#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use Getopt::Long 'HelpMessage';
use Time::HiRes qw( time );
use File::Spec::Functions qw(rel2abs abs2rel);
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                               ---> scafe.workflow.sc.subsample <---
                      <--- workflow, single-cell mode, subsample ctss --->

 Description:
   This workflow subsamples a ctss file, defines tCRE and generate a tCRE UMI/cellbarcode count matrix
   Subsampling is useful to investigate the effect of sequencing depth to tCRE definition

 Usage:
   scafe.workflow.sc.subsample [options] --UMI_CB_ctss_bed_path --run_cellbarcode_path --subsample_num --genome --run_tag --run_outDir
   
   --UMI_CB_ctss_bed_path <required> [string]  ctss file for subsampling, one line one cellbarcode-UMI combination,
                                               *UMI_CB.ctss.bed.gz from scafe.tool.sc.bam_to_ctss.pl, 
                                               4th column cellbarcode-UMI and 5th column is number of unencoded-G
   --run_cellbarcode_path <required> [string]  tsv file contains a list of cell barcodes,
                                               barcodes.tsv.gz from cellranger
   --subsample_num        <required> [integer] number of UMI to be subsampled
   --genome               <required> [string]  name of genome reference, e.g. hg19.gencode_v32lift37
   --run_tag              <required> [string]  prefix for the output files
   --run_outDir           <required> [string]  directory for the output files
   --training_signal_path (optional) [string]  quantitative signal (e.g. ATAC -logP, in bigwig format), or binary genomic 
                                               regions (e.g. annotated CRE, in bed format) used for training of logical 
                                               regression model If null, $usr_glm_model_path must be supplied for 
                                               pre-built logical regression model. It overrides usr_glm_model_path 
                                               (default=null)
   --testing_signal_path  (optional) [string]  quantitative signal (e.g. ATAC -logP, in bigwig format), or binary genomic 
                                               regions (e.g. annotated CRE, in bed format) used for testing the performance 
                                               of the logical regression model. If null, annotated TSS from $genome will be 
                                               used as binary genomic regions. (default=null)
   --max_thread           (optional) [integer] maximum number of parallel threads, capped at 10 to 
                                               avoid memory overflow (default=5)
   --overwrite            (optional) [yes/no]  erase run_outDir before running (default=no)

 Dependencies:
   R packages: 'ROCR','PRROC', 'caret', 'e1071', 'ggplot2', 'scales', 'reshape2'
   bigWigAverageOverBed
   bedGraphToBigWig
   bedtools
   samtools
   paraclu
   paraclu-cut.sh
   tabix
   bgzip

 For demo, cd to SCAFE dir and run,
   scafe.workflow.sc.subsample \
   --overwrite=yes \
   --UMI_CB_ctss_bed_path=./demo/input/sc.subsample/demo.UMI_CB.ctss.bed.gz \
   --run_cellbarcode_path=./demo/input/sc.subsample/demo.barcodes.tsv.gz \
   --subsample_num=100000 \
   --genome=hg19.gencode_v32lift37 \
   --run_tag=demo \
   --run_outDir=./demo/output/sc.subsample/

=head1 VERSION

v0.9.0-beta [March 20, 2021]
	-Initial pre-release

v1.0.0 [June 6, 2022]
	-No update
	-added directionality

v1.0.1 [June 26, 2022]
	-In cluster step, will use unencoded G ctss for hard filtering (--count_ctss_bed_path= option) 

=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startTasks
#
#<section ID="startTasks" num="0">
my $ARGV_ary_ref = [@ARGV];
my ($UMI_CB_ctss_bed_path, $run_cellbarcode_path, $subsample_num, $genome, $training_signal_path, $testing_signal_path, $max_thread, $run_tag, $run_outDir, $overwrite) = &readParameters();#->405
$max_thread = 10 if $max_thread > 10;
my ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath) = &prepDir($run_outDir, $ARGV_ary_ref);#->377
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->352
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_run
#
#<section ID="run" num="1">
my ($path_hsh_ref) = &define_path($run_outDir, $run_tag, $UMI_CB_ctss_bed_path, $run_cellbarcode_path, $training_signal_path, $testing_signal_path, $script_dir);#->173
my ($task_info_hsh_ref) = &define_task($genome, $path_hsh_ref, $max_thread, $subsample_num, $run_tag, $run_outDir);#->221
&run_task($task_info_hsh_ref, $path_hsh_ref, $result_script_dir);#->479
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	general [n=3]:
#		currentTime, logCalledCMDAndScript, readParameters
#
#	unassigned [n=4]:
#		define_path, define_task, prepDir
#		run_task
#
#====================================================================================================================================================#

sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: prepDir|377, run_task|479
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 0_startTasks|117, 1_run|129
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 391, 494, 509, 533, 535, 536, 555
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub define_path {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_run|129
#	secondaryAppearInSection: >none
#	input: $UMI_CB_ctss_bed_path, $run_cellbarcode_path, $run_outDir, $run_tag, $script_dir, $testing_signal_path, $training_signal_path
#	output: $path_hsh_ref
#	toCall: my ($path_hsh_ref) = &define_path($run_outDir, $run_tag, $UMI_CB_ctss_bed_path, $run_cellbarcode_path, $training_signal_path, $testing_signal_path, $script_dir);
#	calledInLine: 132
#....................................................................................................................................................#

	my ($run_outDir, $run_tag, $UMI_CB_ctss_bed_path, $run_cellbarcode_path, $training_signal_path, $testing_signal_path, $script_dir) = @_;
	
	my $path_hsh_ref = {
		'script_dir' => $script_dir,

		'UMI_CB_ctss_bed_path' => $UMI_CB_ctss_bed_path,
		'run_cellbarcode_path' => $run_cellbarcode_path,
		'training_signal_path' => $training_signal_path,
		'testing_signal_path' => $testing_signal_path,

		'CB_ctss_bed_path' => $run_outDir."/subsample_ctss/".$run_tag."/bed/".$run_tag.".subsample.CB.ctss.bed.gz",
		'ung_ctss_bed_path' => $run_outDir."/subsample_ctss/".$run_tag."/bed/".$run_tag.".subsample.unencoded_G.collapse.ctss.bed.gz",
		'collapse_ctss_bed_path' => $run_outDir."/subsample_ctss/".$run_tag."/bed/".$run_tag.".subsample.collapse.ctss.bed.gz",
		'filtered_ctss_bed_path' => $run_outDir."/remove_strand_invader/".$run_tag."/bed/".$run_tag.".pass.ctss.bed.gz",
		'raw_tssCluster_bed_path' => $run_outDir."/cluster/".$run_tag."/bed/".$run_tag.".tssCluster.bed.gz",
		'filtered_tssCluster_info_path' => $run_outDir."/filter/".$run_tag."/log/".$run_tag.".tssCluster.log.tsv",

		'bw_cpm_rev_path' => $run_outDir."/ctss_to_bigwig/".$run_tag."/wig/".$run_tag.".cpm.rev.bw",
		'bw_cpm_fwd_path' => $run_outDir."/ctss_to_bigwig/".$run_tag."/wig/".$run_tag.".cpm.fwd.bw",
		'bw_count_rev_path' => $run_outDir."/ctss_to_bigwig/".$run_tag."/wig/".$run_tag.".count.rev.bw",
		'bw_count_fwd_path' => $run_outDir."/ctss_to_bigwig/".$run_tag."/wig/".$run_tag.".count.fwd.bw",

		'tCRE_bed_path' => $run_outDir."/annotate/".$run_tag."/bed/".$run_tag.".CRE.coord.bed.gz",
		'tCRE_info_path' => $run_outDir."/annotate/".$run_tag."/log/".$run_tag.".CRE.info.tsv.gz",
		'tssCluster_bed_path' => $run_outDir."/annotate/".$run_tag."/bed/".$run_tag.".cluster.coord.bed.gz",
		'tssCluster_info_path' => $run_outDir."/annotate/".$run_tag."/log/".$run_tag.".cluster.info.tsv.gz",
		'directionality_info_path' => $run_outDir."/directionality/".$run_tag."/log/".$run_tag.".directionality.log.tsv.gz",
	};

	foreach my $level (qw/robust lenient default/) {
		$path_hsh_ref->{"$level.filtered_tssCluster_bed_path"} = $run_outDir."/filter/".$run_tag."/bed/".$run_tag.".tssCluster.".$level.".filtered.bed.gz";
	}

	return ($path_hsh_ref);

}
sub define_task {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_run|129
#	secondaryAppearInSection: >none
#	input: $genome, $max_thread, $path_hsh_ref, $run_outDir, $run_tag, $subsample_num
#	output: $task_info_hsh_ref
#	toCall: my ($task_info_hsh_ref) = &define_task($genome, $path_hsh_ref, $max_thread, $subsample_num, $run_tag, $run_outDir);
#	calledInLine: 133
#....................................................................................................................................................#

	my ($genome, $path_hsh_ref, $max_thread, $subsample_num, $run_tag, $run_outDir) = @_;

	my $task_info_hsh_ref = {
		1 => {
			'task_name' => 'subsample_ctss',
			'script_name' => 'scafe.tool.sc.subsample_ctss',
			'param' => [
				['subsample_num', $subsample_num],
				['UMI_CB_ctss_bed_path', $path_hsh_ref->{'UMI_CB_ctss_bed_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/subsample_ctss"],
			],
			'check' => [
				 $path_hsh_ref->{'ung_ctss_bed_path'},
				 $path_hsh_ref->{'collapse_ctss_bed_path'},
				 $path_hsh_ref->{'CB_ctss_bed_path'},
			]
		},
		2 => {
			'task_name' => 'remove_strand_invader',
			'script_name' => 'scafe.tool.cm.remove_strand_invader',
			'param' => [
				['ctss_bed_path', $path_hsh_ref->{'collapse_ctss_bed_path'}],
				['genome', $genome],
				['max_thread', $max_thread],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/remove_strand_invader"],
			],
			'check' => [
				 $path_hsh_ref->{'filtered_ctss_bed_path'},
			]
		},
		3 => {
			'task_name' => 'cluster',
			'script_name' => 'scafe.tool.cm.cluster',
			'param' => [
				['cluster_ctss_bed_path', $path_hsh_ref->{'filtered_ctss_bed_path'}],
				['count_ctss_bed_path', $path_hsh_ref->{'ung_ctss_bed_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/cluster"],
			],
			'check' => [
				 $path_hsh_ref->{'raw_tssCluster_bed_path'},
			]
		},
		4 => {
			'task_name' => 'filter',
			'script_name' => 'scafe.tool.cm.filter',
			'param' => [
				['genome', $genome],
				['training_signal_path', $path_hsh_ref->{'training_signal_path'}],
				['testing_signal_path', $path_hsh_ref->{'testing_signal_path'}],
				['ung_ctss_bed_path', $path_hsh_ref->{'ung_ctss_bed_path'}],
				['tssCluster_bed_path', $path_hsh_ref->{'raw_tssCluster_bed_path'}],
				['ctss_bed_path', $path_hsh_ref->{'filtered_ctss_bed_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/filter"],
			],
			'check' => [
				 $path_hsh_ref->{'default.filtered_tssCluster_bed_path'},
				 $path_hsh_ref->{'robust.filtered_tssCluster_bed_path'},
				 $path_hsh_ref->{'lenient.filtered_tssCluster_bed_path'},
			]
		},
		5 => {
			'task_name' => 'ctss_to_bigwig',
			'script_name' => 'scafe.tool.cm.ctss_to_bigwig',
			'param' => [
				['genome', $genome],
				['ctss_bed_path', $path_hsh_ref->{'filtered_ctss_bed_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/ctss_to_bigwig"],
			],
			'check' => [
				 $path_hsh_ref->{'bw_cpm_rev_path'},
				 $path_hsh_ref->{'bw_cpm_fwd_path'},
				 $path_hsh_ref->{'bw_count_rev_path'},
				 $path_hsh_ref->{'bw_count_fwd_path'},
			]
		},
		6 => {
			'task_name' => 'annotate',
			'script_name' => 'scafe.tool.cm.annotate',
			'param' => [
				['genome', $genome],
				['tssCluster_bed_path', $path_hsh_ref->{"default.filtered_tssCluster_bed_path"}],
				['tssCluster_info_path', $path_hsh_ref->{'filtered_tssCluster_info_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/annotate"],
			],
			'check' => [
				$path_hsh_ref->{"tCRE_bed_path"},
				$path_hsh_ref->{"tCRE_info_path"},
				$path_hsh_ref->{"tssCluster_bed_path"},
				$path_hsh_ref->{"tssCluster_info_path"},
			]
		},
		7 => {
			'task_name' => 'count',
			'script_name' => 'scafe.tool.sc.count',
			'param' => [
				['genome', $genome],
				['countRegion_bed_path', $path_hsh_ref->{"tCRE_bed_path"}],
				['ctss_bed_path', $path_hsh_ref->{'CB_ctss_bed_path'}],
				['cellBarcode_list_path', $path_hsh_ref->{'run_cellbarcode_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/count"],
			],
			'check' => [
				$run_outDir."/count/$run_tag/matrix/matrix.mtx",
				$run_outDir."/count/$run_tag/matrix/genes.tsv",
				$run_outDir."/count/$run_tag/matrix/barcodes.tsv",
			]
		},
		8 => {
			'task_name' => 'directionality',
			'script_name' => 'scafe.tool.cm.directionality',
			'param' => [
				['CRE_bed_path', $path_hsh_ref->{'tCRE_bed_path'}],
				['CRE_info_path', $path_hsh_ref->{'tCRE_info_path'}],
				['ctss_bed_path', $path_hsh_ref->{'filtered_ctss_bed_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/directionality"],
			],
			'check' => [
				$path_hsh_ref->{"directionality_info_path"},
			]
		}
	};
	
	return($task_info_hsh_ref);
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|117
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 124
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub prepDir {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: currentTime|155
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|117
#	secondaryAppearInSection: >none
#	input: $ARGV_ary_ref, $run_outDir
#	output: $ARGVStr, $result_script_dir, $scafe_dir, $scriptAbsPath, $script_dir
#	toCall: my ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath) = &prepDir($run_outDir, $ARGV_ary_ref);
#	calledInLine: 123
#....................................................................................................................................................#
	my ($run_outDir, $ARGV_ary_ref) = @_;

	my $scriptAbsPath = abs_path($0);
	my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @{$ARGV_ary_ref});#->155
	my @path_split = split /\//, $scriptAbsPath;
	my $scafe_dir_index = $#path_split-2;
	my $script_dir_index = $#path_split-1;
	my $scafe_dir = join "/", @path_split[0..$scafe_dir_index];
	my $script_dir = join "/", @path_split[0..$script_dir_index];

	my @mkDirAry;
	my $result_script_dir = "$run_outDir/script/"; push @mkDirAry, $result_script_dir;
	foreach my $dir (@mkDirAry) {system ("mkdir -pm 755 $dir");}

	return ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath);
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|117
#	secondaryAppearInSection: >none
#	input: none
#	output: $UMI_CB_ctss_bed_path, $genome, $max_thread, $overwrite, $run_cellbarcode_path, $run_outDir, $run_tag, $subsample_num, $testing_signal_path, $training_signal_path
#	toCall: my ($UMI_CB_ctss_bed_path, $run_cellbarcode_path, $subsample_num, $genome, $training_signal_path, $testing_signal_path, $max_thread, $run_tag, $run_outDir, $overwrite) = &readParameters();
#	calledInLine: 121
#....................................................................................................................................................#
	
	my ($UMI_CB_ctss_bed_path, $run_cellbarcode_path, $subsample_num, $genome, $training_signal_path, $testing_signal_path, $max_thread, $run_tag, $run_outDir, $overwrite);

	$overwrite = 'no';
	$max_thread = 5;
	
	GetOptions 	(
		"UMI_CB_ctss_bed_path=s"	=>	\$UMI_CB_ctss_bed_path,
		"run_cellbarcode_path=s"	=>	\$run_cellbarcode_path,
		"subsample_num=s"				=>	\$subsample_num,
		"genome=s"						=>	\$genome,
		"run_tag=s"						=>	\$run_tag,
		"run_outDir=s"					=>	\$run_outDir,
		"max_thread:i"					=>	\$max_thread,
		"training_signal_path:s"	=>	\$training_signal_path,
		"testing_signal_path:s"		=>	\$testing_signal_path,
		"overwrite:s"					=>	\$overwrite,
		'help'							=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	my $opt_check_hsh_ref = {
		'UMI_CB_ctss_bed_path' => $UMI_CB_ctss_bed_path,
		'run_cellbarcode_path' => $run_cellbarcode_path,
		'subsample_num' => $subsample_num,
		'genome' => $genome,
		'run_tag' => $run_tag,
		'run_outDir' => $run_outDir,
	};
	
	my $required = 'yes';
	print "\n";
	foreach my $option_name (keys %{$opt_check_hsh_ref}) {
		if (not defined $opt_check_hsh_ref->{$option_name}) {
			print "WARNING: option \"$option_name\" is requied\n";
			$required = 'no';
		}
	}
	if ($required eq 'no') {
		print "WARNING: SCAFE quitting. Please check this help message for required options\n";
		print "\n";
		HelpMessage(1);
	}

	#---check file
	my $file_check_hsh_ref = {
		'UMI_CB_ctss_bed_path' => $UMI_CB_ctss_bed_path,
		'run_cellbarcode_path' => $run_cellbarcode_path,
	};
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}

	system "rm -rf $run_outDir" if ($overwrite eq 'yes');

	chop $run_outDir if ($run_outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $run_outDir/";
	
	return($UMI_CB_ctss_bed_path, $run_cellbarcode_path, $subsample_num, $genome, $training_signal_path, $testing_signal_path, $max_thread, $run_tag, $run_outDir, $overwrite);

}
sub run_task {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: currentTime|155
#	appearInSub: >none
#	primaryAppearInSection: 1_run|129
#	secondaryAppearInSection: >none
#	input: $path_hsh_ref, $result_script_dir, $task_info_hsh_ref
#	output: none
#	toCall: &run_task($task_info_hsh_ref, $path_hsh_ref, $result_script_dir);
#	calledInLine: 134
#....................................................................................................................................................#
	
	my ($task_info_hsh_ref, $path_hsh_ref, $result_script_dir) = @_;
	
	open TASKLOG, ">", "$result_script_dir/task.log.txt";
	print TASKLOG join "", (join "\t", ('0', 'workflow', 'manager', 'started', &currentTime())), "\n";#->155
	foreach my $task_num (sort {$a <=> $b} keys %{$task_info_hsh_ref}) {
		my $task_name = $task_info_hsh_ref->{$task_num}{'task_name'};
		my $script_name = $task_info_hsh_ref->{$task_num}{'script_name'};
		my $result_found = 'yes';
		foreach my $check_path (@{$task_info_hsh_ref->{$task_num}{'check'}}) {
			$result_found = 'no' if not -s $check_path;
		}
		
		if ($result_found eq 'no') {

			print "\n";
			print "#===========================#\n";
			print "Start running $task_name\n";
			print "#===========================#\n";
			print TASKLOG join "", (join "\t", ($task_num, $task_name, $script_name, 'started', &currentTime())), "\n";#->155

			my $script_path = $path_hsh_ref->{'script_dir'}.'/'.$script_name;
			die "script of $task_name does not exist at $script_path\n" if not -s $script_path;
			my @cmd_param_ary = ($script_path);
			foreach my $indiv_param_ary_ref (@{$task_info_hsh_ref->{$task_num}{'param'}}) {
				my ($param_name, $param_val) = @{$indiv_param_ary_ref};
				if (defined $param_val) {#---[2020/10/07 20:32] specifically for skipping training_signal_path if not input
					push @cmd_param_ary, "--$param_name=$param_val";
				}
			}
			my $cmd = join " ", @cmd_param_ary;
			system "$cmd";

			$result_found = 'yes';
			foreach my $check_path (@{$task_info_hsh_ref->{$task_num}{'check'}}) {
				$result_found = 'no' if not -s $check_path;
			}
			
			if ($result_found eq 'yes') {
				print "\n";
				print "#============================================#\n";
				print "Results of $task_name found. Run successfully.\n";
				print "#============================================#\n";
				print TASKLOG join "", (join "\t", ($task_num, $task_name, $script_name, 'successful', &currentTime())), "\n";#->155
			} else {
				print TASKLOG join "", (join "\t", ($task_num, $task_name, $script_name, 'failed', &currentTime())), "\n";#->155
				print TASKLOG join "", (join "\t", ('0', 'workflow', 'workflow', 'failed', &currentTime())), "\n";#->155
				print "\n";
				print "#========================================#\n";
				print "Results of $task_name not found. Quitting.\n";
				print "#========================================#\n";
				die;
			}
			
		} else {
			print "#=====================================#\n";
			print "Results of $task_name found. Skipping.\n";
			print "#=====================================#\n";
		}
	}

	print "\n";
	print "#=====================================================#\n";
	print "Results of all tasks found. All tasks run successfully.\n";
	print "#=====================================================#\n";
	print TASKLOG join "", (join "\t", ('0', 'workflow', 'manager', 'successful', &currentTime())), "\n";#->155
	close TASKLOG;
}

exit;


















































