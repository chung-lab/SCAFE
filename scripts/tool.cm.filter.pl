#!/usr/bin/perl -w

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use List::Util qw (shuffle);
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use URI::Escape;
use Cwd 'abs_path';
use Statistics::Descriptive;
use Math::Round qw (nearest);
use AutoLoader qw/AUTOLOAD/;
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

                      O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                    O~~    O~~ O~~   O~~     O~ ~~     O~~      O~~       
                     O~~      O~~           O~  O~~    O~~      O~~       
                       O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                          O~~ O~~         O~~~~~A O~~  O~~      O~~       
                    O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                      O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA

 Single Cell Analysis of Five'End (SCAFE) Suite: --> tool.cm.filter.pl <--

   This tool filter for genuine TSS clusters based on a logistic regression model on TSS cluster properties.

   tool.cm.filter.pl [options] --ctss_bed_path --ung_ctss_bed_path --tssCluster_bed_path --genome --outputPrefix --outDir
   
 Required:
   --ctss_bed_path           [required] [string]  ctss file contains all ctss,
                                                  *.collapse.ctss.bed.gz from tool.sc.bam_to_ctss.pl, 
                                                  5th column is number reads/UMI
   --ung_ctss_bed_path       [required] [string]  ctss file contains only ctss with unencoded G,
                                                  *.unencoded_G.collapse.ctss.bed.gz from tool.sc.bam_to_ctss.pl, 
                                                  5th column is number reads/UMI
   --tssCluster_bed_path     [required] [string]  bed file contains all TSS clusters,
                                                  *.tssCluster.bed.gz from tool.cm.cluster.pl
   --genome                  [required] [string]  name of genome reference, e.g. hg19.gencode_v32lift37
   --outputPrefix            [required] [string]  prefix for the output files
   --outDir                  [required] [string]  directory for the output files

 Optional:
   --tssCluster_flank_size   [optional] [integer] size of regions (each side) flanking a TSS cluster summit for
                                                  counting UMI/reads for expression levels calculation (default = 75)
   --local_bkgd_extend_size  [optional] [integer] size of regions (each side) flanking a TSS cluster summit for 
                                                  defining the scope for calculating local background (default = 500)
   --min_gold_num            [optional] [integer] minimum number of gold standard regions for training and testing the
                                                  logical regression model (default = 100)
   --training_pct            [optional] [float]   top and bottom percentage of the TSS clusters, ranked by signal in 
                                                  $training_signal_path, used for training of logical regression model
                                                  (default = 5)
   --training_signal_path    [optional] [string]  quantitative signal (e.g. ATAC -logP, in bigwig format), or binary genomic 
                                                  regions (e.g. annotated CRE, in bed format) used for training of logical 
                                                  regression model If null, $usr_glm_model_path must be supplied for 
                                                  pre-built logical regression model. It overrides usr_glm_model_path 
                                                  (default=null)
   --testing_signal_path     [optional] [string]  quantitative signal (e.g. ATAC -logP, in bigwig format), or binary genomic 
                                                  regions (e.g. annotated CRE, in bed format) used for testing the performance 
                                                  of the logical regression model. If null, annotated TSS from $genome will be 
                                                  used as binary genomic regions. (default=null)
   --usr_glm_model_path      [optional] [string]  pre-built logical regression model from the Caret package in R. Used only if 
                                                  training_signal_path is not supplied. Models were pre-built for each genome
                                                  and used as default.
   --Rscript_bin             [optional] [string]  path to the Rscript bin, aim to allow users to supply an R version other the 
                                                  system wide R version. Package Caret must be installed. (Defaul = Rscript)
   --default_cutoff          [optional] [integer] logistic probablity cutoffs for the "default" stringency (Default = 0.5)
   --exclude_chrom_list      [optional] [string]  a list of comma delimited chromosome to be excluded in the training and 
                                                  testing of the logical regression model (Default = chrM)
   --overwrite               [optional] [yes/no]  erase outDir/outputPrefix before running (default=no)

 Dependencies:
   R packages: 'ROCR','PRROC', 'caret', 'e1071', 'ggplot2', 'scales', 'reshape2'
   bedtools
   bigWigAverageOverBed
   
 For demo without training, cd to SCAFE dir and run,
   ./scripts/tool.cm.filter.pl \
   --overwrite=yes \
   --ctss_bed_path=./demo/output/sc.solo/bam_to_ctss/demo/bed/demo.collapse.ctss.bed.gz \
   --ung_ctss_bed_path=./demo/output/sc.solo/bam_to_ctss/demo/bed/demo.unencoded_G.collapse.ctss.bed.gz \
   --tssCluster_bed_path=./demo/output/sc.solo/cluster/demo/bed/demo.tssCluster.bed.gz \
   --genome=hg19.gencode_v32lift37 \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.solo/filter/

 For demo with training, cd to SCAFE dir and run,
   ./scripts/tool.cm.filter.pl \
   --overwrite=yes \
   --ctss_bed_path=./demo/output/sc.solo/bam_to_ctss/demo/bed/demo.collapse.ctss.bed.gz \
   --ung_ctss_bed_path=./demo/output/sc.solo/bam_to_ctss/demo/bed/demo.unencoded_G.collapse.ctss.bed.gz \
   --tssCluster_bed_path=./demo/output/sc.solo/cluster/demo/bed/demo.tssCluster.bed.gz \
   --training_signal_path=./demo/input/atac/demo.atac.bw \
   --testing_signal_path=./demo/input/atac/demo.atac.bw \
   --genome=hg19.gencode_v32lift37 \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.solo/filter/

=head1 VERSION

1.0

=cut#
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->2252
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->686
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($ctss_bed_path, $ung_ctss_bed_path, $tssCluster_bed_path, $training_signal_path, $testing_signal_path, $genome, $tssCluster_flank_size, $local_bkgd_extend_size, $min_gold_num, $training_pct, $Rscript_bin, $usr_glm_model_path, $default_cutoff, $exclude_chrom_list, $outputPrefix, $outDir, $overwrite) = &readParameters();#->2147
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $paramTag = "$outputPrefix";
my $anno_reg_assignment_flank_size = $tssCluster_flank_size;
my $pseudocount = 1;

my $training_pct_hsh_ref = {
	'pos' => $training_pct,
	'neg' => $training_pct,
};

my $testing_pct_hsh_ref = {
	'pos' => 10,
	'neg' => 10,
};

my $trnscpt_density_pct = 0.5;
my $min_density_pct = 0.05;
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineOutDirPath
#
#<section ID="defineOutDirPath" num="2">
my @mkDirAry;

my $result_dir = "$outDir/$paramTag/"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $result_bed_dir = "$result_dir/bed/"; push @mkDirAry, $result_bed_dir;
my $result_log_dir = "$result_dir/log/"; push @mkDirAry, $result_log_dir;
my $result_glm_dir = "$result_dir/glm/"; push @mkDirAry, $result_glm_dir;
my $result_script_dir = "$result_dir/script/"; push @mkDirAry, $result_script_dir;
my $result_tmp_dir = "$result_dir/tmp/"; push @mkDirAry, $result_tmp_dir;

foreach my $dir (@mkDirAry) {system ("mkdir -pm 755 $dir");}

open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&printStartOrFinishMessage("startMessage");#->1910
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->1480

&reportAndLogStatus("Running with following parameters", 10, "\n");#->2230
&reportAndLogStatus("tssCluster_flank_size=$tssCluster_flank_size", 10, "\n");#->2230
&reportAndLogStatus("local_bkgd_extend_size=$local_bkgd_extend_size", 10, "\n");#->2230
&reportAndLogStatus("min_gold_num=$min_gold_num", 10, "\n");#->2230
&reportAndLogStatus("training_pct=$training_pct", 10, "\n");#->2230

#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_getInfoTasks
#
#<section ID="getInfoTasks" num="3">
my ($build_glm_R, $predict_prob_R, $benchmark_roc_R) = &checkRScriptVersion($Rscript_bin);#->600
my ($bedtools_bin) = &checkBedtoolsVersion();#->513
my ($bigWigAverageOverBed_bin) = &checkBigWigAverageOverBedVersion();#->544
my ($mask_tss_region_bed_path, $exon_region_bed_path, $intron_region_bed_path, $background_exon_bed_path, $background_intron_bed_path, $gene_bed_path, $mask_bed_path, $chrom_size_path, $gene_info_path, $tss_pos_bed_path) = &checkRegionBedChromSizeGeneInfoPath($genome);#->647
my ($exclude_chrom_hsh_ref) = &generateExcludeChrHsh($exclude_chrom_list);#->824
my ($chrom_size_hsh_ref) = &getChromSize($chrom_size_path);#->998
my ($gene_info_hsh_ref) = &readGeneInfo($gene_info_path);#->2085
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_backgroundDensityTasks
#
#<section ID="backgroundDensityTasks" num="4">
my ($trnscpt_info_hsh_ref, $trnscpt_bkgd_hsh_ref) = &getTranscriptRegionSize($background_exon_bed_path, $background_intron_bed_path, $gene_info_hsh_ref);#->1252
my ($min_density) = &getBackgroundDensity($trnscpt_info_hsh_ref, $gene_info_hsh_ref, $trnscpt_bkgd_hsh_ref, $ctss_bed_path, $trnscpt_density_pct, $min_density_pct, $bedtools_bin);#->848
&printGeneDensityLog($result_log_dir, $gene_info_hsh_ref, $paramTag);#->1753
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 5_tssClusterPropertiesTasks
#
#<section ID="tssClusterPropertiesTasks" num="5">
my ($tssCluster_summit_bed_path, $tssCluster_summit_anno_flank_bed_path, $tssCluster_info_hsh_ref) = &getTssClusterProperties($tssCluster_bed_path, $ctss_bed_path, $result_bed_dir, $bedtools_bin, $chrom_size_path, $tssCluster_flank_size, $chrom_size_hsh_ref, $anno_reg_assignment_flank_size, $ung_ctss_bed_path, $local_bkgd_extend_size, $mask_tss_region_bed_path, $pseudocount);#->1292
&getGeneTssClusterRanking($tssCluster_summit_bed_path, $tss_pos_bed_path, $tssCluster_info_hsh_ref, $bedtools_bin, $gene_info_hsh_ref, $chrom_size_path);#->1097
&getDistToTSS($tssCluster_summit_bed_path, $tss_pos_bed_path, $tssCluster_info_hsh_ref, $bedtools_bin);#->1063
&getDistToCRE($tssCluster_summit_bed_path, $mask_bed_path, $mask_tss_region_bed_path, $tssCluster_info_hsh_ref, $bedtools_bin);#->1025
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 6_backgroundRelativeExpressionTasks
#
#<section ID="backgroundRelativeExpressionTasks" num="6">
&assignTssClusterToBackgroundRegions($tssCluster_summit_anno_flank_bed_path, $bedtools_bin, $tssCluster_info_hsh_ref, $gene_info_hsh_ref, $exon_region_bed_path, $intron_region_bed_path);#->390
&assignTssClusterToAnnnotationRegions($tssCluster_summit_anno_flank_bed_path, $bedtools_bin, $tssCluster_info_hsh_ref, $gene_info_hsh_ref, $exon_region_bed_path, $intron_region_bed_path, $mask_tss_region_bed_path);#->296
&getBackgroundRelativeExpression($tssCluster_info_hsh_ref, $gene_info_hsh_ref, $min_density, $tssCluster_flank_size, $local_bkgd_extend_size);#->948
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 7_BenchmarkTasks
#
#<section ID="BenchmarkTasks" num="7">
my ($tssCluster_glm_predictors_path, $glm_model_path) = &performGlmTraining($result_tmp_dir, $training_signal_path, $tssCluster_summit_bed_path, $tssCluster_info_hsh_ref, $bigWigAverageOverBed_bin, $bedtools_bin, $training_pct_hsh_ref, $min_gold_num, $result_bed_dir, $mask_tss_region_bed_path, $mask_bed_path, $result_glm_dir, $exclude_chrom_hsh_ref, $build_glm_R, $genome, $Rscript_bin, $testing_signal_path, $testing_pct_hsh_ref, $usr_glm_model_path);#->1588
&predictLogisticProbability($tssCluster_glm_predictors_path, $glm_model_path, $predict_prob_R, $tssCluster_info_hsh_ref, $result_glm_dir, $Rscript_bin, $default_cutoff);#->1636
&performAnnoRegionBenchmark($testing_signal_path, $tssCluster_info_hsh_ref, $result_glm_dir, $exclude_chrom_hsh_ref, $Rscript_bin, $benchmark_roc_R);#->1505
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 8_count
#
#<section ID="count" num="8">
&printTssClusterLog($result_log_dir, $tssCluster_info_hsh_ref, $paramTag);#->2004
&printFilteredBed($tssCluster_bed_path, $tssCluster_info_hsh_ref, $result_bed_dir, $paramTag);#->1697
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 9_finishingTasks
#
#<section ID="finishingTasks" num="9">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->1790
&printStartOrFinishMessage("finishMessage");#->1910
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	checkTools [n=3]:
#		checkBedtoolsVersion, checkBigWigAverageOverBedVersion, checkRScriptVersion
#
#	general [n=8]:
#		checkBedtoolsVersion, checkBigWigAverageOverBedVersion, checkRScriptVersion
#		currentTime, logCalledCMDAndScript, printStartOrFinishMessage
#		readParameters, timeStamp
#
#	getTextInfo [n=1]:
#		readGeneInfo
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=25]:
#		assignTssClusterToAnnnotationRegions, assignTssClusterToBackgroundRegions, buildGlm
#		checkGlmModelRDS, checkRegionBedChromSizeGeneInfoPath, defineGoldenSetForTesting
#		defineGoldenSetForTraining, generateExcludeChrHsh, getBackgroundDensity
#		getBackgroundRelativeExpression, getChromSize, getDistToCRE
#		getDistToTSS, getGeneTssClusterRanking, getGoldenSetBed
#		getGoldenSetBigwig, getTranscriptRegionSize, getTssClusterProperties
#		performAnnoRegionBenchmark, performGlmTraining, predictLogisticProbability
#		printFilteredBed, printGeneDensityLog, printTrainingInput
#		printTssClusterLog
#
#====================================================================================================================================================#

sub assignTssClusterToAnnnotationRegions {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 6_backgroundRelativeExpressionTasks|218
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $exon_region_bed_path, $gene_info_hsh_ref, $intron_region_bed_path, $mask_tss_region_bed_path, $tssCluster_info_hsh_ref, $tssCluster_summit_anno_flank_bed_path
#	output: 
#	toCall: &assignTssClusterToAnnnotationRegions($tssCluster_summit_anno_flank_bed_path, $bedtools_bin, $tssCluster_info_hsh_ref, $gene_info_hsh_ref, $exon_region_bed_path, $intron_region_bed_path, $mask_tss_region_bed_path);
#	calledInLine: 222
#....................................................................................................................................................#
	my ($tssCluster_summit_anno_flank_bed_path, $bedtools_bin, $tssCluster_info_hsh_ref, $gene_info_hsh_ref, $exon_region_bed_path, $intron_region_bed_path, $mask_tss_region_bed_path) = @_;
	
	&reportAndLogStatus("Assigning background regions to tssClusters by summit location", 10, "\n");#->2230

	my $anno_info_hsh_ref = {};
	$anno_info_hsh_ref->{'end5'}{'bed_path'} = $mask_tss_region_bed_path;
	$anno_info_hsh_ref->{'end5'}{'priority'} = 0;
	$anno_info_hsh_ref->{'exon'}{'bed_path'} = $exon_region_bed_path;
	$anno_info_hsh_ref->{'exon'}{'priority'} = 1;
	$anno_info_hsh_ref->{'intron'}{'bed_path'} = $intron_region_bed_path;
	$anno_info_hsh_ref->{'intron'}{'priority'} = 2;
		
	my $check_tssClusterID_hsh_ref = {};

	my $anno_orientation_hsh_ref = {
		'ss' => '-s',
		'as' => '-S',
	};

	#---[2020/05/03 17:22] intersect annotation in order of ss, annotation priority then as, annotation priority
	foreach my $anno_orientation (qw/ss as/) {
		my $anno_orientation_opt = $anno_orientation_hsh_ref->{$anno_orientation};
		foreach my $anno_type (sort {$anno_info_hsh_ref->{$a}{'priority'} <=> $anno_info_hsh_ref->{$b}{'priority'}} keys %{$anno_info_hsh_ref}) {
			&reportAndLogStatus("Intersecting tssClusters with $anno_type in $anno_orientation anno_orientation.", 10, "\n");#->2230
			#---[2019/12/22 23:10] to hold the tssClusterID within this round
			my $anno_bed_path = $anno_info_hsh_ref->{$anno_type}{'bed_path'};
			my $within_region_tssClusterID_hsh_ref = {};
	
			open BEDTOOLSINTERSECT, "$bedtools_bin intersect $anno_orientation_opt -wo -a $tssCluster_summit_anno_flank_bed_path -b $anno_bed_path |";
			while (<BEDTOOLSINTERSECT>) {
				#chr1	11888638	11888649	chr1_11888638_11888649_+	25	+	chr1	11888514	11888681	ENSG00000011021.17;ENSG00000242349.1	2	+	11
				chomp;
				my @splt = split /\t/;
				my $tssClusterID = $splt[3];
				my $geneID_str = $splt[-4];
	
				#---[2019/12/22 23:11] skip if exists in previous round
				next if exists $check_tssClusterID_hsh_ref->{$tssClusterID};
	
				foreach my $geneID ((split /;/, $geneID_str)) {
					$tssCluster_info_hsh_ref->{$tssClusterID}{'anno_type'} = $anno_type;
					$tssCluster_info_hsh_ref->{$tssClusterID}{'anno_orientation'} = $anno_orientation;
					$tssCluster_info_hsh_ref->{$tssClusterID}{'anno_geneID'}{$geneID}++;
					$within_region_tssClusterID_hsh_ref->{$tssClusterID}++;
				}
			}
			close BEDTOOLSINTERSECT;
			my $num_tssCluster_within_region = keys %{$within_region_tssClusterID_hsh_ref};
			&reportAndLogStatus("$num_tssCluster_within_region tssClusters assigned to $anno_type in $anno_orientation anno_orientation.", 10, "\n");#->2230
			#---[2019/12/22 23:10] bookmark the added tssClusterID
			foreach my $tssClusterID (keys %{$within_region_tssClusterID_hsh_ref}) {
				$check_tssClusterID_hsh_ref->{$tssClusterID}++;
			}
		}
	}

	{
		&reportAndLogStatus("adding intergenic annotaton", 10, "\n");#->2230
		my $anno_type = 'intergenic';
		my $anno_orientation = 'ns';
		my $geneID = 'nongenic';
		my $num_tssCluster_within_region = 0;
		foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
			if (not exists $tssCluster_info_hsh_ref->{$tssClusterID}{'anno_type'}) {
				$num_tssCluster_within_region++;
				$tssCluster_info_hsh_ref->{$tssClusterID}{'anno_type'} = $anno_type;
				$tssCluster_info_hsh_ref->{$tssClusterID}{'anno_orientation'} = $anno_orientation;
				$tssCluster_info_hsh_ref->{$tssClusterID}{'anno_geneID'}{$geneID}++;
			}
		}
		&reportAndLogStatus("$num_tssCluster_within_region tssClusters assigned to $anno_type in $anno_orientation anno_orientation.", 10, "\n");#->2230
		
	}

	foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
		my $anno_type = $tssCluster_info_hsh_ref->{$tssClusterID}{'anno_type'};
		my $anno_orientation = $tssCluster_info_hsh_ref->{$tssClusterID}{'anno_orientation'};
		$tssCluster_info_hsh_ref->{$tssClusterID}{'anno_region'} = join ":", ($anno_type,$anno_orientation);
	}

	return ();
}
sub assignTssClusterToBackgroundRegions {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 6_backgroundRelativeExpressionTasks|218
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $exon_region_bed_path, $gene_info_hsh_ref, $intron_region_bed_path, $tssCluster_info_hsh_ref, $tssCluster_summit_anno_flank_bed_path
#	output: 
#	toCall: &assignTssClusterToBackgroundRegions($tssCluster_summit_anno_flank_bed_path, $bedtools_bin, $tssCluster_info_hsh_ref, $gene_info_hsh_ref, $exon_region_bed_path, $intron_region_bed_path);
#	calledInLine: 221
#....................................................................................................................................................#
	my ($tssCluster_summit_anno_flank_bed_path, $bedtools_bin, $tssCluster_info_hsh_ref, $gene_info_hsh_ref, $exon_region_bed_path, $intron_region_bed_path) = @_;
	
	&reportAndLogStatus("Assigning background regions to tssClusters by summit location", 10, "\n");#->2230

	my $anno_info_hsh_ref = {};
	$anno_info_hsh_ref->{'exon'}{'bed_path'} = $exon_region_bed_path;
	$anno_info_hsh_ref->{'exon'}{'priority'} = 1;
	$anno_info_hsh_ref->{'intron'}{'bed_path'} = $intron_region_bed_path;
	$anno_info_hsh_ref->{'intron'}{'priority'} = 2;
		
	my $check_tssClusterID_hsh_ref = {};

	my $bkgd_orientation_hsh_ref = {
		'ss' => '-s',
		'as' => '-S',
	};

	#---[2020/05/03 17:22] intersect annotation in order of ss, annotation priority then as, annotation priority
	foreach my $bkgd_orientation (qw/ss as/) {
		my $bkgd_orientation_opt = $bkgd_orientation_hsh_ref->{$bkgd_orientation};
		foreach my $bkgd_type (sort {$anno_info_hsh_ref->{$a}{'priority'} <=> $anno_info_hsh_ref->{$b}{'priority'}} keys %{$anno_info_hsh_ref}) {
			&reportAndLogStatus("Intersecting tssClusters with $bkgd_type in $bkgd_orientation bkgd_orientation.", 10, "\n");#->2230
			#---[2019/12/22 23:10] to hold the tssClusterID within this round
			my $anno_bed_path = $anno_info_hsh_ref->{$bkgd_type}{'bed_path'};
			my $within_region_tssClusterID_hsh_ref = {};
	
			open BEDTOOLSINTERSECT, "$bedtools_bin intersect $bkgd_orientation_opt -wo -a $tssCluster_summit_anno_flank_bed_path -b $anno_bed_path |";
			while (<BEDTOOLSINTERSECT>) {
				#chr1	11888638	11888649	chr1_11888638_11888649_+	25	+	chr1	11888514	11888681	ENSG00000011021.17;ENSG00000242349.1	2	+	11
				chomp;
				my @splt = split /\t/;
				my $tssClusterID = $splt[3];
				my $geneID_str = $splt[-4];
	
				#---[2019/12/22 23:11] skip if exists in previous round
				next if exists $check_tssClusterID_hsh_ref->{$tssClusterID};
	
				foreach my $geneID ((split /;/, $geneID_str)) {
					$tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_type'} = $bkgd_type;
					$tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_orientation'} = $bkgd_orientation;
					$tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_geneID'}{$geneID}++;
					$within_region_tssClusterID_hsh_ref->{$tssClusterID}++;
				}
			}
			close BEDTOOLSINTERSECT;
			my $num_tssCluster_within_region = keys %{$within_region_tssClusterID_hsh_ref};
			&reportAndLogStatus("$num_tssCluster_within_region tssClusters assigned to $bkgd_type in $bkgd_orientation bkgd_orientation.", 10, "\n");#->2230
			#---[2019/12/22 23:10] bookmark the added tssClusterID
			foreach my $tssClusterID (keys %{$within_region_tssClusterID_hsh_ref}) {
				$check_tssClusterID_hsh_ref->{$tssClusterID}++;
			}
		}
	}

	{
		&reportAndLogStatus("adding intergenic annotaton", 10, "\n");#->2230
		my $bkgd_type = 'intergenic';
		my $bkgd_orientation = 'ns';
		my $geneID = 'nongenic';
		my $num_tssCluster_within_region = 0;
		foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
			if (not exists $tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_type'}) {
				$num_tssCluster_within_region++;
				$tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_type'} = $bkgd_type;
				$tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_orientation'} = $bkgd_orientation;
				$tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_geneID'}{$geneID}++;
			}
		}
		&reportAndLogStatus("$num_tssCluster_within_region tssClusters assigned to $bkgd_type in $bkgd_orientation bkgd_orientation.", 10, "\n");#->2230
	}

	foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
		my $bkgd_type = $tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_type'};
		my $bkgd_orientation = $tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_orientation'};
		$tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_region'} = join ":", ($bkgd_type,$bkgd_orientation);
	}

	return ();
}
sub buildGlm {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: performGlmTraining|1588
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 7_BenchmarkTasks|228
#	input: $Rscript_bin, $build_glm_R, $result_glm_dir, $tssCluster_glm_predictors_path
#	output: $glm_model_path
#	toCall: my ($glm_model_path) = &buildGlm($tssCluster_glm_predictors_path, $build_glm_R, $result_glm_dir, $Rscript_bin);
#	calledInLine: 1626
#....................................................................................................................................................#
	my ($tssCluster_glm_predictors_path, $build_glm_R, $result_glm_dir, $Rscript_bin) = @_;
	
	my $build_glm_dir = "$result_glm_dir/build_glm";
	#system ("rm -Rf $build_glm_dir");
	system ("mkdir -pm 755 $build_glm_dir");
	my $glm_model_path = "$build_glm_dir/combined.predictors.glm.model.RDS";
	my $glm_model_stdout_path = "$build_glm_dir/00_run.stdout.log.txt";
	my $glm_model_stderr_path = "$build_glm_dir/00_run.stderr.log.txt";
	
	&reportAndLogStatus("building glm_model_path", 10, "\n");#->2230
	system "$Rscript_bin $build_glm_R $tssCluster_glm_predictors_path $build_glm_dir 1>$glm_model_stdout_path 2>$glm_model_stderr_path";
	
	if (-s $glm_model_path) {
		&reportAndLogStatus("glm_model_path is generated", 10, "\n");#->2230
	} else {
		die "glm_model_path is not generated. Quitting\n";
	}

	return ($glm_model_path);
}
sub checkBedtoolsVersion {
#....................................................................................................................................................#
#	subroutineCategory: general, checkTools
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 3_getInfoTasks|184
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedtools_bin
#	toCall: my ($bedtools_bin) = &checkBedtoolsVersion();
#	calledInLine: 188
#....................................................................................................................................................#

	my $dirPath = dirname(rel2abs($0));

	my $bedtools_bin = "bedtools";
	
	my $stdOut = `$bedtools_bin --version 2>&1`;
	if ($stdOut =~ m/bedtools v(\S+)/) {
		&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->2230
	} else {
		$bedtools_bin = "$dirPath/../resources/bin/bedtools/bedtools";
		if ($stdOut =~ m/bedtools v(\S+)/) {
			&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->2230
		} else {
			die "bedtools not installed properly. Quitting.\n";
		}
	}
	
	return($bedtools_bin);
}
sub checkBigWigAverageOverBedVersion {
#....................................................................................................................................................#
#	subroutineCategory: general, checkTools
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 3_getInfoTasks|184
#	secondaryAppearInSection: >none
#	input: none
#	output: $bigWigAverageOverBed_bin
#	toCall: my ($bigWigAverageOverBed_bin) = &checkBigWigAverageOverBedVersion();
#	calledInLine: 189
#....................................................................................................................................................#
	
	my $dirPath = dirname(rel2abs($0));

	my $bigWigAverageOverBed_bin = "bigWigAverageOverBed";
	
	my $stdOut = `$bigWigAverageOverBed_bin 2>&1`;
	if ($stdOut =~ m/bigWigAverageOverBed v(\S+)/) {
		&reportAndLogStatus("Checking: bigWigAverageOverBed version: $1", 0, "\n");#->2230
	} else {
		$bigWigAverageOverBed_bin = "$dirPath/../resources/bin/bigWigAverageOverBed/bigWigAverageOverBed";
		if ($stdOut =~ m/bigWigAverageOverBed v(\S+)/) {
			&reportAndLogStatus("Checking: bigWigAverageOverBed version: $1", 0, "\n");#->2230
		} else {
			die "bigWigAverageOverBed is not installed properly. Quitting.\n";
		}
	}
	
	return($bigWigAverageOverBed_bin);
}
sub checkGlmModelRDS {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: performGlmTraining|1588
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 7_BenchmarkTasks|228
#	input: $genome
#	output: $glm_model_path
#	toCall: my ($glm_model_path) = &checkGlmModelRDS($genome);
#	calledInLine: 1630
#....................................................................................................................................................#

	my ($genome) = @_;
	my $dirPath = dirname(rel2abs($0));
	my $glm_model_path = "$dirPath/../resources/genome/$genome/glm/combined.predictors.glm.model.RDS";

	if (-s $glm_model_path) {
		&reportAndLogStatus("Checking: glm_model_path found", 0, "\n");#->2230
	} else {
		die "glm_model_path not found. Quitting.\n";
	}

	return ($glm_model_path);
}
sub checkRScriptVersion {
#....................................................................................................................................................#
#	subroutineCategory: general, checkTools
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 3_getInfoTasks|184
#	secondaryAppearInSection: >none
#	input: $Rscript_bin
#	output: $benchmark_roc_R, $build_glm_R, $predict_prob_R
#	toCall: my ($build_glm_R, $predict_prob_R, $benchmark_roc_R) = &checkRScriptVersion($Rscript_bin);
#	calledInLine: 187
#....................................................................................................................................................#
	
	my ($Rscript_bin) = @_;
	
	my $dirPath = dirname(rel2abs($0));
	my $build_glm_R = "$dirPath/../resources/R/build_glm.R";
	my $predict_prob_R = "$dirPath/../resources/R/predict_prob.R";
	my $benchmark_roc_R = "$dirPath/../resources/R/benchmark_roc.R";

	my $stdOut = `$Rscript_bin --version 2>&1`;
	if ($stdOut =~ m/R scripting front-end version (\S+)/) {
		&reportAndLogStatus("Checking: Rscript version: $1", 0, "\n");#->2230
	} else {
		die "Rscript is not installed properly. Quitting.\n";
	}
	
	if (-s $build_glm_R) {
		&reportAndLogStatus("build_glm_R found.", 0, "\n");#->2230
	} else {
		die "Rscript build_glm_R is not found. Quitting.\n";
	}

	if (-s $predict_prob_R) {
		&reportAndLogStatus("predict_prob_R found.", 0, "\n");#->2230
	} else {
		die "Rscript predict_prob_R is not found. Quitting.\n";
	}

	if (-s $benchmark_roc_R) {
		&reportAndLogStatus("benchmark_roc_R found.", 0, "\n");#->2230
	} else {
		die "Rscript benchmark_roc_R is not found. Quitting.\n";
	}
	
	return($build_glm_R, $predict_prob_R, $benchmark_roc_R);
}
sub checkRegionBedChromSizeGeneInfoPath {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_getInfoTasks|184
#	secondaryAppearInSection: >none
#	input: $genome
#	output: $background_exon_bed_path, $background_intron_bed_path, $chrom_size_path, $exon_region_bed_path, $gene_bed_path, $gene_info_path, $intron_region_bed_path, $mask_bed_path, $mask_tss_region_bed_path, $tss_pos_bed_path
#	toCall: my ($mask_tss_region_bed_path, $exon_region_bed_path, $intron_region_bed_path, $background_exon_bed_path, $background_intron_bed_path, $gene_bed_path, $mask_bed_path, $chrom_size_path, $gene_info_path, $tss_pos_bed_path) = &checkRegionBedChromSizeGeneInfoPath($genome);
#	calledInLine: 190
#....................................................................................................................................................#
	my ($genome) = @_;

	my $dirPath = dirname(rel2abs($0));
	my $mask_tss_region_bed_path = "$dirPath/../resources/genome/$genome/bed/TSS_flank_250.bed.gz";
	my $exon_region_bed_path = "$dirPath/../resources/genome/$genome/bed/exon.bed.gz";
	my $intron_region_bed_path = "$dirPath/../resources/genome/$genome/bed/intron.bed.gz";
	my $gene_bed_path = "$dirPath/../resources/genome/$genome/bed/gene.bed.gz";
	my $background_exon_bed_path = "$dirPath/../resources/genome/$genome/bed/exon.trnscpt_based.subtract_TSS_flank_250.bed.gz";
	my $background_intron_bed_path = "$dirPath/../resources/genome/$genome/bed/intron.trnscpt_based.subtract_TSS_flank_250.bed.gz";
	my $mask_bed_path = "$dirPath/../resources/genome/$genome/bed/mask.bed.gz";
	my $gene_info_path = "$dirPath/../resources/genome/$genome/tsv//gene.info.tsv";
	my $chrom_size_path = "$dirPath/../resources/genome/$genome/tsv/chrom.sizes.tsv";
	my $tss_pos_bed_path = "$dirPath/../resources/genome/$genome/bed/TSS_flank_0.bed.gz";

	die "genome $genome does not have mask_tss_region_bed_path. Please rerun prep_genome step\n" if not -s $mask_tss_region_bed_path;
	die "genome $genome does not have exon_region_bed_path. Please rerun prep_genome step\n" if not -s $exon_region_bed_path;
	die "genome $genome does not have intron_region_bed_path. Please rerun prep_genome step\n" if not -s $intron_region_bed_path;
	die "genome $genome does not have background_exon_bed_path. Please rerun prep_genome step\n" if not -s $background_exon_bed_path;
	die "genome $genome does not have background_intron_bed_path. Please rerun prep_genome step\n" if not -s $background_intron_bed_path;
	die "genome $genome does not have mask_bed_path. Please rerun prep_genome step\n" if not -s $mask_bed_path;
	die "genome $genome does not have gene_info_path. Please rerun prep_genome step\n" if not -s $gene_info_path;
	die "genome $genome does not have chrom_size_path. Please rerun prep_genome step\n" if not -s $chrom_size_path;
	die "genome $genome does not have tss_pos_bed_path. Please rerun prep_genome step\n" if not -s $tss_pos_bed_path;
	die "genome $genome does not have gene_bed_path. Please rerun prep_genome step\n" if not -s $gene_bed_path;

	return ($mask_tss_region_bed_path, $exon_region_bed_path, $intron_region_bed_path, $background_exon_bed_path, $background_intron_bed_path, $gene_bed_path, $mask_bed_path, $chrom_size_path, $gene_info_path, $tss_pos_bed_path);
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|1910, reportAndLogStatus|2230
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|156, 9_finishingTasks|247
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 113, 1926, 1930, 1935, 1939, 2246, 2247
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub defineGoldenSetForTesting {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: getGoldenSetBed|1148, getGoldenSetBigwig|1195, reportAndLogStatus|2230
#	appearInSub: performGlmTraining|1588
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 7_BenchmarkTasks|228
#	input: $bedtools_bin, $bigWigAverageOverBed_bin, $exclude_chrom_hsh_ref, $mask_bed_path, $mask_tss_region_bed_path, $min_gold_num, $result_tmp_dir, $testing_pct_hsh_ref, $testing_signal_path, $training_pct_hsh_ref, $tssCluster_info_hsh_ref, $tssCluster_summit_bed_path
#	output: 
#	toCall: &defineGoldenSetForTesting($tssCluster_summit_bed_path, $tssCluster_info_hsh_ref, $training_pct_hsh_ref, $mask_tss_region_bed_path, $mask_bed_path, $testing_signal_path, $result_tmp_dir, $bedtools_bin, $bigWigAverageOverBed_bin, $testing_pct_hsh_ref, $min_gold_num, $exclude_chrom_hsh_ref);
#	calledInLine: 1610
#....................................................................................................................................................#
	my ($tssCluster_summit_bed_path, $tssCluster_info_hsh_ref, $training_pct_hsh_ref, $mask_tss_region_bed_path, $mask_bed_path, $testing_signal_path, $result_tmp_dir, $bedtools_bin, $bigWigAverageOverBed_bin, $testing_pct_hsh_ref, $min_gold_num, $exclude_chrom_hsh_ref) = @_;
	
	if (-s $testing_signal_path) {
		
		my $train_test = 'test';
		if ($testing_signal_path =~ m/bw$/ or $testing_signal_path =~ m/bigwig$/) {

			my $num_tssCluster = keys %{$tssCluster_info_hsh_ref};
			my $pos_gold_target_num = int($num_tssCluster*($testing_pct_hsh_ref->{'pos'}/100));
			my $neg_gold_target_num = int($num_tssCluster*($testing_pct_hsh_ref->{'neg'}/100));
			$pos_gold_target_num = $min_gold_num if $min_gold_num > $pos_gold_target_num;
			$neg_gold_target_num = $min_gold_num if $min_gold_num > $neg_gold_target_num;
			my $benchmark_signal_score_path = "$result_tmp_dir/benchmark_signal_score.txt";
			my $bw_signal_path = $testing_signal_path;
			my $tssCluster_intersect_reg_bed_path = $tssCluster_summit_bed_path;
			&getGoldenSetBigwig($bigWigAverageOverBed_bin, $bw_signal_path, $tssCluster_intersect_reg_bed_path, $benchmark_signal_score_path, $tssCluster_info_hsh_ref, $train_test, $exclude_chrom_hsh_ref, $pos_gold_target_num, $neg_gold_target_num);#->1195

		} elsif ($testing_signal_path =~ m/bed$/ or $testing_signal_path =~ m/bed.gz$/) {

			my $max_dist_to_bed_region = 0;
			my $min_dist_to_bed_region = 100;
			my $bed_signal_path = $testing_signal_path;
			&getGoldenSetBed($bed_signal_path, $exclude_chrom_hsh_ref, $tssCluster_info_hsh_ref, $max_dist_to_bed_region, $min_dist_to_bed_region, $tssCluster_summit_bed_path, $train_test, $bedtools_bin);#->1148
		
		} else {
			die "testing_signal_path must be bed or bigwig\n";
		}

	} else {

		&reportAndLogStatus("defining goldenset by annotated TSS and CRE for testing", 10, "\n");#->2230

		my $max_dist_to_anno_tss = 250;
		my $min_dist_to_anno_cre = 10;
		my $num_gold_pos = 0;
		my $num_gold_neg = 0;
		foreach my $tssClusterID (sort {$tssCluster_info_hsh_ref->{$a}{'dist_to_anno_tss'} <=> $tssCluster_info_hsh_ref->{$b}{'dist_to_anno_tss'}} keys %{$tssCluster_info_hsh_ref}) {
			$tssCluster_info_hsh_ref->{$tssClusterID}{'test_in_gold_pos'} = 'no';
			my $dist_to_anno_tss = $tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_tss'};
			my $max_gene_rank = $tssCluster_info_hsh_ref->{$tssClusterID}{'max_gene_rank'};
			next if $dist_to_anno_tss == -1;
			if ($dist_to_anno_tss <= $max_dist_to_anno_tss and $max_gene_rank == 1) {
				#---[2020/09/29 4:31] take only the cluster that is max_gene_rank is 1
				$tssCluster_info_hsh_ref->{$tssClusterID}{'test_binary'} = 1;
				$tssCluster_info_hsh_ref->{$tssClusterID}{'test_in_gold_value'} = $dist_to_anno_tss;
				$num_gold_pos++;
			}
		}

		foreach my $tssClusterID (sort {$tssCluster_info_hsh_ref->{$b}{'dist_to_anno_cre'} <=> $tssCluster_info_hsh_ref->{$a}{'dist_to_anno_cre'}} keys %{$tssCluster_info_hsh_ref}) {
			$tssCluster_info_hsh_ref->{$tssClusterID}{'test_in_gold_neg'} = 'no';
			my $dist_to_anno_cre = $tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_cre'};
			next if $dist_to_anno_cre == -1;
			#last if $num_tssCluster_in_golden_negative_region >= $neg_gold_target_num;
			if ($dist_to_anno_cre >= $min_dist_to_anno_cre) {
				$tssCluster_info_hsh_ref->{$tssClusterID}{'test_binary'} = 0;
				$tssCluster_info_hsh_ref->{$tssClusterID}{'test_in_gold_value'} = $dist_to_anno_cre;
				$num_gold_neg++;
			}
		}

		&reportAndLogStatus("num_gold_pos for testing =$num_gold_pos", 10, "\n");#->2230
		&reportAndLogStatus("num_gold_neg for testing =$num_gold_neg", 10, "\n");#->2618	#->2230

	}

	return ();
}
sub defineGoldenSetForTraining {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: getGoldenSetBed|1148, getGoldenSetBigwig|1195
#	appearInSub: performGlmTraining|1588
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 7_BenchmarkTasks|228
#	input: $bedtools_bin, $bigWigAverageOverBed_bin, $exclude_chrom_hsh_ref, $min_gold_num, $result_tmp_dir, $training_pct_hsh_ref, $training_signal_path, $tssCluster_info_hsh_ref, $tssCluster_summit_bed_path
#	output: 
#	toCall: &defineGoldenSetForTraining($result_tmp_dir, $training_signal_path, $tssCluster_summit_bed_path, $tssCluster_info_hsh_ref, $bigWigAverageOverBed_bin, $bedtools_bin, $training_pct_hsh_ref, $min_gold_num, $exclude_chrom_hsh_ref);
#	calledInLine: 1613
#....................................................................................................................................................#
	my ($result_tmp_dir, $training_signal_path, $tssCluster_summit_bed_path, $tssCluster_info_hsh_ref, $bigWigAverageOverBed_bin, $bedtools_bin, $training_pct_hsh_ref, $min_gold_num, $exclude_chrom_hsh_ref) = @_;

	my $train_test = 'train';

	if ($training_signal_path =~ m/bw$/ or $training_signal_path =~ m/bigwig$/) {

		my $num_tssCluster = keys %{$tssCluster_info_hsh_ref};
		my $pos_gold_target_num = int($num_tssCluster*($training_pct_hsh_ref->{'pos'}/100));
		my $neg_gold_target_num = int($num_tssCluster*($training_pct_hsh_ref->{'neg'}/100));
		$pos_gold_target_num = $min_gold_num if $min_gold_num > $pos_gold_target_num;
		$neg_gold_target_num = $min_gold_num if $min_gold_num > $neg_gold_target_num;
		my $benchmark_signal_score_path = "$result_tmp_dir/benchmark_signal_score.txt";
		my $bw_signal_path = $training_signal_path;
		&getGoldenSetBigwig($bigWigAverageOverBed_bin, $bw_signal_path, $tssCluster_summit_bed_path, $benchmark_signal_score_path, $tssCluster_info_hsh_ref, $train_test, $exclude_chrom_hsh_ref, $pos_gold_target_num, $neg_gold_target_num);#->1195

	} elsif ($training_signal_path =~ m/bed$/ or $training_signal_path =~ m/bed.gz$/) {

		my $max_dist_to_bed_region = 0;
		my $min_dist_to_bed_region = 100;
		my $bed_signal_path = $training_signal_path;
		&getGoldenSetBed($bed_signal_path, $exclude_chrom_hsh_ref, $tssCluster_info_hsh_ref, $max_dist_to_bed_region, $min_dist_to_bed_region, $tssCluster_summit_bed_path, $train_test, $bedtools_bin);#->1148
		
	} else {
		die "training_signal_path must be bed or bigwig\n";
	}

	return ();
}
sub generateExcludeChrHsh {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 1_defineHardCodedParam|132
#	secondaryAppearInSection: >none
#	input: $exclude_chrom_list
#	output: $exclude_chrom_hsh_ref
#	toCall: my ($exclude_chrom_hsh_ref) = &generateExcludeChrHsh($exclude_chrom_list);
#	calledInLine: 151
#....................................................................................................................................................#
	my ($exclude_chrom_list) = @_;
	
	my $exclude_chrom_hsh_ref = {};
	if ($exclude_chrom_list ne 'null') {
		foreach my $exclu_chrom (split /\,/, $exclude_chrom_list) {
			&reportAndLogStatus("$exclu_chrom will be excluded from training and testing", 10, "\n");#->2230
			$exclude_chrom_hsh_ref->{$exclu_chrom} = 1;
		}
	}

	return ($exclude_chrom_hsh_ref);
}
sub getBackgroundDensity {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 4_backgroundDensityTasks|197
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $ctss_bed_path, $gene_info_hsh_ref, $min_density_pct, $trnscpt_bkgd_hsh_ref, $trnscpt_density_pct, $trnscpt_info_hsh_ref
#	output: $min_density
#	toCall: my ($min_density) = &getBackgroundDensity($trnscpt_info_hsh_ref, $gene_info_hsh_ref, $trnscpt_bkgd_hsh_ref, $ctss_bed_path, $trnscpt_density_pct, $min_density_pct, $bedtools_bin);
#	calledInLine: 201
#....................................................................................................................................................#
	my ($trnscpt_info_hsh_ref, $gene_info_hsh_ref, $trnscpt_bkgd_hsh_ref, $ctss_bed_path, $trnscpt_density_pct, $min_density_pct, $bedtools_bin) = @_;

	my @all_non_zero_density_array = ();

	foreach my $exon_intron (keys %{$trnscpt_bkgd_hsh_ref}) {
		foreach my $trnscptID (keys %{$trnscpt_info_hsh_ref}) {
			foreach my $bkgd_orientation (qw/ss as/) {
				$trnscpt_info_hsh_ref->{$trnscptID}{'count'}{$exon_intron}{$bkgd_orientation} = 1;
			}
		}
		&reportAndLogStatus("getting $exon_intron background count", 10, "\n");#->2230
		my $exon_intron_bed_path = $trnscpt_bkgd_hsh_ref->{$exon_intron} ;
		open BEDTOOLS, "$bedtools_bin intersect -wo -a $exon_intron_bed_path -b $ctss_bed_path | cut -f 4,6,11,12 |";
		while (<BEDTOOLS>) {
			chomp;
			#chr10	76184022	76284872	ENSG00000156110.14_4|ENST00000672920.1_1	1	+	chr10	76211833	76211834	1	1	+	1
			#chr10	76184022	76284872	ENSG00000156110.14_4|ENST00000672920.1_1	1	+	chr10	76213630	76213631	1	1	+	1
			#chr10	76184022	76284872	ENSG00000156110.14_4|ENST00000672920.1_1	1	+	chr10	76215039	76215040	1	1	+	1
			#chr10	76184022	76284872	ENSG00000156110.14_4|ENST00000672920.1_1	1	+	chr10	76215901	76215902	1	1	+	1

			my ($IDstr, $gene_strand, $count, $ctss_strand) = split /\t/;
			my $bkgd_orientation = 'ss';
			$bkgd_orientation = 'as' if $gene_strand ne $ctss_strand;
			my ($geneID, $trnscptID_str) = split /\|/, $IDstr;
			foreach my $trnscptID (split /;/, $trnscptID_str) {
				$trnscpt_info_hsh_ref->{$trnscptID}{'count'}{$exon_intron}{$bkgd_orientation} += $count;
			}
		}
		close BEDTOOLS;

		foreach my $trnscptID (keys %{$trnscpt_info_hsh_ref}) {
			if (exists $trnscpt_info_hsh_ref->{$trnscptID}{'size'}{$exon_intron}) {
				my $size = $trnscpt_info_hsh_ref->{$trnscptID}{'size'}{$exon_intron};
				foreach my $bkgd_orientation (qw/ss as/) {
					my $count = $trnscpt_info_hsh_ref->{$trnscptID}{'count'}{$exon_intron}{$bkgd_orientation};
					$trnscpt_info_hsh_ref->{$trnscptID}{'density'}{$exon_intron}{$bkgd_orientation} = sprintf "%.2e", $count/$size;
				}
			}
		}
		
		foreach my $geneID (keys %{$gene_info_hsh_ref}) {
			foreach my $bkgd_orientation (qw/ss as/) {
				my @density_ary = ();
				foreach my $trnscptID (keys %{$gene_info_hsh_ref->{$geneID}{'trnscptID'}}) {
					if (exists $trnscpt_info_hsh_ref->{$trnscptID}{'density'}{$exon_intron}) {
						my $density = $trnscpt_info_hsh_ref->{$trnscptID}{'density'}{$exon_intron}{$bkgd_orientation};
						if ($density > 0) {
							push @density_ary, $density;
						}
					}
				}
				my $density = 0;
				@density_ary = sort {$a <=> $b} @density_ary;
				my $n = @density_ary;
				if ($n > 0) {
					foreach my $i (0..$#density_ary) {
						$density = $density_ary[$i] if ($i <= $n*$trnscpt_density_pct);
					}
				}
				if ($density > 0) {
					push @all_non_zero_density_array, $density
				}
				$gene_info_hsh_ref->{$geneID}{'density'}{$exon_intron}{$bkgd_orientation} = $density;
			}
		}
	}
	
	@all_non_zero_density_array = sort {$a <=> $b} @all_non_zero_density_array;
	my $n = @all_non_zero_density_array;
	my $min_density;
	foreach my $i (0..$#all_non_zero_density_array) {
		$min_density = $all_non_zero_density_array[$i] if ($i <= $n*$min_density_pct);
	}
	
	#&reportAndLogStatus("assign min_density=$min_density", 10, "\n");#->2230
	#foreach my $geneID (sort keys %{$gene_info_hsh_ref}) {
	#	foreach my $exon_intron (sort keys %{$gene_info_hsh_ref->{$geneID}{'density'}}) {
	#		foreach my $bkgd_orientation (sort keys %{$gene_info_hsh_ref->{$geneID}{'density'}{$exon_intron}}) {
	#			my $density = $gene_info_hsh_ref->{$geneID}{'density'}{$exon_intron}{$bkgd_orientation};
	#			if ($density < $min_density) {
	#				$gene_info_hsh_ref->{$geneID}{'density'}{$exon_intron}{$bkgd_orientation} = $min_density;
	#			}
	#		}
	#	}
	#}

	return ($min_density);
}
sub getBackgroundRelativeExpression {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 6_backgroundRelativeExpressionTasks|218
#	secondaryAppearInSection: >none
#	input: $gene_info_hsh_ref, $local_bkgd_extend_size, $min_density, $tssCluster_flank_size, $tssCluster_info_hsh_ref
#	output: 
#	toCall: &getBackgroundRelativeExpression($tssCluster_info_hsh_ref, $gene_info_hsh_ref, $min_density, $tssCluster_flank_size, $local_bkgd_extend_size);
#	calledInLine: 223
#....................................................................................................................................................#
	my ($tssCluster_info_hsh_ref, $gene_info_hsh_ref, $min_density, $tssCluster_flank_size, $local_bkgd_extend_size) = @_;
	
	&reportAndLogStatus("getting background relative expression", 10, "\n");#->2230
	
	foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
	
		my $local_bkgd_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'local_bkgd_count'};
		my $local_bkgd_size = $tssCluster_info_hsh_ref->{$tssClusterID}{'local_bkgd_size'};
		my $count = $tssCluster_info_hsh_ref->{$tssClusterID}{'count'};
		my $size = $tssCluster_info_hsh_ref->{$tssClusterID}{'size'};
		my $flank_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'flank_count'};
		my $bkgd_type = $tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_type'};
		my $bkgd_orientation = $tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_orientation'};
		my $bkgd_geneID;
		foreach my $geneID (sort {$tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_geneID'}{$b} <=> $tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_geneID'}{$a}} keys %{$tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_geneID'}}) {
			$bkgd_geneID = $geneID;
			last;
		}
		my $density;
		if ($bkgd_type eq 'intergenic') {
			$density = $local_bkgd_count/$local_bkgd_size;
			
		} else {
			my $exon_intron = $bkgd_type;
			$density = $gene_info_hsh_ref->{$bkgd_geneID}{'density'}{$exon_intron}{$bkgd_orientation};
		}
		
		$density = $min_density if $density < $min_density;
		
		my $bkgd_rltv_expr = log($flank_count/($density*$tssCluster_flank_size*2))/log(2);
		#my $bkgd_rltv_expr = log($count/($density*$size))/log(2);
		$tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_rltv_expr'} = sprintf "%.2e", $bkgd_rltv_expr;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'density'} = $density;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_geneID'} = $bkgd_geneID;
	}

	return ();
}
sub getChromSize {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 3_getInfoTasks|184
#	secondaryAppearInSection: >none
#	input: $chrom_size_path
#	output: $chrom_size_hsh_ref
#	toCall: my ($chrom_size_hsh_ref) = &getChromSize($chrom_size_path);
#	calledInLine: 191
#....................................................................................................................................................#
	my ($chrom_size_path) = @_;
	
	&reportAndLogStatus("getting chrom size", 10, "\n");#->2230
	my $chrom_size_hsh_ref = {};
	open CHROM, "<", $chrom_size_path;
	while (<CHROM>) {
		chomp;
		my ($chrom, $size) = split /\t/;
		$chrom_size_hsh_ref->{$chrom} = $size;
		&reportAndLogStatus("chromosome $chrom with size $size stored", 10, "\n");#->2230
	}
	close CHROM;
	
	return ($chrom_size_hsh_ref);
}
sub getDistToCRE {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 5_tssClusterPropertiesTasks|207
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $mask_bed_path, $mask_tss_region_bed_path, $tssCluster_info_hsh_ref, $tssCluster_summit_bed_path
#	output: 
#	toCall: &getDistToCRE($tssCluster_summit_bed_path, $mask_bed_path, $mask_tss_region_bed_path, $tssCluster_info_hsh_ref, $bedtools_bin);
#	calledInLine: 213
#....................................................................................................................................................#
	my ($tssCluster_summit_bed_path, $mask_bed_path, $mask_tss_region_bed_path, $tssCluster_info_hsh_ref, $bedtools_bin) = @_;

	&reportAndLogStatus("getting distance to annotated cre", 10, "\n");#->2230
	
	foreach my $cre_bed_path ($mask_tss_region_bed_path, $mask_bed_path) {
		open BEDTOOLS, "$bedtools_bin closest -d -a $tssCluster_summit_bed_path -b $cre_bed_path |";
		while (<BEDTOOLS>) {
			chomp;
			my @splt = split /\t/;
			my $tssClusterID = $splt[3];
			my $dist_to_anno_cre = $splt[-1];
			if (not exists $tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_cre'}) {
				$tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_cre'} = $dist_to_anno_cre;
			} elsif ($dist_to_anno_cre < $tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_cre'}) {
				$tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_cre'} = $dist_to_anno_cre;
			}
		}
		close BEDTOOLS;
	}

	foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
		$tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_cre'} = -1 if not exists $tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_cre'};
	}

	return ();
}
sub getDistToTSS {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 5_tssClusterPropertiesTasks|207
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $tssCluster_info_hsh_ref, $tssCluster_summit_bed_path, $tss_pos_bed_path
#	output: 
#	toCall: &getDistToTSS($tssCluster_summit_bed_path, $tss_pos_bed_path, $tssCluster_info_hsh_ref, $bedtools_bin);
#	calledInLine: 212
#....................................................................................................................................................#
	my ($tssCluster_summit_bed_path, $tss_pos_bed_path, $tssCluster_info_hsh_ref, $bedtools_bin) = @_;

	&reportAndLogStatus("getting distance to annotated tss", 10, "\n");#->2230
	
	foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
		$tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_tss'} = -1;
	}
	
	open BEDTOOLS, "$bedtools_bin closest -s -d -a $tssCluster_summit_bed_path -b $tss_pos_bed_path | ";
	while (<BEDTOOLS>) {
		chomp;
		my @splt = split /\t/;
		my $tssClusterID = $splt[3];
		my $dist_to_anno_tss = $splt[-1];
		if (exists $tssCluster_info_hsh_ref->{$tssClusterID}) {
			$tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_tss'} = $dist_to_anno_tss;
		}
	}
	close BEDTOOLS;
	
	return ();
}
sub getGeneTssClusterRanking {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 5_tssClusterPropertiesTasks|207
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $chrom_size_path, $gene_info_hsh_ref, $tssCluster_info_hsh_ref, $tssCluster_summit_bed_path, $tss_pos_bed_path
#	output: 
#	toCall: &getGeneTssClusterRanking($tssCluster_summit_bed_path, $tss_pos_bed_path, $tssCluster_info_hsh_ref, $bedtools_bin, $gene_info_hsh_ref, $chrom_size_path);
#	calledInLine: 211
#....................................................................................................................................................#
	my ($tssCluster_summit_bed_path, $tss_pos_bed_path, $tssCluster_info_hsh_ref, $bedtools_bin, $gene_info_hsh_ref, $chrom_size_path) = @_;

	&reportAndLogStatus("getting gene tssCluster ranking", 10, "\n");#->2230
	
	foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
		$tssCluster_info_hsh_ref->{$tssClusterID}{'max_gene_rank'} = -1;
	}
	
	open BEDTOOLS, "$bedtools_bin slop -b 100 -i $tss_pos_bed_path -g $chrom_size_path | $bedtools_bin intersect -wo -s -a $tssCluster_summit_bed_path -b stdin | cut -f 4,10 |";
	while (<BEDTOOLS>) {
		chomp;

		my ($tssClusterID, $geneID_str) = split /\t/;
		if (exists $tssCluster_info_hsh_ref->{$tssClusterID}) {
			foreach my $geneID (split /;/, $geneID_str) {
				$gene_info_hsh_ref->{$geneID}{'tssClusterID'}{$tssClusterID} = $tssCluster_info_hsh_ref->{$tssClusterID}{'max'};
				$tssCluster_info_hsh_ref->{$tssClusterID}{'geneID'}{$geneID}++;
			}
		}
	}
	close BEDTOOLS;
	
	foreach my $geneID (keys %{$gene_info_hsh_ref}) {
		if (exists $gene_info_hsh_ref->{$geneID}{'tssClusterID'}) {
			my $tssCluster_max_hsh_ref = $gene_info_hsh_ref->{$geneID}{'tssClusterID'};
			my $rank = 1;
			foreach my $tssClusterID (sort {$tssCluster_max_hsh_ref->{$b} <=> $tssCluster_max_hsh_ref->{$a}} keys %{$tssCluster_max_hsh_ref}) {
				if ($tssCluster_info_hsh_ref->{$tssClusterID}{'max_gene_rank'} == -1) {
					$tssCluster_info_hsh_ref->{$tssClusterID}{'max_gene_rank'} = $rank;
				} elsif ($rank < $tssCluster_info_hsh_ref->{$tssClusterID}{'max_gene_rank'}) {
					$tssCluster_info_hsh_ref->{$tssClusterID}{'max_gene_rank'} = $rank;
				}
				$rank++;
			}
		}
	}

	return ();
}
sub getGoldenSetBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: defineGoldenSetForTesting|704, defineGoldenSetForTraining|784
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $bed_signal_path, $bedtools_bin, $exclude_chrom_hsh_ref, $max_dist_to_bed_region, $min_dist_to_bed_region, $train_test, $tssCluster_info_hsh_ref, $tssCluster_summit_bed_path
#	output: 
#	toCall: &getGoldenSetBed($bed_signal_path, $exclude_chrom_hsh_ref, $tssCluster_info_hsh_ref, $max_dist_to_bed_region, $min_dist_to_bed_region, $tssCluster_summit_bed_path, $train_test, $bedtools_bin);
#	calledInLine: 737, 815
#....................................................................................................................................................#
	my ($bed_signal_path, $exclude_chrom_hsh_ref, $tssCluster_info_hsh_ref, $max_dist_to_bed_region, $min_dist_to_bed_region, $tssCluster_summit_bed_path, $train_test, $bedtools_bin) = @_;

	my $bed_dist_hsh_ref = {};
	
	open BEDTOOLS, "$bedtools_bin closest -d -a $tssCluster_summit_bed_path -b $bed_signal_path | ";
	while (<BEDTOOLS>) {
		chomp;
		my @splt = split /\t/;
		my $tssClusterID = $splt[3];
		my $bed_dist = $splt[-1];
		die if not exists $tssCluster_info_hsh_ref->{$tssClusterID};
		$tssCluster_info_hsh_ref->{$tssClusterID}{$train_test.'_in_gold_value'} = $bed_dist;
	}
	close BEDTOOLS;

	my $num_gold_pos = 0;
	my $num_gold_neg = 0;
	foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
		next if exists $exclude_chrom_hsh_ref->{$tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'}};
		my $bed_dist = $tssCluster_info_hsh_ref->{$tssClusterID}{$train_test.'_in_gold_value'};
		next if $bed_dist == -1;
		if ($bed_dist <= $max_dist_to_bed_region) {
			$tssCluster_info_hsh_ref->{$tssClusterID}{$train_test.'_binary'} = 1;
			$num_gold_pos++;
		} elsif ($bed_dist >= $min_dist_to_bed_region) {
			$tssCluster_info_hsh_ref->{$tssClusterID}{$train_test.'_binary'} = 0;
			$num_gold_neg++;
		}
	}
	
	&reportAndLogStatus("$train_test num_gold_pos=$num_gold_pos", 10, "\n");#->2230
	&reportAndLogStatus("$train_test num_gold_neg=$num_gold_neg", 10, "\n");#->2230

	return ();
}
sub getGoldenSetBigwig {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: defineGoldenSetForTesting|704, defineGoldenSetForTraining|784
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $benchmark_signal_score_path, $bigWigAverageOverBed_bin, $bw_signal_path, $exclude_chrom_hsh_ref, $neg_gold_target_num, $pos_gold_target_num, $train_test, $tssCluster_info_hsh_ref, $tssCluster_intersect_reg_bed_path
#	output: 
#	toCall: &getGoldenSetBigwig($bigWigAverageOverBed_bin, $bw_signal_path, $tssCluster_intersect_reg_bed_path, $benchmark_signal_score_path, $tssCluster_info_hsh_ref, $train_test, $exclude_chrom_hsh_ref, $pos_gold_target_num, $neg_gold_target_num);
#	calledInLine: 730, 808
#....................................................................................................................................................#
	my ($bigWigAverageOverBed_bin, $bw_signal_path, $tssCluster_intersect_reg_bed_path, $benchmark_signal_score_path, $tssCluster_info_hsh_ref, $train_test, $exclude_chrom_hsh_ref, $pos_gold_target_num, $neg_gold_target_num) = @_;


	&reportAndLogStatus("defining $train_test goldenset by bigwig score", 10, "\n");#->2230
	system "$bigWigAverageOverBed_bin $bw_signal_path $tssCluster_intersect_reg_bed_path $benchmark_signal_score_path 2>/dev/null";
	my $bw_score_hsh_ref = {};
	open BWSCORE, "<", $benchmark_signal_score_path;
	while (<BWSCORE>) {
		#chr1_14641_14658_-	1	1	0.35957	0.35957	0.35957
		#chr1_14682_14767_-	1	1	0.35957	0.35957	0.35957
		chomp;
		my ($tssClusterID, undef, undef, $bw_score) = split /\t/;
		die if not exists $tssCluster_info_hsh_ref->{$tssClusterID};
		$bw_score_hsh_ref->{$tssClusterID} = $bw_score;
		$tssCluster_info_hsh_ref->{$tssClusterID}{$train_test.'_bwscore'} = $bw_score;
	}
	close BWSCORE;
	
	my $num_gold_pos = 0;
	foreach my $tssClusterID (sort {$bw_score_hsh_ref->{$b} <=> $bw_score_hsh_ref->{$a}} keys %{$bw_score_hsh_ref}) {

		next if exists $exclude_chrom_hsh_ref->{$tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'}};
		if ($num_gold_pos <= $pos_gold_target_num) {
			$tssCluster_info_hsh_ref->{$tssClusterID}{$train_test.'_in_gold_value'} = $bw_score_hsh_ref->{$tssClusterID};
			$tssCluster_info_hsh_ref->{$tssClusterID}{$train_test.'_binary'} = 1;
			$num_gold_pos++;
		}
	}

	my $num_gold_neg = 0;
	foreach my $tssClusterID (sort {$bw_score_hsh_ref->{$a} <=> $bw_score_hsh_ref->{$b}} keys %{$bw_score_hsh_ref}) {
	
		next if exists $exclude_chrom_hsh_ref->{$tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'}};
		if ($num_gold_neg <= $neg_gold_target_num) {
			$tssCluster_info_hsh_ref->{$tssClusterID}{$train_test.'_in_gold_value'} = $bw_score_hsh_ref->{$tssClusterID};
			$tssCluster_info_hsh_ref->{$tssClusterID}{$train_test.'_binary'} = 0;
			$num_gold_neg++;
		}
	}

	&reportAndLogStatus("$train_test num_gold_pos=$num_gold_pos", 10, "\n");#->2230
	&reportAndLogStatus("$train_test num_gold_neg=$num_gold_neg", 10, "\n");#->2230

	return ();
}
sub getTranscriptRegionSize {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 4_backgroundDensityTasks|197
#	secondaryAppearInSection: >none
#	input: $background_exon_bed_path, $background_intron_bed_path, $gene_info_hsh_ref
#	output: $trnscpt_bkgd_hsh_ref, $trnscpt_info_hsh_ref
#	toCall: my ($trnscpt_info_hsh_ref, $trnscpt_bkgd_hsh_ref) = &getTranscriptRegionSize($background_exon_bed_path, $background_intron_bed_path, $gene_info_hsh_ref);
#	calledInLine: 200
#....................................................................................................................................................#
	my ($background_exon_bed_path, $background_intron_bed_path, $gene_info_hsh_ref) = @_;
	
	my $trnscpt_bkgd_hsh_ref = {
		'exon' => $background_exon_bed_path,
		'intron' => $background_intron_bed_path,
	};
	
	my $trnscpt_info_hsh_ref = {};
	foreach my $exon_intron (keys %{$trnscpt_bkgd_hsh_ref}) {
		&reportAndLogStatus("getting $exon_intron background size", 10, "\n");#->2230
		my $exon_intron_bed_path = $trnscpt_bkgd_hsh_ref->{$exon_intron} ;
		open BED, " gzip -dc $trnscpt_bkgd_hsh_ref->{$exon_intron} |";
		while (<BED>) {
			chomp;
			my ($chrom, $chromStart, $chromEnd, $IDstr, $score, $strand) = split /\t/;
			my $size = $chromEnd - $chromStart + 1;
			my ($geneID, $trnscptID_str) = split /\|/, $IDstr;
			foreach my $trnscptID (split /;/, $trnscptID_str) {
				$trnscpt_info_hsh_ref->{$trnscptID}{'geneID'} = $geneID;
				$trnscpt_info_hsh_ref->{$trnscptID}{'size'}{$exon_intron}+=$size;
				$gene_info_hsh_ref->{$geneID}{'trnscptID'}{$trnscptID}++;
			}
		}
		close BED;
	}

	return ($trnscpt_info_hsh_ref, $trnscpt_bkgd_hsh_ref);
}
sub getTssClusterProperties {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 5_tssClusterPropertiesTasks|207
#	secondaryAppearInSection: >none
#	input: $anno_reg_assignment_flank_size, $bedtools_bin, $chrom_size_hsh_ref, $chrom_size_path, $ctss_bed_path, $local_bkgd_extend_size, $mask_tss_region_bed_path, $pseudocount, $result_bed_dir, $tssCluster_bed_path, $tssCluster_flank_size, $ung_ctss_bed_path
#	output: $tssCluster_info_hsh_ref, $tssCluster_summit_anno_flank_bed_path, $tssCluster_summit_bed_path
#	toCall: my ($tssCluster_summit_bed_path, $tssCluster_summit_anno_flank_bed_path, $tssCluster_info_hsh_ref) = &getTssClusterProperties($tssCluster_bed_path, $ctss_bed_path, $result_bed_dir, $bedtools_bin, $chrom_size_path, $tssCluster_flank_size, $chrom_size_hsh_ref, $anno_reg_assignment_flank_size, $ung_ctss_bed_path, $local_bkgd_extend_size, $mask_tss_region_bed_path, $pseudocount);
#	calledInLine: 210
#....................................................................................................................................................#
	my ($tssCluster_bed_path, $ctss_bed_path, $result_bed_dir, $bedtools_bin, $chrom_size_path, $tssCluster_flank_size, $chrom_size_hsh_ref, $anno_reg_assignment_flank_size, $ung_ctss_bed_path, $local_bkgd_extend_size, $mask_tss_region_bed_path, $pseudocount) = @_;
	
	&reportAndLogStatus("Getting tssCluster count and summit and defining tssCluster_info_hsh", 10, "\n");#->2230

	my $tssCluster_info_hsh_ref = {};
	my $summit_dir = "$result_bed_dir/summit/";
	my $tssCluster_summit_bed_path = "$summit_dir/tssCluster_summit.bed.gz";
	my $local_bkgd_region_bed_path = "$result_bed_dir/local_bkgd_region.bed";
	my $tssCluster_summit_anno_flank_bed_path = "$summit_dir/tssCluster_summit.anno_flank.bed.gz";
	
	&reportAndLogStatus("Preparing bedtools intersect", 10, "\n");#->2230
	my $ctss_proc = 0;
	open BEDTOOLS, "$bedtools_bin intersect -sorted -s -wo -a $tssCluster_bed_path -b $ctss_bed_path |";
	while (<BEDTOOLS>) {
		chomp;
		my @splt = split /\t/;
		my $tssClusterID = $splt[3];
		my $stability = $splt[4];
		my $pos = $splt[-5];
		my $count = $splt[-3];
		my $chrom = $splt[0];
		
		next if not exists $chrom_size_hsh_ref->{$chrom};

		if (not exists $tssCluster_info_hsh_ref->{$tssClusterID}) {
			my $chromStart = $splt[1];
			my $chromEnd = $splt[2];
			my $strand = $splt[5];
			my $size = $chromEnd - $chromStart;
			$stability = 0 if $stability < 0;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'stability'} = $stability;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'count'} = $pseudocount;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'ung_count'} = $pseudocount;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'flank_count'} = $pseudocount;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'local_bkgd_count'} = $pseudocount;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'local_bkgd_size'} = $pseudocount;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'max'} = 0;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'strand'} = $strand;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'} = $chrom;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'size'} = $size;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'pos'} = [$chromStart, $chromEnd];
		}

		$tssCluster_info_hsh_ref->{$tssClusterID}{'count'} += $count;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'ctss'}{$pos} = $count;

		if ($count >= $tssCluster_info_hsh_ref->{$tssClusterID}{'max'}) {
			$tssCluster_info_hsh_ref->{$tssClusterID}{'max'} = $count + $pseudocount;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'summit'} = $pos;
		}
		$ctss_proc++;
		&reportAndLogStatus("$ctss_proc ctss processed", 10, "\n") if $ctss_proc%100000 == 0;#->2230
	}
	close OUTBED;

	&reportAndLogStatus("getting unencoded G count", 10, "\n");#->2230
	$ctss_proc = 0;
	open BEDTOOLS, "$bedtools_bin intersect -wa -sorted -s -a $ung_ctss_bed_path -b $ctss_bed_path | $bedtools_bin intersect -sorted -s -wo -a $tssCluster_bed_path -b stdin |";
	while (<BEDTOOLS>) {
		chomp;
		my @splt = split /\t/;
		my $tssClusterID = $splt[3];
		my $ung_count = $splt[-3];
		my $chrom = $splt[0];
		
		next if not exists $chrom_size_hsh_ref->{$chrom};

		$tssCluster_info_hsh_ref->{$tssClusterID}{'ung_count'} += $ung_count;
		$ctss_proc++;
		&reportAndLogStatus("$ctss_proc ctss processed", 10, "\n") if $ctss_proc%100000 == 0;#->2230
	}
	close OUTBED;
	
	&reportAndLogStatus("getting unencoded G percentage", 10, "\n");#->2230
	foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
		my $count = $tssCluster_info_hsh_ref->{$tssClusterID}{'count'};
		my $size = $tssCluster_info_hsh_ref->{$tssClusterID}{'size'};
		my $max = $tssCluster_info_hsh_ref->{$tssClusterID}{'max'};
		my $ung_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'ung_count'};
		my $ung_pct = 0;
		if ($count > 0) {
			$ung_pct = 100*($ung_count/$count);
		}
		my $peakness = $max/($size*$count);
		$tssCluster_info_hsh_ref->{$tssClusterID}{'ung_pct'} = sprintf "%.2f", $ung_pct;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'peakness'} = sprintf "%.5f", $peakness;
	}

	system "mkdir -pm 755 $summit_dir";
	open OUTBED, "| sort -k1,1 -k2,2n | gzip -c >$tssCluster_summit_bed_path";
	open LOCALBKGD, "| sort -k1,1 -k2,2n | $bedtools_bin subtract -s -a stdin -b $mask_tss_region_bed_path | sort -k1,1 -k2,2n | gzip -c >$local_bkgd_region_bed_path";
	foreach my $tssClusterID (sort keys %{$tssCluster_info_hsh_ref}) {
		my $chrom = $tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'};
		my $chrom_size = $chrom_size_hsh_ref->{$chrom};
		my $summit = $tssCluster_info_hsh_ref->{$tssClusterID}{'summit'};
		my $strand = $tssCluster_info_hsh_ref->{$tssClusterID}{'strand'};
		my $score = $tssCluster_info_hsh_ref->{$tssClusterID}{'max'};
		my $chromStart = $summit-1;
		my $chromEnd = $summit;
		print OUTBED join "", (join "\t", ($chrom, $chromStart, $chromEnd, $tssClusterID, $score, $strand)), "\n";
		my $left_end = $summit - $tssCluster_flank_size - 1;
		my $left_start = $left_end - $local_bkgd_extend_size;

		my $right_start= $summit + $tssCluster_flank_size + 1;
		my $right_end= $right_start + $local_bkgd_extend_size;
		
		if ($left_end > 0 and $left_start > 0) {
			print LOCALBKGD join "", (join "\t", ($chrom, $left_start, $left_end, $tssClusterID, $score, $strand)), "\n";
		}
		
		if ($right_start < $chrom_size and $right_end < $chrom_size) {
			print LOCALBKGD join "", (join "\t", ($chrom, $right_start, $right_end, $tssClusterID, $score, $strand)), "\n";
		}
	}
	close OUTBED;
	close LOCALBKGD;
	
	system "$bedtools_bin slop -b $anno_reg_assignment_flank_size -i $tssCluster_summit_bed_path -g $chrom_size_path | sort -k1,1 -k2,2n -k6,6 | gzip -c >$tssCluster_summit_anno_flank_bed_path";

	if ($tssCluster_flank_size >= 0) {
		&reportAndLogStatus("Getting flanking CTSS counts with tssCluster_flank_size=$tssCluster_flank_size.", 10, "\n");#->2230
		my $ctss_proc = 0;
		open BEDTOOLS, "$bedtools_bin slop -b $tssCluster_flank_size -i $tssCluster_summit_bed_path -g $chrom_size_path | $bedtools_bin intersect -sorted -s -wo -a stdin -b $ctss_bed_path |";
		while (<BEDTOOLS>) {
			chomp;
			my @splt = split /\t/;
			my $tssClusterID = $splt[3];
			my $count = $splt[-3];
			die "$tssClusterID does not exists\n" if not exists $tssCluster_info_hsh_ref->{$tssClusterID};
			$tssCluster_info_hsh_ref->{$tssClusterID}{'flank_count'} += $count;
			$ctss_proc++;
			&reportAndLogStatus("$ctss_proc ctss processed", 10, "\n") if $ctss_proc%500000 == 0;#->2230
		}
		close (BEDTOOLS);									
		&reportAndLogStatus("$ctss_proc ctss processed", 10, "\n");#->2230
	} else {
		&reportAndLogStatus("tssCluster_flank_size  = $tssCluster_flank_size. Using counts and flank count", 10, "\n");#->2230
		foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
			my $count = $tssCluster_info_hsh_ref->{$tssClusterID}{'count'};
			$tssCluster_info_hsh_ref->{$tssClusterID}{'flank_count'} = $count;
		}
	}
	
	&reportAndLogStatus("Getting background local background size with local_bkgd_extend_size=$local_bkgd_extend_size.", 10, "\n");#->2230
	open LOCALBKGD, "gzip -dc $local_bkgd_region_bed_path|";
	while (<LOCALBKGD>) {
		my @splt = split /\t/;
		my $tssClusterID = $splt[3];
		my $chromStart = $splt[1];
		my $chromEnd = $splt[2];
		my $local_bkgd_size = $chromEnd - $chromStart;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'local_bkgd_size'} += $local_bkgd_size;
	}
	close LOCALBKGD;

	&reportAndLogStatus("Getting background flanking CTSS counts with local_bkgd_extend_size=$local_bkgd_extend_size.", 10, "\n");#->2230
	$ctss_proc = 0;
	open BEDTOOLS, "$bedtools_bin intersect -sorted -s -wo -a $local_bkgd_region_bed_path -b $ctss_bed_path |";
	while (<BEDTOOLS>) {
		chomp;
		my @splt = split /\t/;
		my $tssClusterID = $splt[3];
		my $count = $splt[-3];
		die "$tssClusterID does not exists\n" if not exists $tssCluster_info_hsh_ref->{$tssClusterID};
		$tssCluster_info_hsh_ref->{$tssClusterID}{'local_bkgd_count'} += $count;
		$ctss_proc++;
		&reportAndLogStatus("$ctss_proc ctss processed", 10, "\n") if $ctss_proc%500000 == 0;#->2230
	}
	close (BEDTOOLS);									
	&reportAndLogStatus("$ctss_proc ctss processed", 10, "\n");#->2230

	my $num_tssCluster = keys %{$tssCluster_info_hsh_ref};
	&reportAndLogStatus("$num_tssCluster tssClusters are stored", 10, "\n");#->2230

	return ($tssCluster_summit_bed_path, $tssCluster_summit_anno_flank_bed_path, $tssCluster_info_hsh_ref);
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|156
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 172
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub performAnnoRegionBenchmark {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 7_BenchmarkTasks|228
#	secondaryAppearInSection: >none
#	input: $Rscript_bin, $benchmark_roc_R, $exclude_chrom_hsh_ref, $result_glm_dir, $testing_signal_path, $tssCluster_info_hsh_ref
#	output: 
#	toCall: &performAnnoRegionBenchmark($testing_signal_path, $tssCluster_info_hsh_ref, $result_glm_dir, $exclude_chrom_hsh_ref, $Rscript_bin, $benchmark_roc_R);
#	calledInLine: 233
#....................................................................................................................................................#
	my ($testing_signal_path, $tssCluster_info_hsh_ref, $result_glm_dir, $exclude_chrom_hsh_ref, $Rscript_bin, $benchmark_roc_R) = @_;
	
	if (-s $testing_signal_path) {

		my $min_num_golden = 50;
		&reportAndLogStatus("testing_signal_path is valid. Performing benchmark on anno regions.", 10, "\n");#->2230
		
		my $anno_reg_hsh_ref = {};
		foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
			my $anno_region = $tssCluster_info_hsh_ref->{$tssClusterID}{'anno_region'};
			$anno_reg_hsh_ref->{$anno_region}{$tssClusterID}{'anno_reg_test_binary'} = -1;
			$anno_reg_hsh_ref->{$anno_region}{$tssClusterID}{'test_bwscore'} = $tssCluster_info_hsh_ref->{$tssClusterID}{'test_bwscore'};
			$anno_reg_hsh_ref->{$anno_region}{$tssClusterID}{'prob'} = $tssCluster_info_hsh_ref->{$tssClusterID}{'prob'};
		}

		foreach my $anno_region (keys %{$anno_reg_hsh_ref}) {
			
			#---[2020/10/13 11:36] potentially set different number for each anno_region
			my $reg_anno_testing_cutoff_hsh_ref = {
				'pos' => 7.5,
				'neg' => 0.25,
			};

			my $sub_outDir = "$result_glm_dir/anno_reg_roc/$anno_region/";
			my $roc_input_path = "$sub_outDir/roc.input.tsv";
			system ("mkdir -pm 755 $sub_outDir");
			
			my $num_gold_pos = 0;
			my $num_gold_neg = 0;
			
			foreach my $tssClusterID (keys %{$anno_reg_hsh_ref->{$anno_region}}) {
				next if exists $exclude_chrom_hsh_ref->{$tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'}};
				my $test_bwscore = $anno_reg_hsh_ref->{$anno_region}{$tssClusterID}{'test_bwscore'};
				if ($test_bwscore >= $reg_anno_testing_cutoff_hsh_ref->{'pos'}) {
					$anno_reg_hsh_ref->{$anno_region}{$tssClusterID}{'anno_reg_test_binary'} = 1;
					$num_gold_pos++;
				}
				if ($test_bwscore <= $reg_anno_testing_cutoff_hsh_ref->{'neg'}) {
					$anno_reg_hsh_ref->{$anno_region}{$tssClusterID}{'anno_reg_test_binary'} = 0;
					$num_gold_neg++;
				}
			}

			&reportAndLogStatus("benchmark on $anno_region: num_gold_pos = $num_gold_pos num_gold_neg=$num_gold_neg", 10, "\n");#->2230
			
			open ROCINPUT, ">", $roc_input_path;
			print ROCINPUT join "", (join "\t", ('tssClusterID', 'binary', 'prob', 'test_bwscore', 'anno_region')), "\n";
			foreach my $tssClusterID (sort {$anno_reg_hsh_ref->{$anno_region}{$b}{'test_bwscore'} <=> $anno_reg_hsh_ref->{$anno_region}{$a}{'test_bwscore'}} keys %{$anno_reg_hsh_ref->{$anno_region}}) {
				my $binary = $anno_reg_hsh_ref->{$anno_region}{$tssClusterID}{'anno_reg_test_binary'};
				my $test_bwscore = $anno_reg_hsh_ref->{$anno_region}{$tssClusterID}{'test_bwscore'};
				my $prob = $anno_reg_hsh_ref->{$anno_region}{$tssClusterID}{'prob'};
				print ROCINPUT join "", (join "\t", ($tssClusterID, $binary, $prob, $test_bwscore, $anno_region)), "\n";
			}
			close ROCINPUT;
			
			if ($num_gold_pos > $min_num_golden and $num_gold_neg > $min_num_golden) {
				my $benchmark_roc_stdout_path = "$sub_outDir/00_stdout.txt";
				my $benchmark_roc_stderr_path = "$sub_outDir/00_stderr.txt";
				&reportAndLogStatus("benchmarking $anno_region", 10, "\n");#->2230
				system "$Rscript_bin $benchmark_roc_R $roc_input_path $sub_outDir 1>$benchmark_roc_stdout_path 2>$benchmark_roc_stderr_path";
			}
		}

	} else {
	
		&reportAndLogStatus("testing_signal_path not found. Will not perform benchmark on anno regions.", 10, "\n");#->2230
	
	}

	return ();
}
sub performGlmTraining {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: buildGlm|481, checkGlmModelRDS|575, defineGoldenSetForTesting|704, defineGoldenSetForTraining|784, printTrainingInput|1944, reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 7_BenchmarkTasks|228
#	secondaryAppearInSection: >none
#	input: $Rscript_bin, $bedtools_bin, $bigWigAverageOverBed_bin, $build_glm_R, $exclude_chrom_hsh_ref, $genome, $mask_bed_path, $mask_tss_region_bed_path, $min_gold_num, $result_bed_dir, $result_glm_dir, $result_tmp_dir, $testing_pct_hsh_ref, $testing_signal_path, $training_pct_hsh_ref, $training_signal_path, $tssCluster_info_hsh_ref, $tssCluster_summit_bed_path, $usr_glm_model_path
#	output: $glm_model_path, $tssCluster_glm_predictors_path
#	toCall: my ($tssCluster_glm_predictors_path, $glm_model_path) = &performGlmTraining($result_tmp_dir, $training_signal_path, $tssCluster_summit_bed_path, $tssCluster_info_hsh_ref, $bigWigAverageOverBed_bin, $bedtools_bin, $training_pct_hsh_ref, $min_gold_num, $result_bed_dir, $mask_tss_region_bed_path, $mask_bed_path, $result_glm_dir, $exclude_chrom_hsh_ref, $build_glm_R, $genome, $Rscript_bin, $testing_signal_path, $testing_pct_hsh_ref, $usr_glm_model_path);
#	calledInLine: 231
#....................................................................................................................................................#
	my ($result_tmp_dir, $training_signal_path, $tssCluster_summit_bed_path, $tssCluster_info_hsh_ref, $bigWigAverageOverBed_bin, $bedtools_bin, $training_pct_hsh_ref, $min_gold_num, $result_bed_dir, $mask_tss_region_bed_path, $mask_bed_path, $result_glm_dir, $exclude_chrom_hsh_ref, $build_glm_R, $genome, $Rscript_bin, $testing_signal_path, $testing_pct_hsh_ref, $usr_glm_model_path) = @_;
	
	foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {
		$tssCluster_info_hsh_ref->{$tssClusterID}{'train_bwscore'} = -1;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'train_in_gold_value'} = -1;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'train_binary'} = -1;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'test_in_gold_value'} = -1;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'test_binary'} = -1;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'test_bwscore'} = -1;
	}

	&defineGoldenSetForTesting($tssCluster_summit_bed_path, $tssCluster_info_hsh_ref, $training_pct_hsh_ref, $mask_tss_region_bed_path, $mask_bed_path, $testing_signal_path, $result_tmp_dir, $bedtools_bin, $bigWigAverageOverBed_bin, $testing_pct_hsh_ref, $min_gold_num, $exclude_chrom_hsh_ref);#->704
	
	if (-s $training_signal_path and not -s $usr_glm_model_path) {
		&defineGoldenSetForTraining($result_tmp_dir, $training_signal_path, $tssCluster_summit_bed_path, $tssCluster_info_hsh_ref, $bigWigAverageOverBed_bin, $bedtools_bin, $training_pct_hsh_ref, $min_gold_num, $exclude_chrom_hsh_ref);#->784
	}
	
	my ($tssCluster_glm_predictors_path) = &printTrainingInput($tssCluster_info_hsh_ref, $result_glm_dir, $result_bed_dir);#->1944
	
	my $glm_model_path;
	
	if (-s $usr_glm_model_path) {
		&reportAndLogStatus("usr_glm_model_path found. Using user provide glm model for predictions.", 10, "\n");#->2230
		$glm_model_path = $usr_glm_model_path;
		
	} elsif (-s $training_signal_path) {
		&reportAndLogStatus("training_signal_path found. Using training_signal_path for train a glm model.", 10, "\n");#->2230
		($glm_model_path) = &buildGlm($tssCluster_glm_predictors_path, $build_glm_R, $result_glm_dir, $Rscript_bin);#->481

	} else {
		&reportAndLogStatus("using the default glm_model for $genome for predictions.", 10, "\n");#->2230
		($glm_model_path) = &checkGlmModelRDS($genome);#->575
	}
	
	return ($tssCluster_glm_predictors_path, $glm_model_path);
}
sub predictLogisticProbability {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 7_BenchmarkTasks|228
#	secondaryAppearInSection: >none
#	input: $Rscript_bin, $default_cutoff, $glm_model_path, $predict_prob_R, $result_glm_dir, $tssCluster_glm_predictors_path, $tssCluster_info_hsh_ref
#	output: 
#	toCall: &predictLogisticProbability($tssCluster_glm_predictors_path, $glm_model_path, $predict_prob_R, $tssCluster_info_hsh_ref, $result_glm_dir, $Rscript_bin, $default_cutoff);
#	calledInLine: 232
#....................................................................................................................................................#
	my ($tssCluster_glm_predictors_path, $glm_model_path, $predict_prob_R, $tssCluster_info_hsh_ref, $result_glm_dir, $Rscript_bin, $default_cutoff) = @_;
	
	my $predict_prob_dir = "$result_glm_dir/predict_prob";
	#system ("rm -Rf $predict_prob_dir");
	system ("mkdir -pm 755 $predict_prob_dir");
	my $glm_prob_path = "$predict_prob_dir/combined.predictors.glm.prob.tsv";
	my $prob_cutoff_path = "$predict_prob_dir/lenient.robust.cutoff.txt";
	my $glm_prob_stdout_path = "$predict_prob_dir/00_run.stdout.log.txt";
	my $glm_prob_stderr_path = "$predict_prob_dir/00_run.stderr.log.txt";
	
	&reportAndLogStatus("predicting logistic probablity", 10, "\n");#->2230
	system "$Rscript_bin $predict_prob_R $tssCluster_glm_predictors_path $glm_model_path $default_cutoff $predict_prob_dir 1>$glm_prob_stdout_path 2>$glm_prob_stderr_path";
	
	if (-s $glm_prob_path) {
		&reportAndLogStatus("glm_prob_path is generated", 10, "\n");#->2230
	} else {
		die "glm_prob_path is not generated. Quitting\n";
	}

	if (-s $prob_cutoff_path) {
		open CUTOFF, "<", $prob_cutoff_path;
		chomp (my $line = <CUTOFF>);
		my ($lenient_cutoff, $robust_cutoff) = split /\s+/, $line;
		close CUTOFF;
		&reportAndLogStatus("default_cutoff=$default_cutoff", 10, "\n");#->2230
		&reportAndLogStatus("robust_cutoff=$robust_cutoff and lenient_cutoff=$lenient_cutoff", 10, "\n");#->2230
		&reportAndLogStatus("Reading glm_prob_path", 10, "\n");#->2230
		open PROB, "<", $glm_prob_path;
		<PROB>;
		while (<PROB>) {
			chomp;
			my ($tssClusterID, $prob) = split /\t/;
			die "$tssClusterID does not exists\n" if not exists $tssCluster_info_hsh_ref->{$tssClusterID};
			$tssCluster_info_hsh_ref->{$tssClusterID}{'prob'} = $prob;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'pass_default_cutoff'} = 'no';
			$tssCluster_info_hsh_ref->{$tssClusterID}{'pass_robust_cutoff'} = 'no';
			$tssCluster_info_hsh_ref->{$tssClusterID}{'pass_lenient_cutoff'} = 'no';
			$tssCluster_info_hsh_ref->{$tssClusterID}{'pass_default_cutoff'} = 'yes' if $prob >= $default_cutoff;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'pass_robust_cutoff'} = 'yes' if $prob >= $robust_cutoff;
			$tssCluster_info_hsh_ref->{$tssClusterID}{'pass_lenient_cutoff'} = 'yes' if $prob >= $lenient_cutoff;
		}
		close PROB;
		
	} else {
		die "prob_cutoff_path is not generated. Quitting\n";
	}

	return ();
}
sub printFilteredBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 8_count|238
#	secondaryAppearInSection: >none
#	input: $paramTag, $result_bed_dir, $tssCluster_bed_path, $tssCluster_info_hsh_ref
#	output: 
#	toCall: &printFilteredBed($tssCluster_bed_path, $tssCluster_info_hsh_ref, $result_bed_dir, $paramTag);
#	calledInLine: 242
#....................................................................................................................................................#
	my ($tssCluster_bed_path, $tssCluster_info_hsh_ref, $result_bed_dir, $paramTag) = @_;

	&reportAndLogStatus("Filtering tssClusters.", 10, "\n");#->2230
	my $all_tssCluster_bed = "$result_bed_dir/$paramTag.tssCluster.all.bed.gz";
	my $robust_tssCluster_bed = "$result_bed_dir/$paramTag.tssCluster.robust.filtered.bed.gz";
	my $lenient_tssCluster_bed = "$result_bed_dir/$paramTag.tssCluster.lenient.filtered.bed.gz";
	my $default_tssCluster_bed = "$result_bed_dir/$paramTag.tssCluster.default.filtered.bed.gz";

	open ALL, "| sort -k1,1 -k2,2n | gzip -c >$all_tssCluster_bed";
	open ROBUST, "| sort -k1,1 -k2,2n | gzip -c >$robust_tssCluster_bed";
	open LENIENT, "| sort -k1,1 -k2,2n | gzip -c >$lenient_tssCluster_bed";
	open DEFAULT, "| sort -k1,1 -k2,2n | gzip -c >$default_tssCluster_bed";

	if ($tssCluster_bed_path =~ m/\.gz$/) {
		open (TSSCLUSTERBED, "gzip -dc $tssCluster_bed_path | ");
	} else {
		open (TSSCLUSTERBED, "cat $tssCluster_bed_path | ");
	}
	while (<TSSCLUSTERBED>) {
		chomp;
		my ($chrom, $chromStart, $chromEnd, $tssClusterID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts) = split /\t/;
		my $prob = $tssCluster_info_hsh_ref->{$tssClusterID}{'prob'};

		my $pass_default_cutoff = $tssCluster_info_hsh_ref->{$tssClusterID}{'pass_default_cutoff'};
		my $pass_lenient_cutoff = $tssCluster_info_hsh_ref->{$tssClusterID}{'pass_lenient_cutoff'};
		my $pass_robust_cutoff = $tssCluster_info_hsh_ref->{$tssClusterID}{'pass_robust_cutoff'};
		
		my $score_bedline = join "", (join "\t", ($chrom, $chromStart, $chromEnd, $tssClusterID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts)), "\n";
		my $prob_bedline = join "", (join "\t", ($chrom, $chromStart, $chromEnd, $tssClusterID, $prob, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts)), "\n";
		
		print ALL $prob_bedline;
		print DEFAULT $score_bedline if ($pass_default_cutoff eq 'yes');
		print ROBUST $score_bedline if ($pass_robust_cutoff eq 'yes');
		print LENIENT $score_bedline if ($pass_lenient_cutoff eq 'yes');

	}
	close TSSCLUSTERBED;
	close ALL;
	close ROBUST;
	close LENIENT;
	close DEFAULT;
	
	return ();
}
sub printGeneDensityLog {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_backgroundDensityTasks|197
#	secondaryAppearInSection: >none
#	input: $gene_info_hsh_ref, $paramTag, $result_log_dir
#	output: 
#	toCall: &printGeneDensityLog($result_log_dir, $gene_info_hsh_ref, $paramTag);
#	calledInLine: 202
#....................................................................................................................................................#
	my ($result_log_dir, $gene_info_hsh_ref, $paramTag) = @_;
	
	my $filePath = "$result_log_dir/$paramTag.gene_density.log.tsv";
	open (OUTFILE, ">", "$filePath");
	$globalReadmeHsh_ref->{$filePath}{'description'} = "Density of genes";
	my @headerAry = ('geneID', 'exon_intron', 'bkgd_orientation', 'density');
	print OUTFILE join "", (join "\t", @headerAry), "\n";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;
	$globalReadmeHsh_ref->{$filePath}{'header'}{'XXX'} = 'XXX';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'YYY'} = 'YYY';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'ZZZ'} = 'ZZZ';
	
	foreach my $geneID (sort keys %{$gene_info_hsh_ref}) {
		foreach my $exon_intron (sort keys %{$gene_info_hsh_ref->{$geneID}{'density'}}) {
			foreach my $bkgd_orientation (sort keys %{$gene_info_hsh_ref->{$geneID}{'density'}{$exon_intron}}) {
				my $density = $gene_info_hsh_ref->{$geneID}{'density'}{$exon_intron}{$bkgd_orientation};
				print OUTFILE join "", (join "\t", ($geneID, $exon_intron, $bkgd_orientation, $density)), "\n";
			}
		}
	}
	
	close OUTFILE;

	return ();
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 9_finishingTasks|247
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 250
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			@colLenCountHsh = sort {$b <=> $a} @colLenCountHsh;
			my $headerColLen = $colLenCountHsh[0]+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}
	
	@{$filelistLenCountHsh{'dir'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'dir'}};
	@{$filelistLenCountHsh{'name'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'name'}};
	@{$filelistLenCountHsh{'description'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'description'}};

	my $fileDir_colLen = $filelistLenCountHsh{'dir'}[0]+2;
	my $fileName_colLen = $filelistLenCountHsh{'name'}[0]+2;
	my $fileDescription_colLen = $filelistLenCountHsh{'description'}[0]+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|686
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|156, 9_finishingTasks|247
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 171, 251
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->686
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->686
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->686
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->686
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub printTrainingInput {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: performGlmTraining|1588
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 7_BenchmarkTasks|228
#	input: $result_bed_dir, $result_glm_dir, $tssCluster_info_hsh_ref
#	output: $tssCluster_glm_predictors_path
#	toCall: my ($tssCluster_glm_predictors_path) = &printTrainingInput($tssCluster_info_hsh_ref, $result_glm_dir, $result_bed_dir);
#	calledInLine: 1616
#....................................................................................................................................................#
	my ($tssCluster_info_hsh_ref, $result_glm_dir, $result_bed_dir) = @_;
	my $golden_set_bed_dir = "$result_bed_dir/golden_set";
	system ("mkdir -pm 755 $golden_set_bed_dir");
	open GDPOS, "| sort -k1,1 -k2,2n >$golden_set_bed_dir/testing.golden_set.positive.tssCluster.bed";
	open GDNEG, "| sort -k1,1 -k2,2n >$golden_set_bed_dir/testing.golden_set.negative.tssCluster.bed";
	
	&reportAndLogStatus("Prining input for benchmark", 10, "\n");#->2230
	my $tssCluster_glm_predictors_path = "$result_glm_dir/tssCluster.glm.predictors.tsv";
	open ALLTSSCLUSTERSCORE, ">", $tssCluster_glm_predictors_path;
	print ALLTSSCLUSTERSCORE join "", (join "\t", ('tssClusterID', 'train_binary', 'test_binary', 'train_in_gold_value', 'test_in_gold_value', 'bkgd_region', 'anno_region', 'density', 'cluster_count', 'summit_count', 'flank_count', 'bkgd_rltv_expr', 'ung_pct', 'size', 'peakness', 'stability')), "\n";
	foreach my $tssClusterID (keys %{$tssCluster_info_hsh_ref}) {

		my $strand = $tssCluster_info_hsh_ref->{$tssClusterID}{'strand'};
		my $chrom = $tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'};
		my ($chromStart, $chromEnd) = @{$tssCluster_info_hsh_ref->{$tssClusterID}{'pos'}};
	
		my $cluster_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'count'};
		my $size = $tssCluster_info_hsh_ref->{$tssClusterID}{'size'};
		my $peakness = $tssCluster_info_hsh_ref->{$tssClusterID}{'peakness'};
		my $ung_pct = $tssCluster_info_hsh_ref->{$tssClusterID}{'ung_pct'};
		my $bkgd_rltv_expr = $tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_rltv_expr'};
		my $summit_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'max'};
		my $flank_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'flank_count'};
		my $train_binary = $tssCluster_info_hsh_ref->{$tssClusterID}{'train_binary'};
		my $test_binary = $tssCluster_info_hsh_ref->{$tssClusterID}{'test_binary'};
		my $train_in_gold_value = $tssCluster_info_hsh_ref->{$tssClusterID}{'train_in_gold_value'};
		my $test_in_gold_value = $tssCluster_info_hsh_ref->{$tssClusterID}{'test_in_gold_value'};
		my $stability = $tssCluster_info_hsh_ref->{$tssClusterID}{'stability'};

		my $bkgd_region = $tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_region'};
		my $anno_region = $tssCluster_info_hsh_ref->{$tssClusterID}{'anno_region'};
		my $density = $tssCluster_info_hsh_ref->{$tssClusterID}{'density'};

		if ($test_binary != -1) {
			if ($test_binary == 1) {
				print GDPOS join "", (join "\t", ($chrom, $chromStart, $chromEnd, $tssClusterID, $test_in_gold_value, $strand)), "\n";	
			} else {
				print GDNEG join "", (join "\t", ($chrom, $chromStart, $chromEnd, $tssClusterID, $test_in_gold_value, $strand)), "\n";	
			}
		}
		print ALLTSSCLUSTERSCORE join "", (join "\t", ($tssClusterID, $train_binary, $test_binary, $train_in_gold_value, $test_in_gold_value, $bkgd_region, $anno_region, $density, $cluster_count, $summit_count, $flank_count, $bkgd_rltv_expr, $ung_pct, $size, $peakness, $stability)), "\n";
	}
	close ALLTSSCLUSTERSCORE;
	close GDPOS;
	close GDNEG;
	
	return ($tssCluster_glm_predictors_path);
}
sub printTssClusterLog {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 8_count|238
#	secondaryAppearInSection: >none
#	input: $paramTag, $result_log_dir, $tssCluster_info_hsh_ref
#	output: 
#	toCall: &printTssClusterLog($result_log_dir, $tssCluster_info_hsh_ref, $paramTag);
#	calledInLine: 241
#....................................................................................................................................................#
	my ($result_log_dir, $tssCluster_info_hsh_ref, $paramTag) = @_;
	
	&reportAndLogStatus("Printing tssCluster log", 10, "\n");#->2230
	
	my $filePath = "$result_log_dir/$paramTag.tssCluster.log.tsv";
	open (OUTFILE, ">", "$filePath");
	$globalReadmeHsh_ref->{$filePath}{'description'} = "Information of all tssClusters";
	my @headerAry = ('tssClusterID',  'prob', 'pass_default_cutoff', 'pass_robust_cutoff', 'pass_lenient_cutoff', 'chrom', 'strand',  'summit', 'anno_region', 'bkgd_region', 'bkgd_geneID', 'density', 'size', 'local_bkgd_count', 'local_bkgd_size', 'max', 'count', 'flank_count', 'bkgd_rltv_expr', 'ung_count', 'ung_pct', 'dist_to_anno_tss', 'dist_to_anno_cre', 'train_bwscore', 'test_bwscore');
	print OUTFILE join "", (join "\t", @headerAry), "\n";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;
	$globalReadmeHsh_ref->{$filePath}{'header'}{'tssClusterID'} = 'XXX';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'chrom'} = 'YYY';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'strand'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'summit'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'bkgd_type'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'bkgd_orientation'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'bkgd_geneID'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'density'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'size'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'slop_size'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'max'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'count'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'flank_count'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'bkgd_rltv_expr'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'ung_count'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'ung_pct'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'dist_to_anno_tss'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'dist_to_anno_cre'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'prob'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'pass_robust_cutoff'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'pass_lenient_cutoff'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'pass_default_cutoff'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'train_bwscore'} = 'ZZZ';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'test_bwscore'} = 'ZZZ';

	foreach my $tssClusterID (sort keys %{$tssCluster_info_hsh_ref}) {

		my $chrom = $tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'};
		my $strand = $tssCluster_info_hsh_ref->{$tssClusterID}{'strand'};
		my $summit = $tssCluster_info_hsh_ref->{$tssClusterID}{'summit'};
		my $bkgd_region = $tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_region'};
		my $anno_region = $tssCluster_info_hsh_ref->{$tssClusterID}{'anno_region'};
		my $density = $tssCluster_info_hsh_ref->{$tssClusterID}{'density'};
		my $bkgd_geneID = $tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_geneID'};
		my $size = $tssCluster_info_hsh_ref->{$tssClusterID}{'size'};
		my $max = $tssCluster_info_hsh_ref->{$tssClusterID}{'max'};
		my $count = $tssCluster_info_hsh_ref->{$tssClusterID}{'count'};
		my $flank_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'flank_count'};
		my $bkgd_rltv_expr = $tssCluster_info_hsh_ref->{$tssClusterID}{'bkgd_rltv_expr'};
		my $ung_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'ung_count'};
		my $ung_pct = $tssCluster_info_hsh_ref->{$tssClusterID}{'ung_pct'};
		my $local_bkgd_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'local_bkgd_count'};
		my $local_bkgd_size = $tssCluster_info_hsh_ref->{$tssClusterID}{'local_bkgd_size'};
		my $dist_to_anno_tss = $tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_tss'};
		my $dist_to_anno_cre = $tssCluster_info_hsh_ref->{$tssClusterID}{'dist_to_anno_cre'};
		my $prob = $tssCluster_info_hsh_ref->{$tssClusterID}{'prob'};
		my $pass_default_cutoff = $tssCluster_info_hsh_ref->{$tssClusterID}{'pass_default_cutoff'};
		my $pass_robust_cutoff = $tssCluster_info_hsh_ref->{$tssClusterID}{'pass_robust_cutoff'};
		my $pass_lenient_cutoff = $tssCluster_info_hsh_ref->{$tssClusterID}{'pass_lenient_cutoff'};
		my $test_bwscore = $tssCluster_info_hsh_ref->{$tssClusterID}{'test_bwscore'};
		my $train_bwscore = $tssCluster_info_hsh_ref->{$tssClusterID}{'train_bwscore'};

		print OUTFILE join "", (join "\t", 	($tssClusterID, $prob, $pass_default_cutoff, $pass_robust_cutoff, $pass_lenient_cutoff, $chrom, $strand,  $summit, $anno_region, $bkgd_region, $bkgd_geneID, $density, $size, $local_bkgd_count, $local_bkgd_size, $max, $count, $flank_count, $bkgd_rltv_expr, $ung_count, $ung_pct, $dist_to_anno_tss, $dist_to_anno_cre, $train_bwscore, $test_bwscore)), "\n";
	}
	
	close OUTFILE;

	return ();
}
sub readGeneInfo {
#....................................................................................................................................................#
#	subroutineCategory: getTextInfo
#	dependOnSub: reportAndLogStatus|2230
#	appearInSub: >none
#	primaryAppearInSection: 3_getInfoTasks|184
#	secondaryAppearInSection: >none
#	input: $gene_info_path
#	output: $gene_info_hsh_ref
#	toCall: my ($gene_info_hsh_ref) = &readGeneInfo($gene_info_path);
#	calledInLine: 192
#....................................................................................................................................................#
	my ($gene_info_path) = @_;
	
	&reportAndLogStatus("reading gene info", 10, "\n");#->2230
	my $gene_info_hsh_ref = {};
	
	if ($gene_info_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $gene_info_path|");
	} else {
		open (FILEIN, "<", $gene_info_path);
	}

	chomp(my $header = <FILEIN>);
	my @headerSplt = split /\t/, $header;
	my %colIndexHsh = ();
	
	foreach my $headerItem (qw/geneID geneClass geneName/) {
		$colIndexHsh{$headerItem} = undef;
		foreach my $i (0..$#headerSplt) {
			$colIndexHsh{$headerItem} = $i if $headerItem eq $headerSplt[$i];
		}
		if (not defined $colIndexHsh{$headerItem}) {
			&reportAndLogStatus("$headerItem item is missing. Dummy values used.", 10, "\n");#->2230
		}
	}
	
	my $lineProc = 0;
	while (<FILEIN>) {
		next if $_ =~ m/^#/;
		$lineProc++;
		chomp;
		&reportAndLogStatus("$lineProc lines processed", 10, "\n") if $lineProc%10000==0;	##->2230
		my @splt = split /\t/;
		my $geneID = $splt[$colIndexHsh{'geneID'}];

		foreach my $headerItem (qw/geneClass geneName/) {
			my $item_value = '__na';
			if (defined $colIndexHsh{$headerItem}) {
				$item_value = $splt[$colIndexHsh{$headerItem}];
			}
			$gene_info_hsh_ref->{$geneID}{$headerItem} = $item_value;
		}		
	}
	close FILEIN;

	my $num_gene = keys %{$gene_info_hsh_ref};
	
	&reportAndLogStatus("$num_gene genes stored", 10, "\n");#->2230
	
	return ($gene_info_hsh_ref);
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|124
#	secondaryAppearInSection: >none
#	input: none
#	output: $Rscript_bin, $ctss_bed_path, $default_cutoff, $exclude_chrom_list, $genome, $local_bkgd_extend_size, $min_gold_num, $outDir, $outputPrefix, $overwrite, $testing_signal_path, $training_pct, $training_signal_path, $tssCluster_bed_path, $tssCluster_flank_size, $ung_ctss_bed_path, $usr_glm_model_path
#	toCall: my ($ctss_bed_path, $ung_ctss_bed_path, $tssCluster_bed_path, $training_signal_path, $testing_signal_path, $genome, $tssCluster_flank_size, $local_bkgd_extend_size, $min_gold_num, $training_pct, $Rscript_bin, $usr_glm_model_path, $default_cutoff, $exclude_chrom_list, $outputPrefix, $outDir, $overwrite) = &readParameters();
#	calledInLine: 127
#....................................................................................................................................................#
	
	my ($ctss_bed_path, $ung_ctss_bed_path, $tssCluster_bed_path, $training_signal_path, $testing_signal_path, $genome, $tssCluster_flank_size, $local_bkgd_extend_size, $min_gold_num, $training_pct, $Rscript_bin, $usr_glm_model_path, $default_cutoff, $exclude_chrom_list, $outputPrefix, $outDir, $overwrite);
	
	$Rscript_bin = "Rscript";
	$tssCluster_flank_size = 75;
	$local_bkgd_extend_size = 500;
	$min_gold_num = 100;
	$training_pct = 5;
	$default_cutoff = 0.5;
	$overwrite = 'no';
	$exclude_chrom_list = 'chrM';

	GetOptions 	(
		"ctss_bed_path=s"				=> \$ctss_bed_path,
		"ung_ctss_bed_path=s"		=> \$ung_ctss_bed_path,
		"tssCluster_bed_path=s"		=> \$tssCluster_bed_path,
		"genome=s"						=> \$genome,
		"tssCluster_flank_size:i"	=> \$tssCluster_flank_size,
		"local_bkgd_extend_size:i"	=> \$local_bkgd_extend_size,
		"min_gold_num:i"				=> \$min_gold_num,
		"training_pct:i"				=> \$training_pct,
		"training_signal_path:s"	=> \$training_signal_path,
		"testing_signal_path:s"		=> \$testing_signal_path,
		"usr_glm_model_path:s"		=> \$usr_glm_model_path,
		"Rscript_bin:s"				=> \$Rscript_bin,
		"default_cutoff:s"			=> \$default_cutoff,
		"exclude_chrom_list"			=> \$exclude_chrom_list,
		"outputPrefix=s"				=> \$outputPrefix,
		"outDir=s"						=> \$outDir,
		"overwrite:s"					=>	\$overwrite,
		'help'							=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $ctss_bed_path;

	#---check file
	my $file_check_hsh_ref = {
		'ctss_bed_path' => $ctss_bed_path,
		'ung_ctss_bed_path' => $ung_ctss_bed_path,
		'tssCluster_bed_path' => $tssCluster_bed_path,
	};
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}
	
	if (defined $usr_glm_model_path) {
		die "Can't read usr_glm_model_path $usr_glm_model_path" if not -s $usr_glm_model_path;
	} else {
		$usr_glm_model_path = 'unused';
	}

	if (defined $training_signal_path) {
		die "Can't read training_signal_path $training_signal_path" if not -s $training_signal_path;
	} else {
		$training_signal_path = 'unused';
	}

	if (defined $testing_signal_path) {
		die "Can't read testing_signal_path $testing_signal_path" if not -s $testing_signal_path;
	} else {
		$testing_signal_path = 'unused';
	}
	
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
	
	return($ctss_bed_path, $ung_ctss_bed_path, $tssCluster_bed_path, $training_signal_path, $testing_signal_path, $genome, $tssCluster_flank_size, $local_bkgd_extend_size, $min_gold_num, $training_pct, $Rscript_bin, $usr_glm_model_path, $default_cutoff, $exclude_chrom_list, $outputPrefix, $outDir, $overwrite);
	
}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|686
#	appearInSub: assignTssClusterToAnnnotationRegions|296, assignTssClusterToBackgroundRegions|390, buildGlm|481, checkBedtoolsVersion|513, checkBigWigAverageOverBedVersion|544, checkGlmModelRDS|575, checkRScriptVersion|600, defineGoldenSetForTesting|704, generateExcludeChrHsh|824, getBackgroundDensity|848, getBackgroundRelativeExpression|948, getChromSize|998, getDistToCRE|1025, getDistToTSS|1063, getGeneTssClusterRanking|1097, getGoldenSetBed|1148, getGoldenSetBigwig|1195, getTranscriptRegionSize|1252, getTssClusterProperties|1292, performAnnoRegionBenchmark|1505, performGlmTraining|1588, predictLogisticProbability|1636, printFilteredBed|1697, printTrainingInput|1944, printTssClusterLog|2004, readGeneInfo|2085
#	primaryAppearInSection: 2_defineOutDirPath|156
#	secondaryAppearInSection: 1_defineHardCodedParam|132, 3_getInfoTasks|184, 4_backgroundDensityTasks|197, 5_tssClusterPropertiesTasks|207, 6_backgroundRelativeExpressionTasks|218, 7_BenchmarkTasks|228, 8_count|238
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 174, 175, 176, 177, 178, 309, 330, 355, 364, 377, 403, 422, 447, 456, 469, 501, 505, 531, 535, 562, 566, 592, 621, 627, 633, 639, 745, 776, 777, 840, 869, 933, 961, 1011, 1018, 1038, 1076, 1110, 1189, 1190, 1209, 1246, 1247, 1272, 1305, 1313, 1354, 1358, 1372, 1376, 1423, 1434, 1437, 1439, 1446, 1458, 1469, 1472, 1475, 1521, 1559, 1574, 1581, 1621, 1625, 1629, 1657, 1661, 1671, 1672, 1673, 1710, 1961, 2017, 2098, 2117, 2126, 2142
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->686
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->686
	
	return ();
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 112
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































