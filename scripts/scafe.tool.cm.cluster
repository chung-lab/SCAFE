#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use List::Util qw (sum shuffle min max);
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                                   ---> scafe.tool.cm.cluster <---
                          <--- tool, common mode, cluster ctss --->

 Description:
   This tool generate TSS cluster from a ctss bed file, using an external tool paraclu with user-defined cutoffs

 Usage:
   scafe.tool.cm.cluster [options] --cluster_ctss_bed_path --outputPrefix --outDir
   
   --cluster_ctss_bed_path       <required> [string]  ctss file used for clustering,
                                                      for single cell, *.pass.ctss.bed.gz ctss file from 
                                                      scafe.tool.cm.remove_strand_invader; for bulk,
                                                      *collapse.ctss.bed.gz from scafe.tool.bk.bam_to_ctss;
                                                      for aggregate, *collapse.ctss.bed.gz from scafe.tool.cm.aggregate
   --count_ctss_bed_path         <required> [string]  ctss file used for counting, 
                                                      using for filtering of clusters, on min_summit_count and min_cluster_count
                                                      for stringent filter, can consider using *.unencoded_G.collapse.ctss.bed.gz
                                                      for permissive filter, use the same as cluster_ctss_bed_path, e.g. *collapse.ctss.bed.gz
   --outputPrefix                <required> [string]  prefix for the output files
   --outDir                      <required> [string]  directory for the output files
   --min_summit_count            (optional) [integer] minimum counts at the summit of a cluster, based on count_ctss_bed_path (default = 0)
   --min_cluster_count           (optional) [integer] minimum counts within a cluster, based on count_ctss_bed_path (default = 2)
   --min_paraclu_count           (optional) [integer] minimum number of read in a cluster to be retained in paraclu (as paraclu input parameter) 
                                                      based on cluster_ctss_bed_path (default = 3)
   --overwrite                    (optional) [yes/no] erase outDir/outputPrefix before running (default=no)

 Dependencies:
   paraclu
   paraclu-cut.sh
   bedtools

 For demo, cd to SCAFE dir and run,
   scafe.tool.cm.cluster \
   --overwrite=yes \
   --cluster_ctss_bed_path=./demo/output/sc.solo/bam_to_ctss/demo/bed/demo.collapse.ctss.bed.gz \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.solo/cluster/

=head1 VERSION

v0.9.0-beta [March 20, 2021]
	-Initial pre-release

v1.0.0 [June 6, 2022]
	-parallelized part of the processes

v1.0.1 [June 26, 2022]
	-min_num_sample_expr_cluster and min_num_sample_expr_summit are deprecated
	-count_ctss_bed_path change to count_ctss_bed_path
	-count_scope_bed_path is deprecated
	-min_pos_count deprecated
	-merge_dist deprecated
	-added min_paraclu_count option
	
=cut#
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->831
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->298
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($cluster_ctss_bed_path, $count_ctss_bed_path, $min_cluster_count, $min_summit_count, $min_paraclu_count, $outputPrefix, $outDir, $overwrite) = &readParameters();#->689
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $paramTag = "$outputPrefix";

my @mkDirAry;
my $result_dir = "$outDir/$paramTag/"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $resultParacluDir = "$result_dir/paraclu/"; push @mkDirAry, $resultParacluDir;
my $resultBedDir = "$result_dir/bed/"; push @mkDirAry, $resultBedDir;
my $resultLogDir = "$result_dir/log/"; push @mkDirAry, $resultLogDir;
my $resultScriptDir = "$result_dir/script/"; push @mkDirAry, $resultScriptDir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 755 $dir");}

open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&printStartOrFinishMessage("startMessage");#->655
&logCalledCMDAndScript($ARGVStr, $resultScriptDir, $scriptAbsPath);#->413

#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_ReadInfoAndRun
#
#<section ID="ReadInfoAndRun" num="2">
my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();#->198
my ($paraclu_input_path) = &parseParacluInput($cluster_ctss_bed_path, $resultParacluDir);#->438
my ($paraclu_cluster_bed_path) = &runParaclu($paraclu_input_path, $paraclu_bin, $cut_sh_path, $resultParacluDir, $min_paraclu_count);#->761
my ($tssCluster_info_hsh_ref, $paraclu_summit_bed_path) = &generateTssClusterInfoHsh($resultParacluDir, $paraclu_cluster_bed_path, $cluster_ctss_bed_path, $bedtools_bin);#->316
&getTssClusterCount($tssCluster_info_hsh_ref, $count_ctss_bed_path, $paraclu_summit_bed_path, $paraclu_cluster_bed_path, $bedtools_bin);#->381
&printFinalBedAndLog($tssCluster_info_hsh_ref, $resultBedDir, $resultLogDir, $min_cluster_count, $min_summit_count, $paramTag);#->486
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_finishingTasks
#
#<section ID="finishingTasks" num="3">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->540
&printStartOrFinishMessage("finishMessage");#->655
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	general [n=5]:
#		currentTime, logCalledCMDAndScript, printStartOrFinishMessage
#		readParameters, timeStamp
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=6]:
#		checkAllExecutable, generateTssClusterInfoHsh, getTssClusterCount
#		parseParacluInput, printFinalBedAndLog, runParaclu
#
#====================================================================================================================================================#

sub checkAllExecutable {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|739
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedGraphToBigWig_bin, $bedtools_bin, $bgzip_bin, $bigWigAverageOverBed_bin, $cut_sh_path, $paraclu_bin, $samtools_bin, $tabix_bin
#	toCall: my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();
#	calledInLine: 153
#....................................................................................................................................................#
	
	my $dirPath = dirname(rel2abs($0));

	my $tabix_bin = "$dirPath/../resources/bin/tabix/tabix";
	my $bgzip_bin = "$dirPath/../resources/bin/bgzip/bgzip";
	my $bedtools_bin = "$dirPath/../resources/bin/bedtools/bedtools";
	my $samtools_bin = "$dirPath/../resources/bin/samtools/samtools";
	my $paraclu_bin = "$dirPath/../resources/bin/paraclu/paraclu";
	my $cut_sh_path = "$dirPath/../resources/bin/paraclu/paraclu-cut.sh";
	my $bedGraphToBigWig_bin = "$dirPath/../resources/bin/bedGraphToBigWig/bedGraphToBigWig";
	my $bigWigAverageOverBed_bin = "$dirPath/../resources/bin/bigWigAverageOverBed/bigWigAverageOverBed";
	
	&reportAndLogStatus("Checking all SCAFE executables", 10, "\n");#->739
	
	{
		my $stdOut = `$tabix_bin  --version 2>&1`;
		if ($stdOut =~ m/tabix \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: tabix version: $1", 0, "\n");#->739
		} else {
			die "tabix is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bgzip_bin --version 2>&1`;
		if ($stdOut =~ m/bgzip \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: bgzip version: $1", 0, "\n");#->739
		} else {
			die "bgzip is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedtools_bin --version 2>&1`;
		if ($stdOut =~ m/bedtools v(\S+)/) {
			&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->739
		} else {
			die "bedtools is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$samtools_bin 2>&1`;
		if ($stdOut =~ m/\s+(Version: \S+)\s+/) {
			&reportAndLogStatus("Checking: samtools version: $1", 0, "\n");#->739
		} else {
			die "samtools is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$paraclu_bin 2>&1`;
		if ($stdOut =~ m/paraclu: I need a minValue and a fileName/) {
			&reportAndLogStatus("Checking: paraclu found.", 0, "\n");#->739
		} else {
			die "paraclu is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$cut_sh_path 55C7128A 2>&1`;
		if ($stdOut =~ m/awk:/) {
			&reportAndLogStatus("Checking: paraclu-cut found.", 0, "\n");#->739
		} else {
			die "paraclu-cut is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedGraphToBigWig_bin 2>&1`;
		if ($stdOut =~ m/bedGraphToBigWig v (\S+)/) {
			&reportAndLogStatus("Checking: bedGraphToBigWig version: $1", 0, "\n");#->739
		} else {
			die "bedGraphToBigWig not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bigWigAverageOverBed_bin 2>&1`;
		if ($stdOut =~ m/bigWigAverageOverBed v(\S+)/) {
			&reportAndLogStatus("Checking: bigWigAverageOverBed version: $1", 0, "\n");#->739
		} else {
			die "bigWigAverageOverBed is not installed properly. Quitting.\n";
		}
	}

	return ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin);
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|655, reportAndLogStatus|739
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 1_defineHardCodedParam|126, 3_finishingTasks|163
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 107, 671, 675, 680, 684, 755, 756
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub generateTssClusterInfoHsh {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|739
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $cluster_ctss_bed_path, $paraclu_cluster_bed_path, $resultParacluDir
#	output: $paraclu_summit_bed_path, $tssCluster_info_hsh_ref
#	toCall: my ($tssCluster_info_hsh_ref, $paraclu_summit_bed_path) = &generateTssClusterInfoHsh($resultParacluDir, $paraclu_cluster_bed_path, $cluster_ctss_bed_path, $bedtools_bin);
#	calledInLine: 156
#....................................................................................................................................................#
	my ($resultParacluDir, $paraclu_cluster_bed_path, $cluster_ctss_bed_path, $bedtools_bin) = @_;
	
	my $tssCluster_info_hsh_ref = {};
	my $paraclu_info_hsh_ref = {};

	&reportAndLogStatus("getting summit position", 10, "\n");#->739
	my $bedtools_cmd = "$bedtools_bin intersect -sorted -a $paraclu_cluster_bed_path -b $cluster_ctss_bed_path -s -wao";
	open BEDTOOLS, "$bedtools_cmd |";
	while (<BEDTOOLS>) {
		chomp;
		my ($chrom, $chromStart, $chromEnd, $tssClusterID, $stability, $strand, undef, undef, $ctss_pos, undef, $ctss_read) = split /\t/;
		if (not exists $paraclu_info_hsh_ref->{$tssClusterID}) {
			$paraclu_info_hsh_ref->{$tssClusterID} = [$chrom, $chromStart, $chromEnd, $strand, $ctss_read, $ctss_pos, $ctss_read, $stability];
		} else {
			$paraclu_info_hsh_ref->{$tssClusterID}[-4] += $ctss_read;
			if ($ctss_read > $paraclu_info_hsh_ref->{$tssClusterID}[-2]) {
				$paraclu_info_hsh_ref->{$tssClusterID}[-2] = $ctss_read;
				$paraclu_info_hsh_ref->{$tssClusterID}[-3] = $ctss_pos;
			}
		}
	}
	close BEDTOOLS;
	
	my $paraclu_summit_bed_path = "$resultParacluDir/paraclu.summit.bed.gz";
	open PARACLUSUMMITBED, "| sort -k1,1 -k2,2n | gzip -c >$paraclu_summit_bed_path";

	foreach my $tssClusterID (keys %{$paraclu_info_hsh_ref}) {
		my ($chrom, $chromStart, $chromEnd, $strand, $paraclu_input_cluster_count, $summit_pos, $paraclu_input_summit_count, $stability) = @{$paraclu_info_hsh_ref->{$tssClusterID}};
		my $size = $chromEnd - $chromStart;
		my $thickStart = $summit_pos - 1;
		my $thickEnd = $summit_pos;
		my $itemRgb = "227,26,28";
		$itemRgb = "31,120,180" if $strand eq '-';
		my $blockCount = 1;
		my $blockSizes = $size;
		my $blockStarts = 0;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'} = $chrom;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'chromStart'} = $chromStart;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'chromEnd'} = $chromEnd;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'size'} = $size;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'stability'} = $stability;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'summit_pos'} = $summit_pos;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'paraclu_input_cluster_count'} = $paraclu_input_cluster_count;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'paraclu_input_summit_count'} = $paraclu_input_summit_count;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'cluster_count'} = 0;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'summit_count'} = 0;
		$tssCluster_info_hsh_ref->{$tssClusterID}{'bedLine'} = [$chrom, $chromStart, $chromEnd, $tssClusterID, $paraclu_input_cluster_count, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts];
		print PARACLUSUMMITBED join "", (join "\t", ($chrom, $thickStart, $thickEnd, $tssClusterID, $stability, $strand)), "\n";
	}
	close PARACLUSUMMITBED;
	
	return ($tssCluster_info_hsh_ref, $paraclu_summit_bed_path);
}
sub getTssClusterCount {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $count_ctss_bed_path, $paraclu_cluster_bed_path, $paraclu_summit_bed_path, $tssCluster_info_hsh_ref
#	output: 
#	toCall: &getTssClusterCount($tssCluster_info_hsh_ref, $count_ctss_bed_path, $paraclu_summit_bed_path, $paraclu_cluster_bed_path, $bedtools_bin);
#	calledInLine: 157
#....................................................................................................................................................#
	my ($tssCluster_info_hsh_ref, $count_ctss_bed_path, $paraclu_summit_bed_path, $paraclu_cluster_bed_path, $bedtools_bin) = @_;
	
	my $count_bed_hsh_ref = {
		'summit_count' => $paraclu_summit_bed_path,
		'cluster_count' => $paraclu_cluster_bed_path,
	};
	
	foreach my $count_type (keys %{$count_bed_hsh_ref}) {
		my $count_range_bed_path = $count_bed_hsh_ref->{$count_type};
		open BEDTOOLS, "$bedtools_bin intersect -sorted -s -wo -a $count_range_bed_path -b $count_ctss_bed_path | cut -f 4,11 |";
		while (<BEDTOOLS>) {
			chomp;
			my ($tssClusterID, $count) = split /\t/;
			$tssCluster_info_hsh_ref->{$tssClusterID}{$count_type} += $count;
		}
		close BEDTOOLS;
	}

	return ();
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_defineHardCodedParam|126
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $resultScriptDir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $resultScriptDir, $scriptAbsPath);
#	calledInLine: 142
#....................................................................................................................................................#
	my ($ARGVStr, $resultScriptDir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$resultScriptDir/script.ran.pl";
	my $calledCMDPath = "$resultScriptDir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub parseParacluInput {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|739
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $cluster_ctss_bed_path, $resultParacluDir
#	output: $paraclu_input_path
#	toCall: my ($paraclu_input_path) = &parseParacluInput($cluster_ctss_bed_path, $resultParacluDir);
#	calledInLine: 154
#....................................................................................................................................................#
	my ($cluster_ctss_bed_path, $resultParacluDir) = @_;
	
	my %itemForThrHsh = ();
	my $threadID = 1;
	
	&reportAndLogStatus("Parsing paraclu input", 10, "\n");#->739
	
	my $paraclu_input_path = "$resultParacluDir/paraclu.input.txt.gz";
	$globalReadmeHsh_ref->{$paraclu_input_path}{'description'} = "Input for paraclu";

	my $cluster_count = 0;
	open PARACLUINPUT, "| gzip -c >$paraclu_input_path";
	if ($cluster_ctss_bed_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $cluster_ctss_bed_path|");
	} else {
		open (FILEIN, "<", $cluster_ctss_bed_path);
	}

	while (<FILEIN>) {
		chomp;
		my @bedAry = split /\t/;
		my $chrom = $bedAry[0];
		my $pos = $bedAry[2];
		my $score = $bedAry[4];
		my $strand = $bedAry[5];
		$cluster_count += $score;
		print PARACLUINPUT join "", (join "\t", ($chrom, $strand, $pos, $score)), "\n";
	}
	close FILEIN;
	close PARACLUINPUT;

	my $cluster_count_millions = sprintf "%.5f", $cluster_count/1000000;
	&reportAndLogStatus("cluster_count = $cluster_count_millions millions", 10, "\n");#->739

	return ($paraclu_input_path);
}
sub printFinalBedAndLog {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|739
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $min_cluster_count, $min_summit_count, $paramTag, $resultBedDir, $resultLogDir, $tssCluster_info_hsh_ref
#	output: 
#	toCall: &printFinalBedAndLog($tssCluster_info_hsh_ref, $resultBedDir, $resultLogDir, $min_cluster_count, $min_summit_count, $paramTag);
#	calledInLine: 158
#....................................................................................................................................................#
	my ($tssCluster_info_hsh_ref, $resultBedDir, $resultLogDir, $min_cluster_count, $min_summit_count, $paramTag) = @_;

	&reportAndLogStatus("printing final cluster bed and log", 10, "\n");#->739
	
	my $out_bed_file_path = "$resultBedDir/$paramTag.tssCluster.bed.gz";
	my $out_log_file_path = "$resultLogDir/$paramTag.tssCluster.log.tsv.gz";
	open OUTBED, "| sort -k1,1 -k2,2n -k6,6 | gzip -c >$out_bed_file_path";
	open OUTLOG, "| gzip -c >$out_log_file_path";

	print OUTLOG join "", (join "\t", ('tssClusterID', 'chrom', 'chromStart', 'chromEnd', 'size', 'summit_pos',  'stability', 'paraclu_input_cluster_count', 'cluster_count', 'paraclu_input_summit_count', 'summit_count')), "\n";

	$globalReadmeHsh_ref->{$out_log_file_path}{'description'} = "information of the final tssCluster (filtering by min_cluster_count and min_summit_count)";
	$globalReadmeHsh_ref->{$out_bed_file_path}{'description'} = "bed file of the final tssCluster (filtering by min_cluster_count and min_summit_count). Score column refers to number of read in the paraclu input signal";

	my $num_discard = 0;
	my $num_retained = 0;
	foreach my $tssClusterID (sort keys %{$tssCluster_info_hsh_ref}) {
		my $chrom = $tssCluster_info_hsh_ref->{$tssClusterID}{'chrom'};
		my $chromStart = $tssCluster_info_hsh_ref->{$tssClusterID}{'chromStart'};
		my $chromEnd = $tssCluster_info_hsh_ref->{$tssClusterID}{'chromEnd'};
		my $size = $tssCluster_info_hsh_ref->{$tssClusterID}{'size'};
		my $stability = $tssCluster_info_hsh_ref->{$tssClusterID}{'stability'};
		my $summit_pos = $tssCluster_info_hsh_ref->{$tssClusterID}{'summit_pos'};
		my $paraclu_input_cluster_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'paraclu_input_cluster_count'};
		my $paraclu_input_summit_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'paraclu_input_summit_count'};
		my $cluster_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'cluster_count'};
		my $summit_count = $tssCluster_info_hsh_ref->{$tssClusterID}{'summit_count'};
		
		if ($cluster_count >= $min_cluster_count and $summit_count >= $min_summit_count) {
			$num_retained++;
			print OUTLOG join "", (join "\t", ($tssClusterID, $chrom, $chromStart, $chromEnd, $size, $summit_pos,  $stability, $paraclu_input_cluster_count, $cluster_count, $paraclu_input_summit_count, $summit_count)), "\n";
			print OUTBED join "", (join "\t", (@{$tssCluster_info_hsh_ref->{$tssClusterID}{'bedLine'}})), "\n";
		} else {
			$num_discard++;
		}
	}
	
	&reportAndLogStatus("$num_retained tssClusters retained", 10, "\n");#->739
	&reportAndLogStatus("$num_discard tssClusters discarded", 10, "\n");#->739
	
	return ();
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_finishingTasks|163
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 166
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort {$a cmp $b} keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			my $headerColLen = max(@colLenCountHsh)+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}

	my $fileDir_colLen = max(@{$filelistLenCountHsh{'dir'}})+2;
	my $fileName_colLen = max(@{$filelistLenCountHsh{'name'}})+2;
	my $fileDescription_colLen = max(@{$filelistLenCountHsh{'description'}})+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|298
#	appearInSub: >none
#	primaryAppearInSection: 1_defineHardCodedParam|126, 3_finishingTasks|163
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 141, 167
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->298
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->298
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->298
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->298
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|118
#	secondaryAppearInSection: >none
#	input: none
#	output: $cluster_ctss_bed_path, $count_ctss_bed_path, $min_cluster_count, $min_paraclu_count, $min_summit_count, $outDir, $outputPrefix, $overwrite
#	toCall: my ($cluster_ctss_bed_path, $count_ctss_bed_path, $min_cluster_count, $min_summit_count, $min_paraclu_count, $outputPrefix, $outDir, $overwrite) = &readParameters();
#	calledInLine: 121
#....................................................................................................................................................#
	
	my ($cluster_ctss_bed_path, $count_ctss_bed_path, $min_cluster_count, $min_summit_count, $min_paraclu_count, $outputPrefix, $outDir, $overwrite);

	$min_summit_count = 0;
	$min_cluster_count = 2;
	$min_paraclu_count = 3;
	$overwrite= 'no';

	GetOptions 	(
		"cluster_ctss_bed_path=s"			=>	\$cluster_ctss_bed_path,
		"count_ctss_bed_path:s"				=>	\$count_ctss_bed_path,
		"min_summit_count:i"					=>	\$min_summit_count,
		"min_cluster_count:i"				=>	\$min_cluster_count,
		"min_paraclu_count:i"				=>	\$min_paraclu_count,
		"outputPrefix=s"						=>	\$outputPrefix,
		"outDir=s"								=>	\$outDir,
		"overwrite=s"							=>	\$overwrite,
		'help'									=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $cluster_ctss_bed_path;
	
	#---check file
	my $file_check_hsh_ref = {
		'cluster_ctss_bed_path' => $cluster_ctss_bed_path,
		'count_ctss_bed_path' => $count_ctss_bed_path,
	};
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}
		
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
		
	return($cluster_ctss_bed_path, $count_ctss_bed_path, $min_cluster_count, $min_summit_count, $min_paraclu_count, $outputPrefix, $outDir, $overwrite);
}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|298
#	appearInSub: checkAllExecutable|198, generateTssClusterInfoHsh|316, parseParacluInput|438, printFinalBedAndLog|486, runParaclu|761
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_ReadInfoAndRun|150
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 221, 226, 235, 244, 253, 262, 271, 280, 289, 332, 454, 481, 499, 534, 535, 782, 808
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->298
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->298
	
	return ();
}
sub runParaclu {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|739
#	appearInSub: >none
#	primaryAppearInSection: 2_ReadInfoAndRun|150
#	secondaryAppearInSection: >none
#	input: $cut_sh_path, $min_paraclu_count, $paraclu_bin, $paraclu_input_path, $resultParacluDir
#	output: $paraclu_cluster_bed_path
#	toCall: my ($paraclu_cluster_bed_path) = &runParaclu($paraclu_input_path, $paraclu_bin, $cut_sh_path, $resultParacluDir, $min_paraclu_count);
#	calledInLine: 155
#....................................................................................................................................................#
	my ($paraclu_input_path, $paraclu_bin, $cut_sh_path, $resultParacluDir, $min_paraclu_count) = @_;
	
	my %itemForThrHsh = ();
	my $threadID = 1;
		
	my $paraclu_sh_path = "$resultParacluDir/run_paraclu.sh";
	my $paraclu_uncut_path = "$resultParacluDir/paraclu.output.uncut.txt.gz";
	my $paraclu_cut_path = "$resultParacluDir/paraclu.output.cut.txt.gz";
	my $paraclu_cluster_bed_path = "$resultParacluDir/paraclu.cluster.bed.gz";

	&reportAndLogStatus("Running paraclu", 10, "\n");#->739
	open PARACLUSH, ">", "$paraclu_sh_path";
	print PARACLUSH "$paraclu_bin $min_paraclu_count <(gzip -dc $paraclu_input_path) | gzip -c >$paraclu_uncut_path\n";
	print PARACLUSH "$cut_sh_path <(gzip -dc $paraclu_uncut_path) | gzip -c >$paraclu_cut_path\n";
	close PARACLUSH;
	system "bash $paraclu_sh_path";

	$globalReadmeHsh_ref->{$paraclu_sh_path}{'description'} = "bash script to run paraclu. Please refer to http://cbrc3.cbrc.jp/~martin/paraclu/";
	$globalReadmeHsh_ref->{$paraclu_uncut_path}{'description'} = "raw paraclu output file, before 'cutting'. Please refer to http://cbrc3.cbrc.jp/~martin/paraclu/";
	$globalReadmeHsh_ref->{$paraclu_cut_path}{'description'} = "paraclu output file, after 'cutting'. Please refer to http://cbrc3.cbrc.jp/~martin/paraclu/";
	$globalReadmeHsh_ref->{$paraclu_cluster_bed_path}{'description'} = "bed file parsed paraclu output after 'cutting'";
	
	my $min_non_zero_d = 10000000;
	open PARACLUOUTPUT, "gzip -dc $paraclu_cut_path |";
	while (<PARACLUOUTPUT>) {
		next if $_ =~ m/^#/;
		chomp;
		# sequence, strand, start, end, sites, sum of values, min d, max d
		#chr1	+	24423	248946143	90912	487284	-1e+100	1.49e-05
		my ($chrom, $strand, $start, $end, $sites, $score, $min_d, $max_d) = split /\t/;
		if ($min_non_zero_d > $min_d and $min_d > 0) {
			$min_non_zero_d = $min_d;
		}
	}
	close PARACLUOUTPUT;

	&reportAndLogStatus("Parsing paraclu output", 10, "\n");#->739
	open PARACLUBED, "| sort -k1,1 -k2,2n | gzip -c >$paraclu_cluster_bed_path";
	open PARACLUOUTPUT, "gzip -dc $paraclu_cut_path |";
	while (<PARACLUOUTPUT>) {
		next if $_ =~ m/^#/;
		chomp;
		# sequence, strand, start, end, sites, sum of values, min d, max d
		#chr1	+	24423	248946143	90912	487284	-1e+100	1.49e-05
		my ($chrom, $strand, $start, $end, $sites, $score, $min_d, $max_d) = split /\t/;
		my $chromStart = $start - 1;
		my $chromEnd = $end;
		$min_d = $min_non_zero_d if $min_d < $min_non_zero_d;
		my $stability = log($max_d/$min_d)/log(2);
		
		my $tssClusterID = join "_", ($chrom, $chromStart, $chromEnd, $strand);
		print PARACLUBED join "", (join "\t", ($chrom, $chromStart, $chromEnd, $tssClusterID, $stability, $strand)), "\n";
	}
	close PARACLUOUTPUT;
	close PARACLUBED;

	return ($paraclu_cluster_bed_path);
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 106
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































