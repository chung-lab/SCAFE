#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use threads ('stack_size' => 64*4096);
use threads::shared;
use List::Util qw (sum shuffle min max);
use Cwd 'abs_path';
use AutoLoader qw/AUTOLOAD/;
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                               ---> scafe.tool.sc.bam_to_ctss <---
                     <--- tool, single-cell mode, convert bam to ctss --->

 Description:
   This tool converts a bam file to a ctss bed file, identifies read 5'end (capped TSS, i.e. ctss),
   extracts the unencoded G information, pileup ctss, and deduplicate the UMI

 Usage:
   scafe.tool.sc.bam_to_ctss [options] --bamPath --genome --outputPrefix --outDir
   
   --bamPath                       <required> [string] bam file from cellranger, can be read 1 only or pair-end
   --genome                        <required> [string] name of genome reference, e.g. hg19.gencode_v32lift37
   --outputPrefix                  <required> [string] prefix for the output files
   --outDir                        <required> [string] directory for the output files
   --include_flag                  (optional) [string] samflag to be included, comma delimited 
                                                       e.g. '64' to include read1, (default=null)
   --exclude_flag                  (optional) [string] samflag to be excluded, comma delimited, 
                                                       e.g. '128,256,4' to exclude read2, secondary alignment 
                                                       and unaligned reads (default=128,256,4)
   --min_MAPQ                     (optional) [integer] minimum MAPQ to include (default=0)
   --max_thread                   (optional) [integer] maximum number of parallel threads, capped at 10 to 
                                                       avoid memory overflow (default=5)
   --TS_oligo_seq                  (optional) [string] Template switching oligo sequence for identification of 
                                                       5'end (default=TTTCTTATATGGG) 
   --detect_TS_oligo (optional) [match/trim/skip/auto] in bam_to_ctss step, the modes of detecting TS oligo. 1. match: search for 
                                                       TS oligo sequence on the read, identify the TSO/cDNA junction as 5'end of 
                                                       the read. This works only when the error rate of the TS oligo region on 
                                                       the read is low, otherwise a considerable number of read will be invalid. 
                                                       2. trim: assuming the 1st N bases of the reads are TS oligo, without 
                                                       checking the actual sequence. N is determined by the length of TS oligo. 
                                                       3. skip: assuming the TS oligo was not sequenced, the 1st base of the read
                                                       will be treated as the 1st base after the TS oligo. 4. auto: automatically 
                                                       determines the best mode, best of the observed error rate of the TS oligo
                                                       and the frequency of 5'end softclipped bases by the aligner. If softcliped 
                                                       bases is close to the length of TS oligo, mode 1 or 2 will be chosen, 
                                                       depending on the observed error rate of the TS oligo (error rate <= 0.1, 
                                                       mode 1 will be chosen or mode 2 otherwise). If softcliped base os close to 
                                                       zero, mode 3 will be chosen. (default=auto).
   --overwrite                    (optional) [yes/no]  erase outDir/outputPrefix before running (default=no)

 Dependencies:
   bedtools
   samtools
   tabix
   bgzip
   
 For demo, cd to SCAFE dir and run,
   scafe.tool.sc.bam_to_ctss \
   --overwrite=yes \
   --bamPath=./demo/input/sc.solo/demo.cellranger.bam \
   --genome=hg19.gencode_v32lift37 \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.solo/bam_to_ctss/

=head1 VERSION

v0.9.0-beta [March 20, 2021]
	-Initial pre-release

v1.0.0 [June 6, 2022]
	-updated the TSO detection and trimming method
	-updated regular expression to get UMI and CB to be more permissive
	-use tabix/bgzip for splitting be into chunks

v1.0.1 [June 26, 2022]
	-No update
	
=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->2013
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->790
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($bamPath, $exclude_flag, $include_flag, $min_MAPQ, $max_thread, $TS_oligo_seq, $detect_TS_oligo, $genome, $outputPrefix, $outDir, $overwrite) = &readParameters();#->1911
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $paramTag = "$outputPrefix";
my $rm_tmp_file = 'yes';
my $sanity_check_toggle = 'yes';
my $num_chunk = 100;
my $TS_oligo_check_tail_length = 5;
my $max_mismatch = 1;
my $regex_match_margin = 5;
my $softclip_margin = 7;
my $min_match_length = 5;
my $max_non_G_mismatch = 10; #---[2021/08/15 15:44] maximum number of non-G mismatch allowed
my $num_subsample = 100000; #---[2021/08/15 15:39] number of read to be sampled for TSO presence detection
my $min_frac_subsample = 0.01; #---[2021/08/15 15:39] subsample fraction (-s option in samtools) for TSO presence detection
$max_thread = 20 if $max_thread > 20;
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineOutDirPath
#
#<section ID="defineOutDirPath" num="2">
my @mkDirAry;
my $result_dir = "$outDir/$paramTag"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $result_bed_dir = "$result_dir/bed/"; push @mkDirAry, $result_bed_dir;
my $result_log_dir = "$result_dir/log/"; push @mkDirAry, $result_log_dir;
my $result_script_dir = "$result_dir/script/"; push @mkDirAry, $result_script_dir;
my $result_tmp_dir = "$result_dir/tmp/"; push @mkDirAry, $result_tmp_dir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 777 $dir");}

open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->1392
&printStartOrFinishMessage("startMessage");#->1783
my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();#->347
my ($chrom_name_path, $chrom_size_path, $genome_fasta_path) = &checkChromNameSizeGenomeFastaPath($genome);#->447
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_checkTSO
#
#<section ID="checkTSO" num="3">
my ($chosen_TSO_detection_mode, $CB_UMI_offset) = &chooseTSODetectionMode($bedtools_bin, $samtools_bin, $bamPath, $exclude_flag, $include_flag, $TS_oligo_seq, $TS_oligo_check_tail_length, $num_subsample, $min_frac_subsample, $detect_TS_oligo);#->616
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_convert
#
#<section ID="convert" num="4">
my ($chrom_name_size_hsh_ref, $out_chrom_size_hsh_ref) = &generateChromNameConversionHsh($chrom_name_path, $chrom_size_path, $samtools_bin, $bamPath);#->844
my ($chunk_size) = &generateChunkSize($out_chrom_size_hsh_ref, $num_chunk);#->968
my ($chunk_info_hsh_ref) = &generateChunkInfoHsh($chrom_name_size_hsh_ref, $chunk_size, $result_tmp_dir);#->914
&processPerChunk($bamPath, $bedtools_bin, $samtools_bin, $max_thread, $chunk_info_hsh_ref, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $min_MAPQ, $TS_oligo_seq, $genome_fasta_path, $out_chrom_size_hsh_ref, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch, $chosen_TSO_detection_mode, $CB_UMI_offset);#->1817
&poolChunkResults($tabix_bin, $bgzip_bin, $max_thread, $chunk_info_hsh_ref, $result_bed_dir, $result_log_dir, $paramTag, $result_tmp_dir, $rm_tmp_file);#->1532
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 5_finishingTasks
#
#<section ID="finishingTasks" num="5">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->1668
&printStartOrFinishMessage("finishMessage");#->1783
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	general [n=5]:
#		currentTime, logCalledCMDAndScript, printStartOrFinishMessage
#		readParameters, timeStamp
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	specific [n=1]:
#		convertBamToCTSS
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=23]:
#		calculateEditDistance, checkAllExecutable, checkChromNameSizeGenomeFastaPath
#		checkChunkResults, checkTSOPresence, chooseTSODetectionMode
#		defineTSOCheckParam, generateChromNameConversionHsh, generateChunkInfoHsh
#		generateChunkSize, generateMisMatchRegex, getCTSS_match_TS_oligo
#		getCTSS_skip_TS_oligo, getCTSS_trim_TS_oligo, getCheckSeq
#		getChunkFasta, getEnd5StartUnencodedG, getSoftclipMatch
#		getSubsampleFraction, getTSOMatchPosition, pileupCBDedupUMI
#		poolChunkResults, processPerChunk
#
#====================================================================================================================================================#

sub calculateEditDistance {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: checkTSOPresence|494
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $seq1, $seq2
#	output: $edit
#	toCall: my ($edit) = &calculateEditDistance($seq1, $seq2);
#	calledInLine: 605
#....................................................................................................................................................#
	my ($seq1, $seq2) = @_;

	my $edit = '0';

	my $match = '1';
	my $mismatch = '-1';
	my $gap = '-1';

	my @matrix;
	$matrix[0][0]{score} = 0;
	$matrix[0][0]{pointer} = "none";
	for(my $j = 1; $j <= length($seq1); $j++) {
	   $matrix[0][$j]{score}   = $gap * $j;
	   $matrix[0][$j]{pointer} = "left";
	}
	for (my $i = 1; $i <= length($seq2); $i++) {
	   $matrix[$i][0]{score}   = $gap * $i;
	   $matrix[$i][0]{pointer} = "up";
	}

	# fill
	for(my $i = 1; $i <= length($seq2); $i++) {
	   for(my $j = 1; $j <= length($seq1); $j++) {
		  my ($diagonal_score, $left_score, $up_score);

		  # calculate match score
		  my $letter1 = substr($seq1, $j-1, 1);
		  my $letter2 = substr($seq2, $i-1, 1);
		  if ($letter1 eq $letter2) {
			 $diagonal_score = $matrix[$i-1][$j-1]{score} + $match;
		  } else {
			 $diagonal_score = $matrix[$i-1][$j-1]{score} + $mismatch;
		  }

		  # calculate gap scores
		  $up_score   = $matrix[$i-1][$j]{score} + $gap;
		  $left_score = $matrix[$i][$j-1]{score} + $gap;

		  # choose best score
		  if ($diagonal_score >= $up_score) {
			 if ($diagonal_score >= $left_score) {
				$matrix[$i][$j]{score}   = $diagonal_score;
				$matrix[$i][$j]{pointer} = "diagonal";
			 } else {
				$matrix[$i][$j]{score}   = $left_score;
				$matrix[$i][$j]{pointer} = "left";
			 }
		  } else {
			 if ($up_score >= $left_score) {
				$matrix[$i][$j]{score}   = $up_score;
				$matrix[$i][$j]{pointer} = "up";
			 } else {
				$matrix[$i][$j]{score}   = $left_score;
				$matrix[$i][$j]{pointer} = "left";
			 }
		  }
	   }
	}
	# trace-back
	my $align1 = "";
	my $align2 = "";

	# start at last cell of matrix
	my $j = length($seq1);
	my $i = length($seq2);

	while (1) {
	   last if $matrix[$i][$j]{pointer} eq "none"; # ends at first cell of matrix

	   if ($matrix[$i][$j]{pointer} eq "diagonal") {
		  $align1 .= substr($seq1, $j-1, 1);
		  $align2 .= substr($seq2, $i-1, 1);
		  $i--;
		  $j--;
	   } elsif ($matrix[$i][$j]{pointer} eq "left") {
		  $align1 .= substr($seq1, $j-1, 1);
		  $align2 .= "-";
		  $j--;
	   } elsif ($matrix[$i][$j]{pointer} eq "up") {
		  $align1 .= "-";
		  $align2 .= substr($seq2, $i-1, 1);
		  $i--;
	   }
	}
	$align1 = reverse $align1;
	$align2 = reverse $align2;

	for (my $i=0; $i<length($align1); ++$i){
		if (substr($align1,$i,1) ne substr($align2,$i,1)){
      		++$edit;
		}
	}

	return($edit);
}
sub checkAllExecutable {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1991
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|155
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedGraphToBigWig_bin, $bedtools_bin, $bgzip_bin, $bigWigAverageOverBed_bin, $cut_sh_path, $paraclu_bin, $samtools_bin, $tabix_bin
#	toCall: my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();
#	calledInLine: 170
#....................................................................................................................................................#
	
	my $dirPath = dirname(rel2abs($0));

	my $tabix_bin = "$dirPath/../resources/bin/tabix/tabix";
	my $bgzip_bin = "$dirPath/../resources/bin/bgzip/bgzip";
	my $bedtools_bin = "$dirPath/../resources/bin/bedtools/bedtools";
	my $samtools_bin = "$dirPath/../resources/bin/samtools/samtools";
	my $paraclu_bin = "$dirPath/../resources/bin/paraclu/paraclu";
	my $cut_sh_path = "$dirPath/../resources/bin/paraclu/paraclu-cut.sh";
	my $bedGraphToBigWig_bin = "$dirPath/../resources/bin/bedGraphToBigWig/bedGraphToBigWig";
	my $bigWigAverageOverBed_bin = "$dirPath/../resources/bin/bigWigAverageOverBed/bigWigAverageOverBed";
	
	&reportAndLogStatus("Checking all SCAFE executables", 10, "\n");#->1991
	
	{
		my $stdOut = `$tabix_bin  --version 2>&1`;
		if ($stdOut =~ m/tabix \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: tabix version: $1", 0, "\n");#->1991
		} else {
			die "tabix is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bgzip_bin --version 2>&1`;
		if ($stdOut =~ m/bgzip \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: bgzip version: $1", 0, "\n");#->1991
		} else {
			die "bgzip is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedtools_bin --version 2>&1`;
		if ($stdOut =~ m/bedtools v(\S+)/) {
			&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->1991
		} else {
			die "bedtools is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$samtools_bin 2>&1`;
		if ($stdOut =~ m/\s+(Version: \S+)\s+/) {
			&reportAndLogStatus("Checking: samtools version: $1", 0, "\n");#->1991
		} else {
			die "samtools is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$paraclu_bin 2>&1`;
		if ($stdOut =~ m/paraclu: I need a minValue and a fileName/) {
			&reportAndLogStatus("Checking: paraclu found.", 0, "\n");#->1991
		} else {
			die "paraclu is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$cut_sh_path 55C7128A 2>&1`;
		if ($stdOut =~ m/awk:/) {
			&reportAndLogStatus("Checking: paraclu-cut found.", 0, "\n");#->1991
		} else {
			die "paraclu-cut is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedGraphToBigWig_bin 2>&1`;
		if ($stdOut =~ m/bedGraphToBigWig v (\S+)/) {
			&reportAndLogStatus("Checking: bedGraphToBigWig version: $1", 0, "\n");#->1991
		} else {
			die "bedGraphToBigWig not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bigWigAverageOverBed_bin 2>&1`;
		if ($stdOut =~ m/bigWigAverageOverBed v(\S+)/) {
			&reportAndLogStatus("Checking: bigWigAverageOverBed version: $1", 0, "\n");#->1991
		} else {
			die "bigWigAverageOverBed is not installed properly. Quitting.\n";
		}
	}

	return ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin);
}
sub checkChromNameSizeGenomeFastaPath {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|155
#	secondaryAppearInSection: >none
#	input: $genome
#	output: $chrom_name_path, $chrom_size_path, $genome_fasta_path
#	toCall: my ($chrom_name_path, $chrom_size_path, $genome_fasta_path) = &checkChromNameSizeGenomeFastaPath($genome);
#	calledInLine: 171
#....................................................................................................................................................#
	my ($genome) = @_;
	
	my $dirPath = dirname(rel2abs($0));
	my $chrom_name_path = "$dirPath/../resources/genome/$genome/tsv/chrom.bam_name.tsv";
	my $chrom_size_path = "$dirPath/../resources/genome/$genome/tsv/chrom.sizes.tsv";
	my $genome_fasta_path = "$dirPath/../resources/genome/$genome/fasta/genome.fa";
	die "genome $genome does not have chrom_name_path. Please rerun prep_genome step\n" if not -s $chrom_name_path;
	die "genome $genome does not have chrom_size_path. Please rerun prep_genome step\n" if not -s $chrom_size_path;
	die "genome $genome does not have genome_fasta_path. Please rerun prep_genome step\n" if not -s $genome_fasta_path;
	
	return ($chrom_name_path, $chrom_size_path, $genome_fasta_path);
}
sub checkChunkResults {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1991
#	appearInSub: poolChunkResults|1532, processPerChunk|1817
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 4_convert|184
#	input: $chunk_info_hsh_ref, $chunk_num, $file_check_ary_ref
#	output: $valid
#	toCall: my ($valid) = &checkChunkResults($chunk_info_hsh_ref, $chunk_num, $file_check_ary_ref);
#	calledInLine: 1565, 1854
#....................................................................................................................................................#
	my ($chunk_info_hsh_ref, $chunk_num, $file_check_ary_ref) = @_;
	
	my $valid = 'yes';
	foreach my $file_to_check (@{$file_check_ary_ref}) {
		my $file_path =  $chunk_info_hsh_ref->{$chunk_num}{$file_to_check};
		#&reportAndLogStatus("$file_path", 10, "\n");#->1991
		$valid = 'no' if not -f $file_path;
	}
	
	return ($valid);
}
sub checkTSOPresence {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: calculateEditDistance|240, reportAndLogStatus|1991
#	appearInSub: chooseTSODetectionMode|616
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_checkTSO|176
#	input: $TS_oligo_check_tail_length, $TS_oligo_seq, $bamPath, $bedtools_bin, $exclude_flag, $frac_subsample, $include_flag, $num_subsample, $samtools_bin
#	output: $CB_UMI_offset, $avg_softclip_length, $error_rate
#	toCall: my ($error_rate, $avg_softclip_length, $CB_UMI_offset) = &checkTSOPresence($bedtools_bin, $samtools_bin, $bamPath, $exclude_flag, $include_flag, $TS_oligo_seq, $TS_oligo_check_tail_length, $num_subsample, $frac_subsample);
#	calledInLine: 635
#....................................................................................................................................................#
	my ($bedtools_bin, $samtools_bin, $bamPath, $exclude_flag, $include_flag, $TS_oligo_seq, $TS_oligo_check_tail_length, $num_subsample, $frac_subsample) = @_;
	
	my $ex_F_param = '';
	my $in_f_param = '';
	my $subsample_s_param = '';
	my $TSO_length = length($TS_oligo_seq);
	my $check_start_pos = $TSO_length-$TS_oligo_check_tail_length;
	
	my $check_TS_oligo_seq = substr $TS_oligo_seq, $check_start_pos, $TS_oligo_check_tail_length;
	
	if (defined $exclude_flag) {
		my @flagAry = ();
		foreach my $flag (split /,/, $exclude_flag) {
			push @flagAry, "-F $flag";
		}
		$ex_F_param = join " ", @flagAry;
	}

	if (defined $include_flag) {
		my @flagAry = ();
		foreach my $flag (split /,/, $include_flag) {
			push @flagAry, "-f $flag";
		}
		$in_f_param = join " ", @flagAry;
	}
	
	if ($frac_subsample >= 0.75) {
		$subsample_s_param = '';
	} else {
		$subsample_s_param = "-s $frac_subsample";
	}
	
	my $perl_covert_readname = 'while (<STDIN>) {chomp; @samAry = split /\t/;if ($_ =~ m/\tCB:Z:([^\t]+)\t.*UB:Z:([^\t]+)/) {$samAry[0] = $1."_".$2."_".$samAry[9];print join "", (join "\t", @samAry[0..10]), "\n";} elsif ($_ =~ m/\tUB:Z:([^\t]+)\t.*CB:Z:([^\t]+)/) {$samAry[0] = $2."_".$1."_".$samAry[9];print join "", (join "\t", @samAry[0..10]), "\n";} elsif ($_ =~ m/^\@/) {print "$_\n";}};';
	my $read_hsh_ref = {};
	open (BAMIN, "$samtools_bin view -h $subsample_s_param $in_f_param $ex_F_param $bamPath 2>/dev/null | perl -e \'$perl_covert_readname\' | $samtools_bin view -b - | $bedtools_bin bamtobed -cigar -i stdin | head -n $num_subsample |");
	my $total_num = 0;
	my $data_hsh_ref = {};
	while (my $line = <BAMIN>) {
		chomp $line;
		my ($chrom, $bedStart, $bedEnd, $CB_UMI_Seq, $MAPQ, $strand, $cigar) = split /\t+/, $line;
		my ($CB, $UMI, $rd_seq) = split /\_/, $CB_UMI_Seq;
		$rd_seq =~ s/\/\d$//;
		my $softclip_length = 0;
		if ($strand eq '+') {
			if ($cigar =~ m/^(\d+)S(\d+)M/) {
				$softclip_length = $1;
			}
		} else {
			$rd_seq = reverse $rd_seq;
			$rd_seq =~ tr/ATGCatgc/TACGtacg/;
			if ($cigar =~ m/(\d+)M(\d+)S$/) {
				$softclip_length = $2;
			}
		}
		$CB =~ s/\-.+$//;
		my $UMI_length = length($UMI);
		my $CB_length = length($CB);
		push @{$data_hsh_ref->{'rd_seq'}}, $rd_seq;
		push @{$data_hsh_ref->{'softclip_length'}}, $softclip_length;
		push @{$data_hsh_ref->{'UMI_length'}}, $UMI_length;
		push @{$data_hsh_ref->{'CB_length'}}, $CB_length;
		$data_hsh_ref->{'count_softclip_length'}{$softclip_length}++;
		$total_num++;
		&reportAndLogStatus("$total_num read sampled", 10, "\n") if $total_num%10000==0;#->1991
	}
	close BAMIN;

	my $avg_softclip_length = sprintf "%.5f", sum(@{$data_hsh_ref->{'softclip_length'}})/$total_num;
	my $avg_CB_length = sprintf "%.5f", sum(@{$data_hsh_ref->{'CB_length'}})/$total_num;
	my $avg_UMI_length = sprintf "%.5f", sum(@{$data_hsh_ref->{'UMI_length'}})/$total_num;
	my $rank = 0;
	my $rank_hsh_ref = {};
	foreach my $softclip_length (sort {$data_hsh_ref->{'count_softclip_length'}{$b} <=> $data_hsh_ref->{'count_softclip_length'}{$a}} keys %{$data_hsh_ref->{'count_softclip_length'}}) {
		$rank++;
		my $pct = sprintf "%.5f", 100*($data_hsh_ref->{'count_softclip_length'}{$softclip_length}/$total_num);
		$rank_hsh_ref->{$rank} = [$softclip_length, $pct];
	}

	my ($first_softclip_length, $first_softclip_length_pct) = @{$rank_hsh_ref->{1}};
	my ($second_softclip_length, $second_softclip_length_pct) = @{$rank_hsh_ref->{2}};
	my ($third_softclip_length, $third_softclip_length_pct) = @{$rank_hsh_ref->{3}};

	&reportAndLogStatus("average CB length=$avg_CB_length", 10, "\n");#->1991
	&reportAndLogStatus("average UMI length=$avg_UMI_length", 10, "\n");#->1991
	&reportAndLogStatus("average softclip length=$avg_softclip_length", 10, "\n");#->1991
	&reportAndLogStatus("1st ranked softclip length=$first_softclip_length [$first_softclip_length_pct%]", 10, "\n");#->1991
	&reportAndLogStatus("2nd ranked softclip length=$second_softclip_length [$second_softclip_length_pct%]", 10, "\n");#->1991
	&reportAndLogStatus("3rd ranked softclip length=$third_softclip_length [$third_softclip_length_pct%]", 10, "\n");#->1991
	
	my $CB_UMI_offset = 0;
	my $CB_UMI_TSO_length = $TSO_length+$avg_CB_length+$avg_UMI_length;
	
	if ($avg_softclip_length >= $CB_UMI_TSO_length - 2 and $avg_softclip_length <= $CB_UMI_TSO_length + 2) {
		$CB_UMI_offset = $avg_CB_length+$avg_UMI_length;
	}
	
	my $offset_check_start_pos = $check_start_pos+$CB_UMI_offset;
	&reportAndLogStatus("calculating error rate with offset_check_start_pos = $offset_check_start_pos", 10, "\n");#->1991
	foreach my $rd_seq (@{$data_hsh_ref->{'rd_seq'}}) {
		my $check_rd_seq = substr $rd_seq, $offset_check_start_pos, $TS_oligo_check_tail_length;
		my ($edit_dist) = &calculateEditDistance($check_rd_seq, $check_TS_oligo_seq);#->240
		my $dist_per_nt = sprintf "%.5f", $edit_dist/$TS_oligo_check_tail_length;
		push @{$data_hsh_ref->{'dist_per_nt'}}, $dist_per_nt;
	}

	my $error_rate = sprintf "%.5f", sum(@{$data_hsh_ref->{'dist_per_nt'}})/$total_num;
	&reportAndLogStatus("TSO error_rate=$error_rate", 10, "\n");#->1991
	
	return ($error_rate, $avg_softclip_length, $CB_UMI_offset);
}
sub chooseTSODetectionMode {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: checkTSOPresence|494, getSubsampleFraction|1336, reportAndLogStatus|1991
#	appearInSub: >none
#	primaryAppearInSection: 3_checkTSO|176
#	secondaryAppearInSection: >none
#	input: $TS_oligo_check_tail_length, $TS_oligo_seq, $bamPath, $bedtools_bin, $detect_TS_oligo, $exclude_flag, $include_flag, $min_frac_subsample, $num_subsample, $samtools_bin
#	output: $CB_UMI_offset, $chosen_TSO_detection_mode
#	toCall: my ($chosen_TSO_detection_mode, $CB_UMI_offset) = &chooseTSODetectionMode($bedtools_bin, $samtools_bin, $bamPath, $exclude_flag, $include_flag, $TS_oligo_seq, $TS_oligo_check_tail_length, $num_subsample, $min_frac_subsample, $detect_TS_oligo);
#	calledInLine: 179
#....................................................................................................................................................#
	my ($bedtools_bin, $samtools_bin, $bamPath, $exclude_flag, $include_flag, $TS_oligo_seq, $TS_oligo_check_tail_length, $num_subsample, $min_frac_subsample, $detect_TS_oligo) = @_;
	
	my $chosen_TSO_detection_mode;
	my $max_error_rate = 0.10; #---[2021/08/15 16:19] max error_rate
	my $softclip_margin = 3;

	&reportAndLogStatus("Checking TSO presence in bam", 10, "\n");#->1991
	my ($frac_subsample) = &getSubsampleFraction($min_frac_subsample, $num_subsample, $samtools_bin, $bamPath);#->1336
	my ($error_rate, $avg_softclip_length, $CB_UMI_offset) = &checkTSOPresence($bedtools_bin, $samtools_bin, $bamPath, $exclude_flag, $include_flag, $TS_oligo_seq, $TS_oligo_check_tail_length, $num_subsample, $frac_subsample);#->494
	
	if ($detect_TS_oligo eq 'auto') {
		if ($avg_softclip_length <= $softclip_margin) {
			$chosen_TSO_detection_mode = 'skip';
			&reportAndLogStatus("chosen_TSO_detection_mode is auto defined as $chosen_TSO_detection_mode", 10, "\n");#->1991

		} elsif ($avg_softclip_length >= ($CB_UMI_offset+length($TS_oligo_seq)-$softclip_margin) and $avg_softclip_length <= ($CB_UMI_offset+length($TS_oligo_seq)+$softclip_margin)) {
			if ($error_rate <= $max_error_rate) {
				$chosen_TSO_detection_mode = 'match';
				&reportAndLogStatus("chosen_TSO_detection_mode is auto defined as $chosen_TSO_detection_mode", 10, "\n");#->1991
			} else {
				$chosen_TSO_detection_mode = 'trim';
				&reportAndLogStatus("chosen_TSO_detection_mode is auto defined as $chosen_TSO_detection_mode", 10, "\n");#->1991
			}
		} else {
			die "Quitting: Auto detection of TS oligo failed. Average softclip length is ambiguous.\n";
		}
	} else {
		$chosen_TSO_detection_mode = $detect_TS_oligo;
		&reportAndLogStatus("chosen_TSO_detection_mode is user defined as $chosen_TSO_detection_mode", 10, "\n");#->1991
	}

	return ($chosen_TSO_detection_mode, $CB_UMI_offset);
}
sub convertBamToCTSS {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: generateMisMatchRegex|993, getCTSS_match_TS_oligo|1062, getCTSS_skip_TS_oligo|1096, getCTSS_trim_TS_oligo|1128, reportAndLogStatus|1991
#	appearInSub: processPerChunk|1817
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 4_convert|184
#	input: $CB_UMI_offset, $TS_oligo_check_tail_length, $TS_oligo_seq, $bamPath, $bedtools_bin, $chosen_TSO_detection_mode, $chrom_name_size_hsh_ref, $chunk_UMI_CB_ctss_bed_path, $chunk_endPos, $chunk_fasta_offset_pos, $chunk_fasta_path, $chunk_log_path, $chunk_sanity_check_path, $chunk_seq_str, $chunk_startPos, $chunk_unsort_UMI_CB_ctss_bed_path, $exclude_flag, $include_flag, $max_mismatch, $max_non_G_mismatch, $min_MAPQ, $min_match_length, $regex_match_margin, $region_str, $samtools_bin, $sanity_check_toggle, $softclip_margin
#	output: 
#	toCall: &convertBamToCTSS($bamPath, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $bedtools_bin, $samtools_bin, $min_MAPQ, $chunk_UMI_CB_ctss_bed_path, $chunk_unsort_UMI_CB_ctss_bed_path, $region_str, $chunk_log_path, $chunk_startPos, $chunk_endPos, $TS_oligo_seq, $chunk_fasta_path, $chunk_seq_str, $chunk_fasta_offset_pos, $chunk_sanity_check_path, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch, $chosen_TSO_detection_mode, $CB_UMI_offset);
#	calledInLine: 1875
#....................................................................................................................................................#
	my ($bamPath, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $bedtools_bin, $samtools_bin, $min_MAPQ, $chunk_UMI_CB_ctss_bed_path, $chunk_unsort_UMI_CB_ctss_bed_path, $region_str, $chunk_log_path, $chunk_startPos, $chunk_endPos, $TS_oligo_seq, $chunk_fasta_path, $chunk_seq_str, $chunk_fasta_offset_pos, $chunk_sanity_check_path, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch, $chosen_TSO_detection_mode, $CB_UMI_offset) = @_;
	
	if (not -s $chunk_UMI_CB_ctss_bed_path) {
		#&reportAndLogStatus("converting $paramTag bam to ctss bed", 10, "\n");#->1991
		my $perl_covert_readname = 'while (<STDIN>) {chomp; @samAry = split /\t/;if ($_ =~ m/\tCB:Z:([^\t]+)\t.*UB:Z:([^\t]+)/) {$samAry[0] = $1."_".$2."_".$samAry[9];print join "", (join "\t", @samAry[0..10]), "\n";} elsif ($_ =~ m/\tUB:Z:([^\t]+)\t.*CB:Z:([^\t]+)/) {$samAry[0] = $2."_".$1."_".$samAry[9];print join "", (join "\t", @samAry[0..10]), "\n";} elsif ($_ =~ m/^\@/) {print "$_\n";}};';
		my $margin = 20;
		my $min_total_match = 30;
		my $num_proc = 0;
		my $ex_F_param = '';
		my $in_f_param = '';
		if (defined $exclude_flag) {
			my @flagAry = ();
			foreach my $flag (split /,/, $exclude_flag) {
				push @flagAry, "-F $flag";
			}
			$ex_F_param = join " ", @flagAry;
		}

		if (defined $include_flag) {
			my @flagAry = ();
			foreach my $flag (split /,/, $include_flag) {
				push @flagAry, "-f $flag";
			}
			$in_f_param = join " ", @flagAry;
		}

		#---[6/18/15 14:23] get all
		open (BAMIN, "$samtools_bin view -h $in_f_param $ex_F_param $bamPath $region_str 2>/dev/null | perl -e \'$perl_covert_readname\' | $samtools_bin view -b - | $bedtools_bin bamtobed -cigar -i stdin |");
		#open (CTSSOUT, "| sort -k1,1 -k2,2n -k6,6 >$chunk_UMI_CB_ctss_bed_path");
		open (CTSSOUT, ">", $chunk_unsort_UMI_CB_ctss_bed_path);
		open SANITYCHECK, ">", $chunk_sanity_check_path;
		print SANITYCHECK join "", (join "\t", ('out_chrom', 'bedStart', 'bedEnd', 'strand', 'rd_seq', 'check_read_seq', 'check_genome_seq', 'cigar', 'softclip_length', 'match_length', 'check_read_pos', 'trim_length', 'num_unencoded_G', 'non_G_mismatch')), "\n";

		my $TS_oligo_length = length $TS_oligo_seq;
		my $check_TS_oligo_substr = -1*$TS_oligo_check_tail_length;

		my $check_TS_oligo_seq = substr $TS_oligo_seq, $check_TS_oligo_substr;
		
		my $min_softclip_length = $CB_UMI_offset + $TS_oligo_length - $softclip_margin;
		my $max_softclip_length = $CB_UMI_offset + $TS_oligo_length + $softclip_margin;
		my $min_regex_match_pos = $CB_UMI_offset + $TS_oligo_length - $regex_match_margin;
		my $max_regex_match_pos = $CB_UMI_offset + $TS_oligo_length + $regex_match_margin;

		my $match_string = $check_TS_oligo_seq;
		my ($regex_string) = &generateMisMatchRegex($match_string, $max_mismatch);#->993
		my $check_TS_oligo_regex = $regex_string;
		
		#&reportAndLogStatus("REGEX for TS_oligo check:$check_TS_oligo_regex", 10, "\n");#->1991
		
		my $chunk_total_read_num = 0;
		my $chunk_passed_read_num = 0;
		
		while (my $line = <BAMIN>) {
			chomp $line;
			my ($chrom, $bedStart, $bedEnd, $CB_UMI_Seq, $MAPQ, $strand, $cigar) = split /\t+/, $line;
			$chunk_total_read_num++;
			my $total_match = 0;
			$total_match = sum($cigar =~ m/(\d+)M/g) if $cigar =~ /\d+M/;

			next if $MAPQ < $min_MAPQ;
			next if $total_match < $min_total_match;
			my ($CB, $UMI, $bam_seq) = split /\_/, $CB_UMI_Seq;
			my $readname = join "_", ($CB, $UMI);
			$bam_seq =~ s/\/\d$//;
			my $out_chrom = $chrom_name_size_hsh_ref->{$chrom}{'out_chrom'};
			my $size = $chrom_name_size_hsh_ref->{$chrom}{'size'};

			
			#&reportAndLogStatus("passed_read_num = $passed_read_num", 10, "\n") if ($passed_read_num%10000 == 0);#->1991
			
			my ($end5Start, $num_unencoded_G, $sanity_check_ary_ref);
			
			if ($chosen_TSO_detection_mode eq 'match') {
				($end5Start, $num_unencoded_G, $sanity_check_ary_ref) = &getCTSS_match_TS_oligo($bedStart, $bedEnd, $strand, $bam_seq, $check_TS_oligo_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_softclip_length, $max_softclip_length, $min_regex_match_pos, $max_regex_match_pos, $check_TS_oligo_regex, $min_match_length, $max_non_G_mismatch, $CB_UMI_offset);#->1062

			} elsif ($chosen_TSO_detection_mode eq 'trim') {
				($end5Start, $num_unencoded_G, $sanity_check_ary_ref) = &getCTSS_trim_TS_oligo($bedStart, $bedEnd, $strand, $bam_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_softclip_length, $max_softclip_length, $min_match_length, $max_non_G_mismatch, $TS_oligo_length, $CB_UMI_offset);#->1128
				
			} elsif ($chosen_TSO_detection_mode eq 'skip') {
				($end5Start, $num_unencoded_G, $sanity_check_ary_ref) = &getCTSS_skip_TS_oligo($bedStart, $bedEnd, $strand, $bam_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_match_length, $max_non_G_mismatch);#->1096

			} else {
				die "Quitting: chosen_TSO_detection_mode is not probalbly defined\n";
			}

			if ($sanity_check_toggle eq 'yes') {
				print SANITYCHECK join "", (join "\t", (@{$sanity_check_ary_ref})), "\n";
			}
			
			if (defined $end5Start) {
				my $end5End = $end5Start+1;
				if ($end5Start >= $chunk_startPos and $end5End <= $chunk_endPos) {
					if ($end5Start >= $margin and $end5End <= ($size - $margin)) {
						$chunk_passed_read_num++;
						print CTSSOUT join "", (join "\t", ($out_chrom, $end5Start, $end5End, $readname, $num_unencoded_G, $strand)), "\n";
					}
				}
			}
		}
	
		open (LOG, ">$chunk_log_path");
		print LOG "$chunk_passed_read_num\t$chunk_total_read_num\n";
		close LOG;
	
		close BAMIN;
		close CTSSOUT;
		close SANITYCHECK;

		system "sort -k1,1 -k2,2n -k6,6 $chunk_unsort_UMI_CB_ctss_bed_path >$chunk_UMI_CB_ctss_bed_path";
		system "rm $chunk_unsort_UMI_CB_ctss_bed_path";
		
	} else {
		&reportAndLogStatus("chunk_UMI_CB_ctss_bed_path found. Skipping conversion.", 10, "\n");#->1991
	}

	return ();
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|1783, reportAndLogStatus|1991
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|155, 5_finishingTasks|196
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 116, 1799, 1803, 1808, 1812, 2007, 2008
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub defineTSOCheckParam {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: getCTSS_match_TS_oligo|1062, getCTSS_skip_TS_oligo|1096, getCTSS_trim_TS_oligo|1128
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $bam_seq, $bedEnd, $bedStart
#	output: $TSO_match_valid, $TSS_within_chunk, $check_genome_seq, $check_read_pos, $check_read_seq, $end5Start, $match_length, $match_valid, $non_G_mismatch, $num_nt_extract_check, $num_unencoded_G, $overall_valid, $rd_seq, $readEnd, $readStart, $softclip_length, $softclip_valid, $trim_length
#	toCall: my ($rd_seq, $readStart, $readEnd, $end5Start, $num_nt_extract_check, $check_read_seq, $check_genome_seq, $check_read_pos, $trim_length, $num_unencoded_G, $non_G_mismatch, $softclip_valid, $match_valid, $TSS_within_chunk, $TSO_match_valid, $overall_valid, $softclip_length, $match_length) = &defineTSOCheckParam($bedStart, $bedEnd, $bam_seq);
#	calledInLine: 1075, 1112, 1141
#....................................................................................................................................................#
	my ($bedStart, $bedEnd, $bam_seq) = @_;

	my $end5Start = undef;
	my $num_nt_extract_check = 10;
	my $overall_valid = 'no';

	my $check_read_seq = '__na';
	my $check_genome_seq = '__na';
	my $check_read_pos = '__na';
	my $trim_length = '__na';
	my $num_unencoded_G = '__na';
	my $non_G_mismatch = '__na';
	my $softclip_valid = '__na';
	my $match_valid = '__na';
	my $TSS_within_chunk = '__na';
	my $TSO_match_valid = '__na';
	my $softclip_length = '__na';
	my $match_length = '__na';

	my ($readStart, $readEnd) = ($bedStart, $bedEnd);
	my $rd_seq = $bam_seq;

	return ($rd_seq, $readStart, $readEnd, $end5Start, $num_nt_extract_check, $check_read_seq, $check_genome_seq, $check_read_pos, $trim_length, $num_unencoded_G, $non_G_mismatch, $softclip_valid, $match_valid, $TSS_within_chunk, $TSO_match_valid, $overall_valid, $softclip_length, $match_length);
}
sub generateChromNameConversionHsh {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1991
#	appearInSub: >none
#	primaryAppearInSection: 4_convert|184
#	secondaryAppearInSection: >none
#	input: $bamPath, $chrom_name_path, $chrom_size_path, $samtools_bin
#	output: $chrom_name_size_hsh_ref, $out_chrom_size_hsh_ref
#	toCall: my ($chrom_name_size_hsh_ref, $out_chrom_size_hsh_ref) = &generateChromNameConversionHsh($chrom_name_path, $chrom_size_path, $samtools_bin, $bamPath);
#	calledInLine: 187
#....................................................................................................................................................#
	
	my ($chrom_name_path, $chrom_size_path, $samtools_bin, $bamPath) = @_;

	my $min_hit_read_pct = 10;
	&reportAndLogStatus("getting bam header chromosome", 10, "\n");#->1991
	my $actual_bam_chrom_name_hsh_ref = {};
	my $total_num_read = 0;
	open SAMTOOLS, "$samtools_bin idxstats $bamPath 2>/dev/null |";
	while (<SAMTOOLS>) {
		chomp;
		my ($actual_bam_chrom_name, $size, $num_read) = split /\t/;
		if ($actual_bam_chrom_name ne "*") {
			$actual_bam_chrom_name_hsh_ref->{$actual_bam_chrom_name} = $num_read;
			$total_num_read+=$num_read;
			&reportAndLogStatus("chrom $actual_bam_chrom_name found in bam with size $size and num_read $num_read", 10, "\n");#->1991
		}
	}
	close SAMTOOLS;

	my $chrom_name_size_hsh_ref = {};
	my $tmp_chrom_hsh_ref = {};
	my $out_chrom_size_hsh_ref = {};
	my $hit_num_read = 0;
	open (CHROMNAME, "<", $chrom_name_path);
	while (<CHROMNAME>) {
		chomp;
		my ($out_chrom, $bam_chrom_name) = split /\s+/;
		
		if (exists $actual_bam_chrom_name_hsh_ref->{$out_chrom}) {
			$bam_chrom_name = $out_chrom;
			$hit_num_read += $actual_bam_chrom_name_hsh_ref->{$out_chrom};
		} elsif (exists $actual_bam_chrom_name_hsh_ref->{$bam_chrom_name}) {
			$hit_num_read += $actual_bam_chrom_name_hsh_ref->{$bam_chrom_name};
		}
		
		$chrom_name_size_hsh_ref->{$bam_chrom_name}{'out_chrom'} = $out_chrom;
		$tmp_chrom_hsh_ref->{$out_chrom} = $bam_chrom_name;
	}
	close CHROMNAME;

	my $hit_read_pct = 100*($hit_num_read/$total_num_read);
	&reportAndLogStatus("$hit_read_pct % of read in bam is within chrom list scope", 10, "\n");#->1991
	if ($hit_read_pct < $min_hit_read_pct) {
		die "Quitting due to low % of read in bam is within chrom list scope.\n";
	}

	open (CHROMSIZE, "<", $chrom_size_path);
	while (<CHROMSIZE>) {
		chomp;
		my ($out_chrom, $size) = split /\s+/;
		my $bam_chrom_name = $tmp_chrom_hsh_ref->{$out_chrom};
		$chrom_name_size_hsh_ref->{$bam_chrom_name}{'size'} = $size;
		$out_chrom_size_hsh_ref->{$out_chrom} = $size;
	}
	close CHROMSIZE;

	return ($chrom_name_size_hsh_ref, $out_chrom_size_hsh_ref);
}
sub generateChunkInfoHsh {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1991
#	appearInSub: >none
#	primaryAppearInSection: 4_convert|184
#	secondaryAppearInSection: >none
#	input: $chrom_name_size_hsh_ref, $chunk_size, $result_tmp_dir
#	output: $chunk_info_hsh_ref
#	toCall: my ($chunk_info_hsh_ref) = &generateChunkInfoHsh($chrom_name_size_hsh_ref, $chunk_size, $result_tmp_dir);
#	calledInLine: 189
#....................................................................................................................................................#
	my ($chrom_name_size_hsh_ref, $chunk_size, $result_tmp_dir) = @_;
	
	my $chunk_num = 1;
	my $chunk_info_hsh_ref = {};
	foreach my $chrom (sort {$chrom_name_size_hsh_ref->{$a}{'out_chrom'} cmp $chrom_name_size_hsh_ref->{$b}{'out_chrom'}} keys %{$chrom_name_size_hsh_ref}) {
		my $size = $chrom_name_size_hsh_ref->{$chrom}{'size'};
		my $out_chrom = $chrom_name_size_hsh_ref->{$chrom}{'out_chrom'};
		foreach (my $startPos = 0; $startPos <= $size; $startPos += $chunk_size) {
			my $endPos = $startPos + $chunk_size;
			$endPos = $size if ($endPos > $size);
			my $file_tag = "$out_chrom.$startPos.$endPos";
			
			my $size_in_chunk = $endPos - $startPos;
			&reportAndLogStatus("chunk $chunk_num contains $size_in_chunk nt covering $out_chrom $startPos to $endPos", 10, "\n");#->1991

			my $chunk_CB_ctss_bed_path = "$result_tmp_dir/$file_tag.CB.ctss.bed";
			my $chunk_collapse_ctss_bed_path = "$result_tmp_dir/$file_tag.collapse.ctss.bed";
			my $chunk_ung_collapse_ctss_bed_path = "$result_tmp_dir/$file_tag.unencoded_G.collapse.ctss.bed";
			my $chunk_UMI_CB_ctss_bed_path = "$result_tmp_dir/$file_tag.UMI_CB.ctss.bed";
			my $chunk_unsort_UMI_CB_ctss_bed_path = "$result_tmp_dir/$file_tag.unsorted.UMI_CB.ctss.bed";
			my $chunk_log_path = "$result_tmp_dir/$file_tag.log.txt";
			my $chunk_fasta_path = "$result_tmp_dir/$file_tag.seq.fasta";
			my $chunk_sanity_check_path = "$result_tmp_dir/$file_tag.unencoded_G.sanity_check.txt";

			my ($chunk_chrom, $chunk_startPos, $chunk_endPos) = ($chrom, $startPos, $endPos);
			$chunk_info_hsh_ref->{$chunk_num}{'file_tag'} = $file_tag;
			$chunk_info_hsh_ref->{$chunk_num}{'loc'} = [$chunk_chrom, $chunk_startPos, $chunk_endPos];
			$chunk_info_hsh_ref->{$chunk_num}{'region_str'} = "$chunk_chrom:$chunk_startPos-$chunk_endPos";
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_ung_collapse_ctss_bed_path'} = $chunk_ung_collapse_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_unsort_UMI_CB_ctss_bed_path'} = $chunk_unsort_UMI_CB_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_UMI_CB_ctss_bed_path'} = $chunk_UMI_CB_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_CB_ctss_bed_path'} = $chunk_CB_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_collapse_ctss_bed_path'} = $chunk_collapse_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_log_path'} = $chunk_log_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_sanity_check_path'} = $chunk_sanity_check_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_fasta_path'} = $chunk_fasta_path;
			$chunk_num++;
		}
 	}

	return ($chunk_info_hsh_ref);
}
sub generateChunkSize {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_convert|184
#	secondaryAppearInSection: >none
#	input: $num_chunk, $out_chrom_size_hsh_ref
#	output: $chunk_size
#	toCall: my ($chunk_size) = &generateChunkSize($out_chrom_size_hsh_ref, $num_chunk);
#	calledInLine: 188
#....................................................................................................................................................#
	
	my ($out_chrom_size_hsh_ref, $num_chunk) = @_;
	
	my $total_size = 0;

	foreach my $out_chrom (keys %{$out_chrom_size_hsh_ref}) {
		$total_size += $out_chrom_size_hsh_ref->{$out_chrom};
	}
	
	my $chunk_size = int ($total_size/$num_chunk);
	
	return ($chunk_size);
}
sub generateMisMatchRegex {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: convertBamToCTSS|661
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $match_string, $max_mismatch
#	output: $regex_string
#	toCall: my ($regex_string) = &generateMisMatchRegex($match_string, $max_mismatch);
#	calledInLine: 716
#....................................................................................................................................................#
	my ($match_string, $max_mismatch) = @_;

	my @mismatch_3_ary;
	my @mismatch_2_ary;
	my @mismatch_1_ary;
	
	for my $i (0..length($match_string)-1) {
		my $mismatch_1_subpattern = join('',
			substr($match_string, 0, $i),
			'\\w',  # or '\\w'
			substr($match_string, $i+1),
		);
		push @mismatch_1_ary, $mismatch_1_subpattern;

		for my $j ($i+1..length($match_string)-1) {
			my $mismatch_2_subpattern = join('',
				substr($match_string, 0, $i),
				'\\w',  # or '\\w'
				substr($match_string, $i+1, $j-$i-1),
				'\\w',  # or '\\w'
				substr($match_string, $j+1),
			);
			push @mismatch_2_ary, $mismatch_2_subpattern;

			for my $k ($j+1..length($match_string)-1) {
				my $mismatch_3_subpattern = join('',
					substr($match_string, 0, $i),
					'\\w',  # or '\\w'
					substr($match_string, $i+1, $j-$i-1),
					'\\w',  # or '\\w'
					substr($match_string, $j+1, $k-$j-1),
					'\\w',  # or '\\w'
					substr($match_string, $k+1),
				);
				push @mismatch_3_ary, $mismatch_3_subpattern;
			}
		}
	}
	
	my $regex_string;
	if ($max_mismatch eq 0) {
		$regex_string = $match_string;
	} elsif ($max_mismatch eq 1) {
		$regex_string = join('|', @mismatch_1_ary);

	} elsif ($max_mismatch eq 2) {
		$regex_string = join('|', @mismatch_2_ary);

	} elsif ($max_mismatch eq 3) {
		$regex_string = join('|', @mismatch_3_ary);

	} else {
		die;
	}
	
	return ($regex_string);
}
sub getCTSS_match_TS_oligo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: defineTSOCheckParam|808, getCheckSeq|1157, getEnd5StartUnencodedG|1233, getSoftclipMatch|1289, getTSOMatchPosition|1367
#	appearInSub: convertBamToCTSS|661
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $CB_UMI_offset, $bam_seq, $bedEnd, $bedStart, $check_TS_oligo_regex, $check_TS_oligo_seq, $chunk_endPos, $chunk_fasta_offset_pos, $chunk_seq_str, $chunk_startPos, $cigar, $max_non_G_mismatch, $max_regex_match_pos, $max_softclip_length, $min_match_length, $min_regex_match_pos, $min_softclip_length, $out_chrom, $samtools_bin, $strand
#	output: $end5Start, $num_unencoded_G, $sanity_check_ary_ref
#	toCall: my ($end5Start, $num_unencoded_G, $sanity_check_ary_ref) = &getCTSS_match_TS_oligo($bedStart, $bedEnd, $strand, $bam_seq, $check_TS_oligo_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_softclip_length, $max_softclip_length, $min_regex_match_pos, $max_regex_match_pos, $check_TS_oligo_regex, $min_match_length, $max_non_G_mismatch, $CB_UMI_offset);
#	calledInLine: 745
#....................................................................................................................................................#
	my ($bedStart, $bedEnd, $strand, $bam_seq, $check_TS_oligo_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_softclip_length, $max_softclip_length, $min_regex_match_pos, $max_regex_match_pos, $check_TS_oligo_regex, $min_match_length, $max_non_G_mismatch, $CB_UMI_offset) = @_;
	
	my ($rd_seq, $readStart, $readEnd, $end5Start, $num_nt_extract_check, $check_read_seq, $check_genome_seq, $check_read_pos, $trim_length, $num_unencoded_G, $non_G_mismatch, $softclip_valid, $match_valid, $TSS_within_chunk, $TSO_match_valid, $overall_valid, $softclip_length, $match_length) = &defineTSOCheckParam($bedStart, $bedEnd, $bam_seq);#->808

	($rd_seq, $softclip_length, $match_length, $readStart, $readEnd, $TSS_within_chunk, $softclip_valid, $match_valid) = &getSoftclipMatch($cigar, $strand, $readStart, $readEnd, $chunk_startPos, $chunk_endPos, $TSS_within_chunk, $rd_seq, $softclip_length, $match_length, $softclip_valid, $match_valid, $min_softclip_length, $max_softclip_length, $min_match_length);#->1289

	if ($softclip_valid eq 'yes' and $match_valid eq 'yes' and $TSS_within_chunk eq 'yes') {
		
		my $match_end_rd_pos = undef;
		($match_end_rd_pos, $TSO_match_valid) = &getTSOMatchPosition($rd_seq, $check_TS_oligo_regex, $TSO_match_valid, $max_regex_match_pos, $min_regex_match_pos, $match_end_rd_pos, $CB_UMI_offset);#->1367

		if ($TSO_match_valid eq 'yes') {
			($check_genome_seq, $check_read_seq, $check_read_pos) = &getCheckSeq($match_end_rd_pos, $chunk_fasta_offset_pos, $readStart, $readEnd, $strand, $num_nt_extract_check, $chunk_seq_str, $rd_seq);#->1157
			($num_unencoded_G, $non_G_mismatch, $end5Start, $trim_length) = &getEnd5StartUnencodedG($match_end_rd_pos, $num_nt_extract_check, $check_read_seq, $check_genome_seq, $strand, $readStart, $readEnd, $max_non_G_mismatch, $trim_length);#->1233
		}
	}
	
	$overall_valid = 'yes' if defined $end5Start;
	my $sanity_check_ary_ref = [$out_chrom, $bedStart, $bedEnd, $strand, $rd_seq, $check_read_seq, $check_genome_seq, $cigar, $softclip_length, $match_length, $check_read_pos, $trim_length, $num_unencoded_G, $non_G_mismatch, $softclip_valid, $match_valid, $TSS_within_chunk, $TSO_match_valid, $overall_valid];

	return ($end5Start, $num_unencoded_G, $sanity_check_ary_ref);
}
sub getCTSS_skip_TS_oligo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: defineTSOCheckParam|808, getCheckSeq|1157, getEnd5StartUnencodedG|1233, getSoftclipMatch|1289
#	appearInSub: convertBamToCTSS|661
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $bam_seq, $bedEnd, $bedStart, $chunk_endPos, $chunk_fasta_offset_pos, $chunk_seq_str, $chunk_startPos, $cigar, $max_non_G_mismatch, $min_match_length, $out_chrom, $samtools_bin, $strand
#	output: $end5Start, $num_unencoded_G, $sanity_check_ary_ref
#	toCall: my ($end5Start, $num_unencoded_G, $sanity_check_ary_ref) = &getCTSS_skip_TS_oligo($bedStart, $bedEnd, $strand, $bam_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_match_length, $max_non_G_mismatch);
#	calledInLine: 751
#....................................................................................................................................................#
	my ($bedStart, $bedEnd, $strand, $bam_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_match_length, $max_non_G_mismatch) = @_;
	
	my $min_softclip_length = 0;
	my $max_softclip_length = 7;
	
	my ($rd_seq, $readStart, $readEnd, $end5Start, $num_nt_extract_check, $check_read_seq, $check_genome_seq, $check_read_pos, $trim_length, $num_unencoded_G, $non_G_mismatch, $softclip_valid, $match_valid, $TSS_within_chunk, $TSO_match_valid, $overall_valid, $softclip_length, $match_length) = &defineTSOCheckParam($bedStart, $bedEnd, $bam_seq);#->808

	($rd_seq, $softclip_length, $match_length, $readStart, $readEnd, $TSS_within_chunk, $softclip_valid, $match_valid) = &getSoftclipMatch($cigar, $strand, $readStart, $readEnd, $chunk_startPos, $chunk_endPos, $TSS_within_chunk, $rd_seq, $softclip_length, $match_length, $softclip_valid, $match_valid, $min_softclip_length, $max_softclip_length, $min_match_length);#->1289

	if ($softclip_valid eq 'yes' and $match_valid eq 'yes' and $TSS_within_chunk eq 'yes') {
		my $match_end_rd_pos = 0;
		($check_genome_seq, $check_read_seq, $check_read_pos) = &getCheckSeq($match_end_rd_pos, $chunk_fasta_offset_pos, $readStart, $readEnd, $strand, $num_nt_extract_check, $chunk_seq_str, $rd_seq);#->1157
		($num_unencoded_G, $non_G_mismatch, $end5Start, $trim_length) = &getEnd5StartUnencodedG($match_end_rd_pos, $num_nt_extract_check, $check_read_seq, $check_genome_seq, $strand, $readStart, $readEnd, $max_non_G_mismatch, $trim_length);#->1233
	}

	$overall_valid = 'yes' if defined $end5Start;
	my $sanity_check_ary_ref = [$out_chrom, $bedStart, $bedEnd, $strand, $rd_seq, $check_read_seq, $check_genome_seq, $cigar, $softclip_length, $match_length, $check_read_pos, $trim_length, $num_unencoded_G, $non_G_mismatch, $softclip_valid, $match_valid, $TSS_within_chunk, $TSO_match_valid, $overall_valid];
	
	return ($end5Start, $num_unencoded_G, $sanity_check_ary_ref);
}
sub getCTSS_trim_TS_oligo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: defineTSOCheckParam|808, getCheckSeq|1157, getEnd5StartUnencodedG|1233, getSoftclipMatch|1289
#	appearInSub: convertBamToCTSS|661
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $CB_UMI_offset, $TS_oligo_length, $bam_seq, $bedEnd, $bedStart, $chunk_endPos, $chunk_fasta_offset_pos, $chunk_seq_str, $chunk_startPos, $cigar, $max_non_G_mismatch, $max_softclip_length, $min_match_length, $min_softclip_length, $out_chrom, $samtools_bin, $strand
#	output: $end5Start, $num_unencoded_G, $sanity_check_ary_ref
#	toCall: my ($end5Start, $num_unencoded_G, $sanity_check_ary_ref) = &getCTSS_trim_TS_oligo($bedStart, $bedEnd, $strand, $bam_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_softclip_length, $max_softclip_length, $min_match_length, $max_non_G_mismatch, $TS_oligo_length, $CB_UMI_offset);
#	calledInLine: 748
#....................................................................................................................................................#
	my ($bedStart, $bedEnd, $strand, $bam_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_softclip_length, $max_softclip_length, $min_match_length, $max_non_G_mismatch, $TS_oligo_length, $CB_UMI_offset) = @_;
	
	my ($rd_seq, $readStart, $readEnd, $end5Start, $num_nt_extract_check, $check_read_seq, $check_genome_seq, $check_read_pos, $trim_length, $num_unencoded_G, $non_G_mismatch, $softclip_valid, $match_valid, $TSS_within_chunk, $TSO_match_valid, $overall_valid, $softclip_length, $match_length) = &defineTSOCheckParam($bedStart, $bedEnd, $bam_seq);#->808

	($rd_seq, $softclip_length, $match_length, $readStart, $readEnd, $TSS_within_chunk, $softclip_valid, $match_valid) = &getSoftclipMatch($cigar, $strand, $readStart, $readEnd, $chunk_startPos, $chunk_endPos, $TSS_within_chunk, $rd_seq, $softclip_length, $match_length, $softclip_valid, $match_valid, $min_softclip_length, $max_softclip_length, $min_match_length);#->1289

	if ($softclip_valid eq 'yes' and $match_valid eq 'yes' and $TSS_within_chunk eq 'yes') {
		my $match_end_rd_pos = $TS_oligo_length + $CB_UMI_offset;
		($check_genome_seq, $check_read_seq, $check_read_pos) = &getCheckSeq($match_end_rd_pos, $chunk_fasta_offset_pos, $readStart, $readEnd, $strand, $num_nt_extract_check, $chunk_seq_str, $rd_seq);#->1157
		($num_unencoded_G, $non_G_mismatch, $end5Start, $trim_length) = &getEnd5StartUnencodedG($match_end_rd_pos, $num_nt_extract_check, $check_read_seq, $check_genome_seq, $strand, $readStart, $readEnd, $max_non_G_mismatch, $trim_length);#->1233
	}

	$overall_valid = 'yes' if defined $end5Start;
	my $sanity_check_ary_ref = [$out_chrom, $bedStart, $bedEnd, $strand, $rd_seq, $check_read_seq, $check_genome_seq, $cigar, $softclip_length, $match_length, $check_read_pos, $trim_length, $num_unencoded_G, $non_G_mismatch, $softclip_valid, $match_valid, $TSS_within_chunk, $TSO_match_valid, $overall_valid];
	
	return ($end5Start, $num_unencoded_G, $sanity_check_ary_ref);
}
sub getCheckSeq {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: getCTSS_match_TS_oligo|1062, getCTSS_skip_TS_oligo|1096, getCTSS_trim_TS_oligo|1128
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $chunk_fasta_offset_pos, $chunk_seq_str, $match_end_rd_pos, $num_nt_extract_check, $rd_seq, $readEnd, $readStart, $strand
#	output: $check_genome_seq, $check_read_pos, $check_read_seq
#	toCall: my ($check_genome_seq, $check_read_seq, $check_read_pos) = &getCheckSeq($match_end_rd_pos, $chunk_fasta_offset_pos, $readStart, $readEnd, $strand, $num_nt_extract_check, $chunk_seq_str, $rd_seq);
#	calledInLine: 1085, 1118, 1147
#....................................................................................................................................................#
	my ($match_end_rd_pos, $chunk_fasta_offset_pos, $readStart, $readEnd, $strand, $num_nt_extract_check, $chunk_seq_str, $rd_seq) = @_;
	
	my $check_genome_seq;
	my $check_read_seq;
	my $check_read_pos;
	
	#---take 10nt for checking
	if ($strand eq '+') {

		my $check_genome_pos_start = $readStart + $match_end_rd_pos - $chunk_fasta_offset_pos + 1;
		$check_genome_seq = substr ($chunk_seq_str, $check_genome_pos_start, $num_nt_extract_check);

	} else {
		my $check_genome_pos_end = $readEnd - $match_end_rd_pos - $chunk_fasta_offset_pos;
		my $check_genome_pos_start = $check_genome_pos_end - $num_nt_extract_check + 1;

		$check_genome_seq = substr ($chunk_seq_str, $check_genome_pos_start, $num_nt_extract_check);
		$check_genome_seq = reverse($check_genome_seq);
		$check_genome_seq =~ tr/ATGC/TACG/;
	}

	$check_read_pos = $match_end_rd_pos;
	$check_read_seq = substr $rd_seq, $check_read_pos, $num_nt_extract_check;
	
	return ($check_genome_seq, $check_read_seq, $check_read_pos);
}
sub getChunkFasta {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1991
#	appearInSub: processPerChunk|1817
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 4_convert|184
#	input: $chunk_endPos, $chunk_fasta_path, $chunk_startPos, $genome_fasta_path, $out_chrom, $samtools_bin, $size
#	output: $chunk_fasta_offset_pos, $chunk_seq_str
#	toCall: my ($chunk_seq_str, $chunk_fasta_offset_pos) = &getChunkFasta($chunk_fasta_path, $out_chrom, $chunk_startPos, $chunk_endPos, $genome_fasta_path, $size, $samtools_bin);
#	calledInLine: 1874
#....................................................................................................................................................#
	my ($chunk_fasta_path, $out_chrom, $chunk_startPos, $chunk_endPos, $genome_fasta_path, $size, $samtools_bin) = @_;
	
	&reportAndLogStatus("Extracting chunk fasta", 10, "\n");#->1991
	
	my $fasta_start_pos = $chunk_startPos - 500;
	$fasta_start_pos = 1 if $fasta_start_pos < 1;
	
	my $fasta_end_pos = $chunk_endPos + 500;
	$fasta_end_pos = $size if $fasta_end_pos > $size;

	my $chunk_fasta_name = "$out_chrom:$fasta_start_pos-$fasta_end_pos";
	system ("$samtools_bin faidx $genome_fasta_path $chunk_fasta_name >$chunk_fasta_path");
	my $chunk_seq_str = '';
	
	open CHUNKFASTA, "<", $chunk_fasta_path;
	<CHUNKFASTA>;
	while (<CHUNKFASTA>) {
		chomp;
		$chunk_seq_str = $chunk_seq_str.$_;
	}
	close CHUNKFASTA;
	$chunk_seq_str = uc $chunk_seq_str;
	my $chunk_fasta_offset_pos = $fasta_start_pos;

	return ($chunk_seq_str, $chunk_fasta_offset_pos);
}
sub getEnd5StartUnencodedG {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: getCTSS_match_TS_oligo|1062, getCTSS_skip_TS_oligo|1096, getCTSS_trim_TS_oligo|1128
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $check_genome_seq, $check_read_seq, $match_end_rd_pos, $max_non_G_mismatch, $num_nt_extract_check, $readEnd, $readStart, $strand, $trim_length
#	output: $end5Start, $non_G_mismatch, $num_unencoded_G, $trim_length
#	toCall: my ($num_unencoded_G, $non_G_mismatch, $end5Start, $trim_length) = &getEnd5StartUnencodedG($match_end_rd_pos, $num_nt_extract_check, $check_read_seq, $check_genome_seq, $strand, $readStart, $readEnd, $max_non_G_mismatch, $trim_length);
#	calledInLine: 1086, 1119, 1148
#....................................................................................................................................................#
	my ($match_end_rd_pos, $num_nt_extract_check, $check_read_seq, $check_genome_seq, $strand, $readStart, $readEnd, $max_non_G_mismatch, $trim_length) = @_;

	$trim_length = $match_end_rd_pos;
	my $num_unencoded_G = 0;
	my $non_G_mismatch = 0;
	my $matched = 'no';
	my $end5Start = undef;
	
	foreach my $shift_pos (0..$num_nt_extract_check) {
		my $read_nt = substr($check_read_seq, $shift_pos, 1);
		my $genome_nt = substr($check_genome_seq, $shift_pos, 1);
		
		die "Quitting: genome_nt error\n" if (not defined $genome_nt);
		
		if ($read_nt ne $genome_nt) {
			if ($read_nt eq 'G') {
				$num_unencoded_G++;
			} else {
				$non_G_mismatch++;
			};
			$trim_length++;
			last if $non_G_mismatch > $max_non_G_mismatch;
		} else {
			$matched = 'yes';
			last;
		}
	}
	
	if ($matched eq 'yes') {
		if ($strand eq '+') {
			$end5Start = $readStart + $trim_length;

		} elsif ($strand eq '-') {
			$end5Start = $readEnd - $trim_length - 1;
	
		} else {
			die "strand=$strand, must be + or -\n";
		}
	
		$end5Start = 0 if $end5Start < 0;
	}
	
	return ($num_unencoded_G, $non_G_mismatch, $end5Start, $trim_length);
}
sub getSoftclipMatch {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: getCTSS_match_TS_oligo|1062, getCTSS_skip_TS_oligo|1096, getCTSS_trim_TS_oligo|1128
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $TSS_within_chunk, $chunk_endPos, $chunk_startPos, $cigar, $match_length, $match_valid, $max_softclip_length, $min_match_length, $min_softclip_length, $rd_seq, $readEnd, $readStart, $softclip_length, $softclip_valid, $strand
#	output: $TSS_within_chunk, $match_length, $match_valid, $rd_seq, $readEnd, $readStart, $softclip_length, $softclip_valid
#	toCall: my ($rd_seq, $softclip_length, $match_length, $readStart, $readEnd, $TSS_within_chunk, $softclip_valid, $match_valid) = &getSoftclipMatch($cigar, $strand, $readStart, $readEnd, $chunk_startPos, $chunk_endPos, $TSS_within_chunk, $rd_seq, $softclip_length, $match_length, $softclip_valid, $match_valid, $min_softclip_length, $max_softclip_length, $min_match_length);
#	calledInLine: 1077, 1114, 1143
#....................................................................................................................................................#
	my ($cigar, $strand, $readStart, $readEnd, $chunk_startPos, $chunk_endPos, $TSS_within_chunk, $rd_seq, $softclip_length, $match_length, $softclip_valid, $match_valid, $min_softclip_length, $max_softclip_length, $min_match_length) = @_;

	$softclip_valid = 'no';
	$match_valid = 'no';
	$TSS_within_chunk = 'no';
	$softclip_length = 0;
	$match_length = 0;
	
	if ($strand eq '+') {
		if ($cigar =~ m/^(\d+)S(\d+)M/) {
			$softclip_length = $1;
			$match_length = $2;
			$readStart -= $softclip_length;
		} elsif ($cigar =~ m/^(\d+)M/) {
			$match_length = $1;
		}
		$TSS_within_chunk = 'yes' if $readStart >= $chunk_startPos;
	} else {
		$rd_seq = reverse $rd_seq;
		$rd_seq =~ tr/ATGCatgc/TACGtacg/;
		if ($cigar =~ m/(\d+)M(\d+)S$/) {
			$softclip_length = $2;
			$match_length = $1;
			$readEnd += $softclip_length;
		} elsif ($cigar =~ m/(\d+)M$/) {
			$match_length = $1;
		}
		$TSS_within_chunk = 'yes' if $readEnd <= $chunk_endPos;
	}

	$softclip_valid = 'yes' if ($softclip_length >= $min_softclip_length and $softclip_length <= $max_softclip_length);
	$match_valid = 'yes' if ($match_length >= $min_match_length);

	return ($rd_seq, $softclip_length, $match_length, $readStart, $readEnd, $TSS_within_chunk, $softclip_valid, $match_valid);
}
sub getSubsampleFraction {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1991
#	appearInSub: chooseTSODetectionMode|616
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_checkTSO|176
#	input: $bamPath, $min_frac_subsample, $num_subsample, $samtools_bin
#	output: $frac_subsample
#	toCall: my ($frac_subsample) = &getSubsampleFraction($min_frac_subsample, $num_subsample, $samtools_bin, $bamPath);
#	calledInLine: 634
#....................................................................................................................................................#
	my ($min_frac_subsample, $num_subsample, $samtools_bin, $bamPath) = @_;
	
	&reportAndLogStatus("Determining subsampe fraction", 10, "\n");#->1991
	open SAMTOOLS, "$samtools_bin idxstats $bamPath 2>/dev/null|";
	my $total_num_read = 0;
	while (<SAMTOOLS>) {
		chomp;
		my ($chrom, $size, $num_read) = split /\t/;
		$total_num_read += $num_read;
	}
	close SAMTOOLS;
	my $frac_subsample = $num_subsample/$total_num_read;
	$frac_subsample = 1 if $frac_subsample > 1;
	$frac_subsample = $min_frac_subsample if $frac_subsample < $min_frac_subsample;
	&reportAndLogStatus("total_num_read=$total_num_read. targeting $num_subsample read.", 10, "\n");#->1991
	&reportAndLogStatus("frac_subsample is set as $frac_subsample", 10, "\n");#->1991
	
	return ($frac_subsample);
}
sub getTSOMatchPosition {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: getCTSS_match_TS_oligo|1062
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $CB_UMI_offset, $TSO_match_valid, $check_TS_oligo_regex, $match_end_rd_pos, $max_regex_match_pos, $min_regex_match_pos, $rd_seq
#	output: $TSO_match_valid, $match_end_rd_pos
#	toCall: my ($match_end_rd_pos, $TSO_match_valid) = &getTSOMatchPosition($rd_seq, $check_TS_oligo_regex, $TSO_match_valid, $max_regex_match_pos, $min_regex_match_pos, $match_end_rd_pos, $CB_UMI_offset);
#	calledInLine: 1082
#....................................................................................................................................................#
	my ($rd_seq, $check_TS_oligo_regex, $TSO_match_valid, $max_regex_match_pos, $min_regex_match_pos, $match_end_rd_pos, $CB_UMI_offset) = @_;
	
	$TSO_match_valid = 'no';
	my $trim_rd_seq_match = substr $rd_seq, $CB_UMI_offset, $max_regex_match_pos;
	if ($trim_rd_seq_match =~ /$check_TS_oligo_regex/g) {
		$match_end_rd_pos = $+[0] + $CB_UMI_offset;
		if ($match_end_rd_pos <= $max_regex_match_pos and $match_end_rd_pos >= $min_regex_match_pos) {#---valid only if the TSO is within the TS_oligo_check_range
			$TSO_match_valid = 'yes';
		}
	}

	return ($match_end_rd_pos, $TSO_match_valid);
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|155
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 168
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub pileupCBDedupUMI {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1991
#	appearInSub: processPerChunk|1817
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 4_convert|184
#	input: $chunk_CB_ctss_bed_path, $chunk_UMI_CB_ctss_bed_path, $chunk_collapse_ctss_bed_path, $chunk_num, $chunk_ung_collapse_ctss_bed_path
#	output: 
#	toCall: &pileupCBDedupUMI($chunk_UMI_CB_ctss_bed_path, $chunk_CB_ctss_bed_path, $chunk_collapse_ctss_bed_path, $chunk_ung_collapse_ctss_bed_path, $chunk_num);
#	calledInLine: 1876
#....................................................................................................................................................#
	my ($chunk_UMI_CB_ctss_bed_path, $chunk_CB_ctss_bed_path, $chunk_collapse_ctss_bed_path, $chunk_ung_collapse_ctss_bed_path, $chunk_num) = @_;

	#&reportAndLogStatus("deduplicating umi at ctss", 10, "\n");#->1991
	my $num_proc = 0;
	my $tmp_CTSS_hsh_ref = {};
	my $last_chrom = 'initial';
	my $last_start = 'initial';
	my $last_strand = 'initial';
	open INCTSS, "<", $chunk_UMI_CB_ctss_bed_path;
	open OUTCTSS, ">", $chunk_CB_ctss_bed_path;
	open OUTCBCOLLAPSECTSS, ">", $chunk_collapse_ctss_bed_path;
	open UNGOUTCBCOLLAPSECTSS, ">", $chunk_ung_collapse_ctss_bed_path;
	while (<INCTSS>) {
		chomp;
		my ($chrom, $start, $end, $ID, $num_unencoded_G, $strand) = split /\t/;
		{
			my ($CB, $UMI) = split /_/, $ID;
			$tmp_CTSS_hsh_ref->{$chrom}{$start}{$strand}{$CB}{'all'}{$UMI}++;
			$tmp_CTSS_hsh_ref->{$chrom}{$start}{$strand}{$CB}{'ung'}{$UMI}++ if $num_unencoded_G > 0;
		}
	
		if ($last_chrom eq 'initial') {
			$last_chrom = $chrom;
			$last_start = $start;
			$last_strand = $strand;
		}
		if (($chrom ne $last_chrom or $start ne $last_start or $strand ne $last_strand)) {
			my $last_end = $last_start + 1;
			my $CB_collapse_num_umi = 0;
			my $num_CB = 0;

			my $ung_CB_collapse_num_umi = 0;
			my $ung_num_CB = 0;

			foreach my $CB (sort keys %{$tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand}}) {
				my $num_umi = keys %{$tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand}{$CB}{'all'}};
				$CB_collapse_num_umi += $num_umi;
				$num_CB++;
				print OUTCTSS join "", (join "\t", ($last_chrom, $last_start, $last_end, $CB, $num_umi, $last_strand)), "\n";

				if (exists $tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand}{$CB}{'ung'}) {
					my $ung_num_umi = keys %{$tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand}{$CB}{'ung'}};
					$ung_CB_collapse_num_umi += $ung_num_umi;
					$ung_num_CB++;
				}
			}
			print OUTCBCOLLAPSECTSS join "", (join "\t", ($last_chrom, $last_start, $last_end, $num_CB, $CB_collapse_num_umi, $last_strand)), "\n";
			
			if ($ung_CB_collapse_num_umi > 0) {
				print UNGOUTCBCOLLAPSECTSS join "", (join "\t", ($last_chrom, $last_start, $last_end, $ung_num_CB, $ung_CB_collapse_num_umi, $last_strand)), "\n";
			}
			
			delete $tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand};
			$last_chrom = $chrom;
			$last_start = $start;
			$last_strand = $strand;
			$num_proc++;
			if ($num_proc%10000 == 0) {
				&reportAndLogStatus("$num_proc CTSS deduplicated for chunk $chunk_num", 10, "\n");#->1991
			}
		}
	
		if (eof(INCTSS)) {
			foreach my $chrom (keys %{$tmp_CTSS_hsh_ref}) {
				foreach my $start (keys %{$tmp_CTSS_hsh_ref->{$chrom}}) {
					my $end = $start + 1;
					foreach my $strand (keys %{$tmp_CTSS_hsh_ref->{$chrom}{$start}}) {
						my $CB_collapse_num_umi = 0;
						my $num_CB = 0;

						my $ung_CB_collapse_num_umi = 0;
						my $ung_num_CB = 0;

						foreach my $CB (sort keys  %{$tmp_CTSS_hsh_ref->{$chrom}{$start}{$strand}}) {
							my $num_umi = keys %{$tmp_CTSS_hsh_ref->{$chrom}{$start}{$strand}{$CB}{'all'}};
							$CB_collapse_num_umi += $num_umi;
							$num_CB++;
							print OUTCTSS join "", (join "\t", ($chrom, $start, $end, $CB, $num_umi, $strand)), "\n";

							if (exists $tmp_CTSS_hsh_ref->{$chrom}{$start}{$strand}{$CB}{'ung'}) {
								my $ung_num_umi = keys %{$tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand}{$CB}{'ung'}};
								$ung_CB_collapse_num_umi += $ung_num_umi;
								$ung_num_CB++;
							}

						}
						print OUTCBCOLLAPSECTSS join "", (join "\t", ($chrom, $start, $end, "$num_CB", $CB_collapse_num_umi, $strand)), "\n";

						if ($ung_CB_collapse_num_umi > 0) {
							print UNGOUTCBCOLLAPSECTSS join "", (join "\t", ($chrom, $start, $end, "$ung_num_CB", $ung_CB_collapse_num_umi, $strand)), "\n";
						}
					}
				}
			}
		}
	}
	close INCTSS;
	close OUTCTSS;
	close OUTCBCOLLAPSECTSS;
	close UNGOUTCBCOLLAPSECTSS;

	return ();
}
sub poolChunkResults {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: checkChunkResults|471, reportAndLogStatus|1991
#	appearInSub: >none
#	primaryAppearInSection: 4_convert|184
#	secondaryAppearInSection: >none
#	input: $bgzip_bin, $chunk_info_hsh_ref, $max_thread, $paramTag, $result_bed_dir, $result_log_dir, $result_tmp_dir, $rm_tmp_file, $tabix_bin
#	output: 
#	toCall: &poolChunkResults($tabix_bin, $bgzip_bin, $max_thread, $chunk_info_hsh_ref, $result_bed_dir, $result_log_dir, $paramTag, $result_tmp_dir, $rm_tmp_file);
#	calledInLine: 191
#....................................................................................................................................................#
	my ($tabix_bin, $bgzip_bin, $max_thread, $chunk_info_hsh_ref, $result_bed_dir, $result_log_dir, $paramTag, $result_tmp_dir, $rm_tmp_file) = @_;
	
	my $CB_ctss_bed_path = "$result_bed_dir/$paramTag.CB.ctss.bed";
	my $ung_collapse_ctss_bed_path = "$result_bed_dir/$paramTag.unencoded_G.collapse.ctss.bed";
	my $collapse_ctss_bed_path = "$result_bed_dir/$paramTag.collapse.ctss.bed";
	my $UMI_CB_ctss_bed_path = "$result_bed_dir/$paramTag.UMI_CB.ctss.bed";
	my $log_path = "$result_log_dir/$paramTag.read_count.txt";
	my $sanity_check_path = "$result_tmp_dir/$paramTag.unencoded_G.sanity_check.txt";
	open SANITYCHECK, ">", $sanity_check_path;
	print SANITYCHECK join "", (join "\t", ('out_chrom', 'bedStart', 'bedEnd', 'strand', 'rd_seq', 'check_read_seq', 'check_genome_seq', 'cigar', 'softclip_length', 'match_length', 'check_read_pos', 'trim_length', 'num_unencoded_G', 'non_G_mismatch', 'softclip_valid', 'match_valid', 'TSS_within_chunk', 'TSO_match_valid', 'overall_valid')), "\n";

	my $total_read_num = 0;
	my $passed_read_num = 0;
	my $num_sanity_print = 1000;
	
	open UMICBCTSS, ">$UMI_CB_ctss_bed_path";
	open CBCTSS, ">$CB_ctss_bed_path";
	open COLLAPSECTSS, ">$collapse_ctss_bed_path";
	open UNGCOLLAPSECTSS, ">$ung_collapse_ctss_bed_path";
	
	foreach my $chunk_num (sort {$a <=> $b} keys %{$chunk_info_hsh_ref}) {
		my $file_check_ary_ref = [qw/chunk_UMI_CB_ctss_bed_path chunk_CB_ctss_bed_path chunk_collapse_ctss_bed_path/];
		my ($valid) = &checkChunkResults($chunk_info_hsh_ref, $chunk_num, $file_check_ary_ref);#->471

		if ($valid eq 'yes') {
			&reportAndLogStatus("results of chunk $chunk_num is found. start parsing.", 10, "\n");#->1991
			my $chunk_UMI_CB_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_UMI_CB_ctss_bed_path'};
			my $chunk_CB_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_CB_ctss_bed_path'};
			my $chunk_collapse_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_collapse_ctss_bed_path'};
			my $chunk_ung_collapse_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_ung_collapse_ctss_bed_path'};
			my $chunk_log_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_log_path'};
			my $chunk_sanity_check_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_sanity_check_path'};
			my $chunk_fasta_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_fasta_path'};
			
			my $num_sanity_check = 0;
			open (CHUNKSANITYCHECK, "<", $chunk_sanity_check_path);
			<CHUNKSANITYCHECK>;
			while (<CHUNKSANITYCHECK>) {
				print SANITYCHECK $_;
				$num_sanity_check++;
				last if $num_sanity_check >= $num_sanity_print;
			}
			close CHUNKSANITYCHECK;

			open (CHUNKUMICB, "<", $chunk_UMI_CB_ctss_bed_path);
			while (<CHUNKUMICB>) {
				print UMICBCTSS $_;
			}
			close CHUNKUMICB;

			open (CHUNKCB, "<", $chunk_CB_ctss_bed_path);
			while (<CHUNKCB>) {
				print CBCTSS $_;
			}
			close CHUNKCB;

			open (UNGCHUNKCOLLAPSE, "<", $chunk_ung_collapse_ctss_bed_path);
			while (<UNGCHUNKCOLLAPSE>) {
				print UNGCOLLAPSECTSS $_;
			}
			close UNGCHUNKCOLLAPSE;

			open (CHUNKCOLLAPSE, "<", $chunk_collapse_ctss_bed_path);
			while (<CHUNKCOLLAPSE>) {
				print COLLAPSECTSS $_;
			}
			close CHUNKCOLLAPSE;
		
			open (CHUNKLOG, "<", $chunk_log_path);
			while (<CHUNKLOG>) {
				chomp;
				my ($chunk_passed_read_num, $chunk_total_read_num) = split /\t/;
				$total_read_num += $chunk_total_read_num;
				$passed_read_num += $chunk_passed_read_num;
			}
			close CHUNKLOG;

			if ($rm_tmp_file eq 'yes') {
				system ("rm $chunk_UMI_CB_ctss_bed_path");
				system ("rm $chunk_CB_ctss_bed_path");
				system ("rm $chunk_collapse_ctss_bed_path");
				system ("rm $chunk_ung_collapse_ctss_bed_path");
				system ("rm $chunk_log_path");
				system ("rm $chunk_fasta_path");
				system ("rm $chunk_sanity_check_path");
			}
		} else {
			die "results of chunk $chunk_num is not found. quitting\n";
		}
	}
	
	my $ctss_hsh_ref = {
		'UMI_CB_ctss_bed_path' => $UMI_CB_ctss_bed_path,
		'CB_ctss_bed_path' => $CB_ctss_bed_path,
		'collapse_ctss_bed_path' => $collapse_ctss_bed_path,
		'ung_collapse_ctss_bed_path' => $ung_collapse_ctss_bed_path,
	};
	
	foreach my $ctss_name (sort keys %{$ctss_hsh_ref}) {
		my $ctss_path = $ctss_hsh_ref->{$ctss_name};
		my $tabix_ctss_path = "$ctss_path.gz";
		&reportAndLogStatus("Compressing $ctss_name.", 10, "\n");#->1991
		system "$bgzip_bin -@ $max_thread -c $ctss_path >$tabix_ctss_path";
		system "rm -f $ctss_path";
		&reportAndLogStatus("Tabix indexing $ctss_name.", 10, "\n");#->1991
		system "$tabix_bin -p bed $tabix_ctss_path";
	}

	my $passed_read_pct = sprintf "%.2f", 100*($passed_read_num/$total_read_num);
	open ALLLOG, ">", $log_path;
	print ALLLOG join "", (join "\t", ('total_read_num', 'passed_read_num', 'passed_read_pct')), "\n";
	print ALLLOG join "", (join "\t", ($total_read_num, $passed_read_num, $passed_read_pct)), "\n";
	close ALLLOG;
	close SANITYCHECK;
	close COLLAPSECTSS;
	close UNGCOLLAPSECTSS;
	close CBCTSS;
	close UMICBCTSS;
	
	&reportAndLogStatus("total_read_num=$total_read_num", 10, "\n");#->1991
	&reportAndLogStatus("passed_read_num=$passed_read_num", 10, "\n");#->1991
	&reportAndLogStatus("passed_read_pct=$passed_read_pct%", 10, "\n");#->1991
	
	return ();
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 5_finishingTasks|196
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 199
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort {$a cmp $b} keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			my $headerColLen = max(@colLenCountHsh)+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}

	my $fileDir_colLen = max(@{$filelistLenCountHsh{'dir'}})+2;
	my $fileName_colLen = max(@{$filelistLenCountHsh{'name'}})+2;
	my $fileDescription_colLen = max(@{$filelistLenCountHsh{'description'}})+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|790
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|155, 5_finishingTasks|196
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 169, 200
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->790
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->790
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->790
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->790
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub processPerChunk {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: checkChunkResults|471, convertBamToCTSS|661, getChunkFasta|1195, pileupCBDedupUMI|1417, reportAndLogStatus|1991
#	appearInSub: >none
#	primaryAppearInSection: 4_convert|184
#	secondaryAppearInSection: >none
#	input: $CB_UMI_offset, $TS_oligo_check_tail_length, $TS_oligo_seq, $bamPath, $bedtools_bin, $chosen_TSO_detection_mode, $chrom_name_size_hsh_ref, $chunk_info_hsh_ref, $exclude_flag, $genome_fasta_path, $include_flag, $max_mismatch, $max_non_G_mismatch, $max_thread, $min_MAPQ, $min_match_length, $out_chrom_size_hsh_ref, $regex_match_margin, $samtools_bin, $sanity_check_toggle, $softclip_margin
#	output: 
#	toCall: &processPerChunk($bamPath, $bedtools_bin, $samtools_bin, $max_thread, $chunk_info_hsh_ref, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $min_MAPQ, $TS_oligo_seq, $genome_fasta_path, $out_chrom_size_hsh_ref, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch, $chosen_TSO_detection_mode, $CB_UMI_offset);
#	calledInLine: 190
#....................................................................................................................................................#
	my ($bamPath, $bedtools_bin, $samtools_bin, $max_thread, $chunk_info_hsh_ref, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $min_MAPQ, $TS_oligo_seq, $genome_fasta_path, $out_chrom_size_hsh_ref, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch, $chosen_TSO_detection_mode, $CB_UMI_offset) = @_;

	my %itemForThrHsh = ();
	my $threadID = 1;
	my $chrom_info_hsh_ref = {};
	my $total_num_chunk = keys %{$chunk_info_hsh_ref};
	foreach my $chunk_num (keys %{$chunk_info_hsh_ref}) {
		$threadID = 1 if $threadID > $max_thread;
		$itemForThrHsh{$threadID}{$chunk_num}++;
		$threadID++;
	}
	my $chunk_proc : shared = 0;
	my %threadHsh =();
	foreach my $threadID (sort {$a <=> $b} keys %itemForThrHsh) {
		my $itemForThrHsh_ref = $itemForThrHsh{$threadID};
		($threadHsh{$threadID}) = threads->new(#---refer to http://www.perlmonks.org/?node_id=966781, the 
	
			sub {
				
				my ($itemForThrHsh_ref) = @_;
				my $total_chunk = keys %{$itemForThrHsh_ref};
				
				&reportAndLogStatus("$total_chunk chunks spawned to thread $threadID.", 10, "\n");#->1991
				foreach my $chunk_num (keys %{$itemForThrHsh_ref}) {
					
					my $file_check_ary_ref = [qw/chunk_UMI_CB_ctss_bed_path chunk_CB_ctss_bed_path chunk_collapse_ctss_bed_path/];
					my ($valid) = &checkChunkResults($chunk_info_hsh_ref, $chunk_num, $file_check_ary_ref);#->471

					if ($valid eq 'yes') {
						&reportAndLogStatus("results of chunk $chunk_num is found. skipping", 10, "\n");#->1991

					} else {
						&reportAndLogStatus("start processing chunk $chunk_num in thread $threadID.", 10, "\n");#->1991
						my $region_str = $chunk_info_hsh_ref->{$chunk_num}{'region_str'};
						my $chunk_unsort_UMI_CB_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_unsort_UMI_CB_ctss_bed_path'};
						my $chunk_UMI_CB_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_UMI_CB_ctss_bed_path'};
						my $chunk_CB_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_CB_ctss_bed_path'};
						my $chunk_collapse_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_collapse_ctss_bed_path'};
						my $chunk_ung_collapse_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_ung_collapse_ctss_bed_path'};
						my $chunk_log_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_log_path'};
						my $chunk_sanity_check_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_sanity_check_path'};
						my $chunk_fasta_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_fasta_path'};
						my ($chunk_chrom, $chunk_startPos, $chunk_endPos) = @{$chunk_info_hsh_ref->{$chunk_num}{'loc'}};
						my $out_chrom = $chrom_name_size_hsh_ref->{$chunk_chrom}{'out_chrom'};
						my $size = $out_chrom_size_hsh_ref->{$out_chrom};
						
						my ($chunk_seq_str, $chunk_fasta_offset_pos) = &getChunkFasta($chunk_fasta_path, $out_chrom, $chunk_startPos, $chunk_endPos, $genome_fasta_path, $size, $samtools_bin);#->1195
						&convertBamToCTSS($bamPath, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $bedtools_bin, $samtools_bin, $min_MAPQ, $chunk_UMI_CB_ctss_bed_path, $chunk_unsort_UMI_CB_ctss_bed_path, $region_str, $chunk_log_path, $chunk_startPos, $chunk_endPos, $TS_oligo_seq, $chunk_fasta_path, $chunk_seq_str, $chunk_fasta_offset_pos, $chunk_sanity_check_path, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch, $chosen_TSO_detection_mode, $CB_UMI_offset);#->661
						&pileupCBDedupUMI($chunk_UMI_CB_ctss_bed_path, $chunk_CB_ctss_bed_path, $chunk_collapse_ctss_bed_path, $chunk_ung_collapse_ctss_bed_path, $chunk_num);#->1417
					}
					$chunk_proc++;
					&reportAndLogStatus("$chunk_proc of $total_num_chunk chunks are finised.", 10, "\n");#->1991
				}
				return ();
			}
			,($itemForThrHsh_ref)
		);
	}
	
	while (keys %threadHsh) {

		my @threads = threads->list();
		my $thread_count = threads->list();
		my @running = threads->list(threads::running);
		my @joinable = threads->list(threads::joinable);
		my $running_count = @running;
		my $joinable_count = @joinable;

		&reportAndLogStatus("$thread_count threads exists. $running_count running and $joinable_count joinable.", 10, "\n");#->1991

		foreach my $threadID (keys %threadHsh) {
			if (not $threadHsh{$threadID}->is_running() or $threadHsh{$threadID}->is_joinable() or $threadHsh{$threadID}->is_detached()) {
				&reportAndLogStatus("thread $threadID is finishing.", 10, "\n");#->1991
				$threadHsh{$threadID}->join();
				delete $threadHsh{$threadID};
			}
		}
		sleep 10;
	}

	return ();
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|127
#	secondaryAppearInSection: >none
#	input: none
#	output: $TS_oligo_seq, $bamPath, $detect_TS_oligo, $exclude_flag, $genome, $include_flag, $max_thread, $min_MAPQ, $outDir, $outputPrefix, $overwrite
#	toCall: my ($bamPath, $exclude_flag, $include_flag, $min_MAPQ, $max_thread, $TS_oligo_seq, $detect_TS_oligo, $genome, $outputPrefix, $outDir, $overwrite) = &readParameters();
#	calledInLine: 130
#....................................................................................................................................................#
	
	my ($bamPath, $exclude_flag, $include_flag, $min_MAPQ, $max_thread, $TS_oligo_seq, $detect_TS_oligo, $genome, $outputPrefix, $outDir, $overwrite);
	
	$min_MAPQ = 0;
	$exclude_flag = '4,8,128,256,512,1024,2048';
	$max_thread = 5;
	$TS_oligo_seq = 'TTTCTTATATGGG';
	$detect_TS_oligo = 'auto';
	$overwrite = 'no';

	GetOptions 	(
		"bamPath=s"				=>	\$bamPath,
		"outDir=s"				=>	\$outDir,
		"genome=s"				=>	\$genome,
		"outputPrefix=s"		=>	\$outputPrefix,
		"min_MAPQ:i"			=>	\$min_MAPQ,
		"include_flag:s"		=>	\$include_flag,
		"exclude_flag:s"		=>	\$exclude_flag,
		"max_thread:i"			=>	\$max_thread,
		"TS_oligo_seq:s"		=>	\$TS_oligo_seq,
		"detect_TS_oligo:s"	=>	\$detect_TS_oligo,
		"overwrite:s"			=>	\$overwrite,
		'help'					=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	my $opt_check_hsh_ref = {
		'bamPath' => $bamPath,
		'outDir' => $outDir,
		'genome' => $genome,
		'outputPrefix' => $outputPrefix,
	};
	
	my $required = 'yes';
	print "\n";
	foreach my $option_name (keys %{$opt_check_hsh_ref}) {
		if (not defined $opt_check_hsh_ref->{$option_name}) {
			print "WARNING: option \"$option_name\" is requied\n";
			$required = 'no';
		}
	}
	if ($required eq 'no') {
		print "WARNING: SCAFE quitting. Please check this help message for required options\n";
		print "\n";
		HelpMessage(1);
	}
	
	#---check file
	my $file_check_hsh_ref = {
		'bamPath' => $bamPath,
	};
	
	if ($detect_TS_oligo ne 'auto' and $detect_TS_oligo ne 'skip' and $detect_TS_oligo ne 'match' and $detect_TS_oligo ne 'trim') {
		die "Quitting: detect_TS_oligo=$detect_TS_oligo. Option detect_TS_oligo must be ethier auto, skip, match or trim\n";
	}
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		if (not -s $file_path) {
			die "Quitting: File $option_name does not exists at $file_path";
		}
	}
	
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
	
	return($bamPath, $exclude_flag, $include_flag, $min_MAPQ, $max_thread, $TS_oligo_seq, $detect_TS_oligo, $genome, $outputPrefix, $outDir, $overwrite);

}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|790
#	appearInSub: checkAllExecutable|347, checkChunkResults|471, checkTSOPresence|494, chooseTSODetectionMode|616, convertBamToCTSS|661, generateChromNameConversionHsh|844, generateChunkInfoHsh|914, getChunkFasta|1195, getSubsampleFraction|1336, pileupCBDedupUMI|1417, poolChunkResults|1532, processPerChunk|1817
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|155, 3_checkTSO|176, 4_convert|184
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 370, 375, 384, 393, 402, 411, 420, 429, 438, 487, 568, 587, 588, 589, 590, 591, 592, 602, 611, 633, 640, 645, 648, 655, 675, 719, 740, 784, 859, 869, 896, 938, 1208, 1349, 1361, 1362, 1430, 1486, 1568, 1644, 1646, 1661, 1662, 1663, 1850, 1857, 1860, 1879, 1896, 1900
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->790
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->790
	
	return ();
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 115
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































