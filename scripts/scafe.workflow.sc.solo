#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use Getopt::Long 'HelpMessage';
use Time::HiRes qw( time );
use File::Spec::Functions qw(rel2abs abs2rel);
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                                ---> scafe.workflow.sc.solo <---
                  <--- workflow, single-cell mode, process a single sample --->

 Description:
   This workflow process a single sample, from a cellranger bam file to tCRE UMI/cellbarcode count matrix

 Usage:
   scafe.workflow.sc.solo [options] --run_bam_path --run_cellbarcode_path --genome --run_tag --run_outDir
   
   --run_bam_path                  <required> [string] bam file from cellranger, can be read 1 only or pair-end
   --run_cellbarcode_path          <required> [string] tsv file contains a list of cell barcodes,
                                                       barcodes.tsv.gz from cellranger
   --genome                        <required> [string] name of genome reference, e.g. hg19.gencode_v32lift37
   --run_tag                       <required> [string] prefix for the output files
   --run_outDir                    <required> [string] directory for the output files
   --training_signal_path          (optional) [string] quantitative signal (e.g. ATAC -logP, in bigwig format), or binary genomic 
                                                       regions (e.g. annotated CRE, in bed format) used for training of logical 
                                                       regression model If null, $usr_glm_model_path must be supplied for 
                                                       pre-built logical regression model. It overrides usr_glm_model_path 
                                                       (default=null)
   --testing_signal_path           (optional) [string] quantitative signal (e.g. ATAC -logP, in bigwig format), or binary genomic 
                                                       regions (e.g. annotated CRE, in bed format) used for testing the performance 
                                                       of the logical regression model. If null, annotated TSS from $genome will be 
                                                       used as binary genomic regions. (default=null)
   --detect_TS_oligo (optional) [match|trim|skip|auto] in bam_to_ctss step, the modes of detecting TS oligo. 1. match: search for 
                                                       TS oligo sequence on the read, identify the TSO/cDNA junction as 5'end of 
                                                       the read. This works only when the error rate of the TS oligo region on 
                                                       the read is low, otherwise a considerable number of read will be invalid. 
                                                       2. trim: assuming the 1st N bases of the reads are TS oligo, without 
                                                       checking the actual sequence. N is determined by the length of TS oligo. 
                                                       3. skip: assuming the TS oligo was not sequenced, the 1st base of the read
                                                       will be treated as the 1st base after the TS oligo. 4. auto: automatically 
                                                       determines the best mode, best of the observed error rate of the TS oligo
                                                       and the frequency of 5'end softclipped bases by the aligner. If softcliped 
                                                       bases is close to the length of TS oligo, mode 1 or 2 will be chosen, 
                                                       depending on the observed error rate of the TS oligo (error rate <= 0.1, 
                                                       mode 1 will be chosen or mode 2 otherwise). If softcliped base os close to 
                                                       zero, mode 3 will be chosen. (default=auto).
   --max_thread                   (optional) [integer] maximum number of parallel threads, capped at 10 to 
                                                       avoid memory overflow (default=5)
   --overwrite                     (optional) [yes/no] erase run_outDir before running (default=no)

 Dependencies:
   R packages: 'ROCR','PRROC', 'caret', 'e1071', 'ggplot2', 'scales', 'reshape2'
   bigWigAverageOverBed
   bedGraphToBigWig
   bedtools
   samtools
   paraclu
   paraclu-cut.sh
   tabix
   bgzip

 For demo, cd to SCAFE dir and run,
   scafe.workflow.sc.solo \
   --overwrite=yes \
   --run_bam_path=./demo/input/sc.solo/demo.cellranger.bam \
   --run_cellbarcode_path=./demo/input/sc.solo/demo.barcodes.tsv.gz \
   --genome=hg19.gencode_v32lift37 \
   --run_tag=demo \
   --run_outDir=./demo/output/sc.solo/

=head1 VERSION

v0.9.0-beta [March 20, 2021]
	-Initial pre-release

v1.0.0 [June 6, 2022]
	-added 4 modes of detect_TS_oligo with new version of scafe.tool.sc.bam_to_ctss
	-added directionality

v1.0.1 [June 26, 2022]
	-In cluster step, will use unencoded G ctss for hard filtering (--count_ctss_bed_path= option) 

=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startTasks
#
#<section ID="startTasks" num="0">
my $ARGV_ary_ref = [@ARGV];
my ($run_bam_path, $run_cellbarcode_path, $genome, $training_signal_path, $testing_signal_path, $detect_TS_oligo, $max_thread, $run_tag, $run_outDir, $overwrite) = &readParameters();#->435
$max_thread = 10 if $max_thread > 10;
my ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath) = &prepDir($run_outDir, $ARGV_ary_ref);#->407
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->382
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_run
#
#<section ID="run" num="1">
my ($path_hsh_ref) = &define_path($run_outDir, $run_tag, $run_bam_path, $run_cellbarcode_path, $training_signal_path, $testing_signal_path, $script_dir);#->186
my ($task_info_hsh_ref) = &define_task($genome, $path_hsh_ref, $detect_TS_oligo, $max_thread, $run_tag, $run_outDir);#->235
&run_task($task_info_hsh_ref, $path_hsh_ref, $result_script_dir);#->493
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	general [n=3]:
#		currentTime, logCalledCMDAndScript, readParameters
#
#	unassigned [n=4]:
#		define_path, define_task, prepDir
#		run_task
#
#====================================================================================================================================================#

sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: prepDir|407, run_task|493
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 0_startTasks|130, 1_run|142
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 421, 508, 523, 547, 549, 550, 569
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub define_path {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_run|142
#	secondaryAppearInSection: >none
#	input: $run_bam_path, $run_cellbarcode_path, $run_outDir, $run_tag, $script_dir, $testing_signal_path, $training_signal_path
#	output: $path_hsh_ref
#	toCall: my ($path_hsh_ref) = &define_path($run_outDir, $run_tag, $run_bam_path, $run_cellbarcode_path, $training_signal_path, $testing_signal_path, $script_dir);
#	calledInLine: 145
#....................................................................................................................................................#

	my ($run_outDir, $run_tag, $run_bam_path, $run_cellbarcode_path, $training_signal_path, $testing_signal_path, $script_dir) = @_;
	
	my $path_hsh_ref = {
		'script_dir' => $script_dir,

		'run_bam_path' => $run_bam_path,
		'run_cellbarcode_path' => $run_cellbarcode_path,
		'training_signal_path' => $training_signal_path,
		'testing_signal_path' => $testing_signal_path,

		'CB_ctss_bed_path' => $run_outDir."/bam_to_ctss/".$run_tag."/bed/".$run_tag.".CB.ctss.bed.gz",
		'ung_ctss_bed_path' => $run_outDir."/bam_to_ctss/".$run_tag."/bed/".$run_tag.".unencoded_G.collapse.ctss.bed.gz",
		'collapse_ctss_bed_path' => $run_outDir."/bam_to_ctss/".$run_tag."/bed/".$run_tag.".collapse.ctss.bed.gz",
		'filtered_ctss_bed_path' => $run_outDir."/remove_strand_invader/".$run_tag."/bed/".$run_tag.".pass.ctss.bed.gz",
		'raw_tssCluster_bed_path' => $run_outDir."/cluster/".$run_tag."/bed/".$run_tag.".tssCluster.bed.gz",
		'filtered_tssCluster_info_path' => $run_outDir."/filter/".$run_tag."/log/".$run_tag.".tssCluster.log.tsv",

		'bw_cpm_rev_path' => $run_outDir."/ctss_to_bigwig/".$run_tag."/wig/".$run_tag.".cpm.rev.bw",
		'bw_cpm_fwd_path' => $run_outDir."/ctss_to_bigwig/".$run_tag."/wig/".$run_tag.".cpm.fwd.bw",
		'bw_count_rev_path' => $run_outDir."/ctss_to_bigwig/".$run_tag."/wig/".$run_tag.".count.rev.bw",
		'bw_count_fwd_path' => $run_outDir."/ctss_to_bigwig/".$run_tag."/wig/".$run_tag.".count.fwd.bw",

		'tCRE_bed_path' => $run_outDir."/annotate/".$run_tag."/bed/".$run_tag.".CRE.coord.bed.gz",
		'tCRE_info_path' => $run_outDir."/annotate/".$run_tag."/log/".$run_tag.".CRE.info.tsv.gz",
		'tssCluster_bed_path' => $run_outDir."/annotate/".$run_tag."/bed/".$run_tag.".cluster.coord.bed.gz",
		'tssCluster_info_path' => $run_outDir."/annotate/".$run_tag."/log/".$run_tag.".cluster.info.tsv.gz",
		'directionality_info_path' => $run_outDir."/directionality/".$run_tag."/log/".$run_tag.".directionality.log.tsv.gz",
	};

	foreach my $level (qw/robust lenient default/) {
		$path_hsh_ref->{"$level.filtered_tssCluster_bed_path"} = $run_outDir."/filter/".$run_tag."/bed/".$run_tag.".tssCluster.".$level.".filtered.bed.gz";
	}

	return ($path_hsh_ref);

}
sub define_task {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_run|142
#	secondaryAppearInSection: >none
#	input: $detect_TS_oligo, $genome, $max_thread, $path_hsh_ref, $run_outDir, $run_tag
#	output: $task_info_hsh_ref
#	toCall: my ($task_info_hsh_ref) = &define_task($genome, $path_hsh_ref, $detect_TS_oligo, $max_thread, $run_tag, $run_outDir);
#	calledInLine: 146
#....................................................................................................................................................#

	my ($genome, $path_hsh_ref, $detect_TS_oligo, $max_thread, $run_tag, $run_outDir) = @_;

	my $task_info_hsh_ref = {
		1 => {
			'task_name' => 'bam_to_ctss',
			'script_name' => 'scafe.tool.sc.bam_to_ctss',
			'param' => [
				['genome', $genome],
				['detect_TS_oligo', $detect_TS_oligo],
				['max_thread', $max_thread],
				['bamPath', $path_hsh_ref->{'run_bam_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/bam_to_ctss"],
			],
			'check' => [
				 $path_hsh_ref->{'ung_ctss_bed_path'},
				 $path_hsh_ref->{'collapse_ctss_bed_path'},
				 $path_hsh_ref->{'CB_ctss_bed_path'},
			]
		},
		2 => {
			'task_name' => 'remove_strand_invader',
			'script_name' => 'scafe.tool.cm.remove_strand_invader',
			'param' => [
				['ctss_bed_path', $path_hsh_ref->{'collapse_ctss_bed_path'}],
				['genome', $genome],
				['max_thread', $max_thread],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/remove_strand_invader"],
			],
			'check' => [
				 $path_hsh_ref->{'filtered_ctss_bed_path'},
			]
		},
		3 => {
			'task_name' => 'cluster',
			'script_name' => 'scafe.tool.cm.cluster',
			'param' => [
				['cluster_ctss_bed_path', $path_hsh_ref->{'filtered_ctss_bed_path'}],
				['count_ctss_bed_path', $path_hsh_ref->{'ung_ctss_bed_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/cluster"],
			],
			'check' => [
				 $path_hsh_ref->{'raw_tssCluster_bed_path'},
			]
		},
		4 => {
			'task_name' => 'filter',
			'script_name' => 'scafe.tool.cm.filter',
			'param' => [
				['genome', $genome],
				['training_signal_path', $path_hsh_ref->{'training_signal_path'}],
				['testing_signal_path', $path_hsh_ref->{'testing_signal_path'}],
				['ung_ctss_bed_path', $path_hsh_ref->{'ung_ctss_bed_path'}],
				['tssCluster_bed_path', $path_hsh_ref->{'raw_tssCluster_bed_path'}],
				['ctss_bed_path', $path_hsh_ref->{'filtered_ctss_bed_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/filter"],
			],
			'check' => [
				 $path_hsh_ref->{'default.filtered_tssCluster_bed_path'},
				 $path_hsh_ref->{'robust.filtered_tssCluster_bed_path'},
				 $path_hsh_ref->{'lenient.filtered_tssCluster_bed_path'},
			]
		},
		5 => {
			'task_name' => 'ctss_to_bigwig',
			'script_name' => 'scafe.tool.cm.ctss_to_bigwig',
			'param' => [
				['genome', $genome],
				['ctss_bed_path', $path_hsh_ref->{'filtered_ctss_bed_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/ctss_to_bigwig"],
			],
			'check' => [
				 $path_hsh_ref->{'bw_cpm_rev_path'},
				 $path_hsh_ref->{'bw_cpm_fwd_path'},
				 $path_hsh_ref->{'bw_count_rev_path'},
				 $path_hsh_ref->{'bw_count_fwd_path'},
			]
		},
		6 => {
			'task_name' => 'annotate',
			'script_name' => 'scafe.tool.cm.annotate',
			'param' => [
				['genome', $genome],
				['tssCluster_bed_path', $path_hsh_ref->{"default.filtered_tssCluster_bed_path"}],
				['tssCluster_info_path', $path_hsh_ref->{'filtered_tssCluster_info_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/annotate"],
			],
			'check' => [
				$path_hsh_ref->{"tCRE_bed_path"},
				$path_hsh_ref->{"tCRE_info_path"},
				$path_hsh_ref->{"tssCluster_bed_path"},
				$path_hsh_ref->{"tssCluster_info_path"},
			]
		},
		7 => {
			'task_name' => 'count',
			'script_name' => 'scafe.tool.sc.count',
			'param' => [
				['genome', $genome],
				['countRegion_bed_path', $path_hsh_ref->{"tCRE_bed_path"}],
				['ctss_bed_path', $path_hsh_ref->{'CB_ctss_bed_path'}],
				['cellBarcode_list_path', $path_hsh_ref->{'run_cellbarcode_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/count"],
			],
			'check' => [
				$run_outDir."/count/$run_tag/matrix/matrix.mtx",
				$run_outDir."/count/$run_tag/matrix/genes.tsv",
				$run_outDir."/count/$run_tag/matrix/barcodes.tsv",
			]
		},
		8 => {
			'task_name' => 'directionality',
			'script_name' => 'scafe.tool.cm.directionality',
			'param' => [
				['CRE_bed_path', $path_hsh_ref->{'tCRE_bed_path'}],
				['CRE_info_path', $path_hsh_ref->{'tCRE_info_path'}],
				['ctss_bed_path', $path_hsh_ref->{'filtered_ctss_bed_path'}],
				['outputPrefix', $run_tag],
				['outDir', $run_outDir."/directionality"],
			],
			'check' => [
				$path_hsh_ref->{"directionality_info_path"},
			]
		}
	};
	
	return($task_info_hsh_ref);
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|130
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 137
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub prepDir {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: currentTime|168
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|130
#	secondaryAppearInSection: >none
#	input: $ARGV_ary_ref, $run_outDir
#	output: $ARGVStr, $result_script_dir, $scafe_dir, $scriptAbsPath, $script_dir
#	toCall: my ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath) = &prepDir($run_outDir, $ARGV_ary_ref);
#	calledInLine: 136
#....................................................................................................................................................#
	my ($run_outDir, $ARGV_ary_ref) = @_;

	my $scriptAbsPath = abs_path($0);
	my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @{$ARGV_ary_ref});#->168
	my @path_split = split /\//, $scriptAbsPath;
	my $scafe_dir_index = $#path_split-2;
	my $script_dir_index = $#path_split-1;
	my $scafe_dir = join "/", @path_split[0..$scafe_dir_index];
	my $script_dir = join "/", @path_split[0..$script_dir_index];

	my @mkDirAry;
	my $result_script_dir = "$run_outDir/script/"; push @mkDirAry, $result_script_dir;
	foreach my $dir (@mkDirAry) {system ("mkdir -pm 755 $dir");}

	return ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath);
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|130
#	secondaryAppearInSection: >none
#	input: none
#	output: $detect_TS_oligo, $genome, $max_thread, $overwrite, $run_bam_path, $run_cellbarcode_path, $run_outDir, $run_tag, $testing_signal_path, $training_signal_path
#	toCall: my ($run_bam_path, $run_cellbarcode_path, $genome, $training_signal_path, $testing_signal_path, $detect_TS_oligo, $max_thread, $run_tag, $run_outDir, $overwrite) = &readParameters();
#	calledInLine: 134
#....................................................................................................................................................#
	
	my ($run_bam_path, $run_cellbarcode_path, $genome, $training_signal_path, $testing_signal_path, $detect_TS_oligo, $max_thread, $run_tag, $run_outDir, $overwrite);

	$overwrite = 'no';
	$max_thread = 5;
	$detect_TS_oligo = 'auto';
	
	GetOptions 	(
		"run_bam_path=s"				=>	\$run_bam_path,
		"run_cellbarcode_path=s"	=>	\$run_cellbarcode_path,
		"genome=s"						=>	\$genome,
		"max_thread:i"					=>	\$max_thread,
		"training_signal_path:s"	=>	\$training_signal_path,
		"testing_signal_path:s"		=>	\$testing_signal_path,
		"detect_TS_oligo:s"			=>	\$detect_TS_oligo,
		"run_tag=s"						=>	\$run_tag,
		"run_outDir=s"					=>	\$run_outDir,
		"overwrite:s"					=>	\$overwrite,
		'help'							=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $run_bam_path;

	#---check file
	my $file_check_hsh_ref = {
		'run_bam_path' => $run_bam_path,
		'run_cellbarcode_path' => $run_cellbarcode_path,
	};
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}

	if ($detect_TS_oligo ne 'auto' and $detect_TS_oligo ne 'skip' and $detect_TS_oligo ne 'match' and $detect_TS_oligo ne 'trim') {
		die "Quitting: detect_TS_oligo=$detect_TS_oligo. Option detect_TS_oligo must be ethier auto, skip, match or trim\n";
	}

	system "rm -rf $run_outDir" if ($overwrite eq 'yes');

	chop $run_outDir if ($run_outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $run_outDir/";
	
	return($run_bam_path, $run_cellbarcode_path, $genome, $training_signal_path, $testing_signal_path, $detect_TS_oligo, $max_thread, $run_tag, $run_outDir, $overwrite);

}
sub run_task {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: currentTime|168
#	appearInSub: >none
#	primaryAppearInSection: 1_run|142
#	secondaryAppearInSection: >none
#	input: $path_hsh_ref, $result_script_dir, $task_info_hsh_ref
#	output: none
#	toCall: &run_task($task_info_hsh_ref, $path_hsh_ref, $result_script_dir);
#	calledInLine: 147
#....................................................................................................................................................#
	
	my ($task_info_hsh_ref, $path_hsh_ref, $result_script_dir) = @_;
	
	open TASKLOG, ">", "$result_script_dir/task.log.txt";
	print TASKLOG join "", (join "\t", ('0', 'workflow', 'manager', 'started', &currentTime())), "\n";#->168
	foreach my $task_num (sort {$a <=> $b} keys %{$task_info_hsh_ref}) {
		my $task_name = $task_info_hsh_ref->{$task_num}{'task_name'};
		my $script_name = $task_info_hsh_ref->{$task_num}{'script_name'};
		my $result_found = 'yes';
		foreach my $check_path (@{$task_info_hsh_ref->{$task_num}{'check'}}) {
			$result_found = 'no' if not -s $check_path;
		}
		
		if ($result_found eq 'no') {

			print "\n";
			print "#===========================#\n";
			print "Start running $task_name\n";
			print "#===========================#\n";
			print TASKLOG join "", (join "\t", ($task_num, $task_name, $script_name, 'started', &currentTime())), "\n";#->168

			my $script_path = $path_hsh_ref->{'script_dir'}.'/'.$script_name;
			die "script of $task_name does not exist at $script_path\n" if not -s $script_path;
			my @cmd_param_ary = ($script_path);
			foreach my $indiv_param_ary_ref (@{$task_info_hsh_ref->{$task_num}{'param'}}) {
				my ($param_name, $param_val) = @{$indiv_param_ary_ref};
				if (defined $param_val) {#---[2020/10/07 20:32] specifically for skipping training_signal_path if not input
					push @cmd_param_ary, "--$param_name=$param_val";
				}
			}
			my $cmd = join " ", @cmd_param_ary;
			system "$cmd";

			$result_found = 'yes';
			foreach my $check_path (@{$task_info_hsh_ref->{$task_num}{'check'}}) {
				$result_found = 'no' if not -s $check_path;
			}
			
			if ($result_found eq 'yes') {
				print "\n";
				print "#============================================#\n";
				print "Results of $task_name found. Run successfully.\n";
				print "#============================================#\n";
				print TASKLOG join "", (join "\t", ($task_num, $task_name, $script_name, 'successful', &currentTime())), "\n";#->168
			} else {
				print TASKLOG join "", (join "\t", ($task_num, $task_name, $script_name, 'failed', &currentTime())), "\n";#->168
				print TASKLOG join "", (join "\t", ('0', 'workflow', 'workflow', 'failed', &currentTime())), "\n";#->168
				print "\n";
				print "#========================================#\n";
				print "Results of $task_name not found. Quitting.\n";
				print "#========================================#\n";
				die;
			}
			
		} else {
			print "#=====================================#\n";
			print "Results of $task_name found. Skipping.\n";
			print "#=====================================#\n";
		}
	}

	print "\n";
	print "#=====================================================#\n";
	print "Results of all tasks found. All tasks run successfully.\n";
	print "#=====================================================#\n";
	print TASKLOG join "", (join "\t", ('0', 'workflow', 'manager', 'successful', &currentTime())), "\n";#->168
	close TASKLOG;
}

exit;


















































