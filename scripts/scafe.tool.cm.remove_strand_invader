#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use List::Util qw (sum shuffle min max);
use threads ('stack_size' => 64*4096);
use threads::shared;
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                           ---> scafe.tool.cm.remove_strand_invader <---
                  <--- tool, common mode, remove strand invader artefact --->

 Description:
   This tool identify and remove strand invader artefact from a ctss bed file, 
   by aligning the sequence immediate upstream of a ctss to TS oligo sequence

 Usage:
   scafe.tool.cm.remove_strand_invader [options] --ctss_bed_path --genome --outputPrefix --outDir
   
   --ctss_bed_path      <required> [string]  "collapse" ctss file from scafe.tool.sc.bam_to_ctss.pl, 
                                             4th column is number of cells and 5th column is number UMI
   --genome             <required> [string]  name of genome reference, e.g. hg19.gencode_v32lift37
   --outputPrefix       <required> [string]  prefix for the output files
   --outDir             <required> [string]  directory for the output files
   --min_edit_distance  (optional) [integer] edit distance threshold to define strand invader 
                                             the smaller value, the more stringent defintion of strand invader
                                             (default=5)
   --min_end_non_G_num  (optional) [integer] immediate upstream non-G number threshold to define strand invader
                                             the smaller value, the more stringent defintion of strand invader
                                             (default=2)
   --max_thread         (optional) [integer] maximum number of parallel threads, capped at 
                                             10 to avoid memory overflow (default=5)
   --TS_oligo_seq       (optional) [string]  Template switching oligo sequence for identification 
                                             of 5'end (default=TTTCTTATATGGG) 
   --overwrite          (optional) [yes/no]  [yes/no]  erase outDir/outputPrefix before running (default=no)

 Dependencies:
   bedtools
   tabix
   bgzip

 For demo, cd to SCAFE dir and run,
   scafe.tool.cm.remove_strand_invader \
   --overwrite=yes \
   --ctss_bed_path=./demo/output/sc.solo/bam_to_ctss/demo/bed/demo.collapse.ctss.bed.gz \
   --genome=hg19.gencode_v32lift37 \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.solo/remove_strand_invader/

=head1 VERSION

v0.9.0-beta [March 20, 2021]
	-Initial pre-release

v1.0.0 [June 6, 2022]
	-No update

v1.0.1 [June 26, 2022]
	-No update

=cut#
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->1158
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->462
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($ctss_bed_path, $TS_oligo_seq, $min_edit_distance, $min_end_non_G_num, $max_thread, $genome, $outputPrefix, $outDir, $overwrite) = &readParameters();#->1083
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $chunk_size = 100000000;
my $bgzip_sort_thread = 5;
$max_thread = 10 if $max_thread > 10;
my $output_cutoff_hsh_ref = {
	'min_edit_distance' => $min_edit_distance, #---[2019/12/19 20:21] is strand invader if <= X edit distance in the whole 13 nucleotides (i.e. 13 to turn out)
	'min_end_non_G_num' => $min_end_non_G_num, #---[2019/12/19 20:21] is strand invader if <= X nonGs in the last 3 nucleotides (i.e. 3 to turn out)
};
my $paramTag = "$outputPrefix";
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineOutDirPath
#
#<section ID="defineOutDirPath" num="2">
my @mkDirAry;
my $result_dir = "$outDir/$paramTag/"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $result_fasta_dir = "$result_dir/fasta/"; push @mkDirAry, $result_fasta_dir;
my $result_bed_dir = "$result_dir/bed/"; push @mkDirAry, $result_bed_dir;
my $result_log_dir = "$result_dir/log/"; push @mkDirAry, $result_log_dir;
my $result_tmp_dir = "$result_dir/tmp/"; push @mkDirAry, $result_tmp_dir;
my $result_script_dir = "$result_dir/script/"; push @mkDirAry, $result_script_dir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 777 $dir");}

open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->711
&printStartOrFinishMessage("startMessage");#->940
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_count
#
#<section ID="count" num="3">
my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();#->311
my ($fasta_path, $chrom_size_path) = &checkFastaChromSizePath($genome);#->440
my ($chrom_size_hsh_ref) = &readChromSize($chrom_size_path);#->1058
my ($chunk_info_hsh_ref) = &generateChunkInfoHsh($chrom_size_hsh_ref, $chunk_size, $result_tmp_dir);#->587
&processPerChunk($ctss_bed_path, $fasta_path, $result_fasta_dir, $TS_oligo_seq, $bedtools_bin, $tabix_bin, $bgzip_bin, $bgzip_sort_thread, $max_thread, $output_cutoff_hsh_ref, $chunk_info_hsh_ref, $chrom_size_path, $paramTag);#->974
&poolChunkResults($tabix_bin, $chunk_info_hsh_ref, $result_bed_dir, $result_log_dir, $paramTag);#->736
system("rm -rf $result_tmp_dir");
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_finishingTasks
#
#<section ID="finishingTasks" num="4">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->820
&printStartOrFinishMessage("finishMessage");#->940
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	general [n=5]:
#		currentTime, logCalledCMDAndScript, printStartOrFinishMessage
#		readParameters, timeStamp
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=10]:
#		calculateEditDistance, checkAllExecutable, checkChunkResults
#		checkFastaChromSizePath, filterCTSS, generateChunkInfoHsh
#		generateUpstreamSeq, poolChunkResults, processPerChunk
#		readChromSize
#
#====================================================================================================================================================#

sub calculateEditDistance {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: filterCTSS|480
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $seq1, $seq2
#	output: $edit
#	toCall: my ($edit) = &calculateEditDistance($seq1, $seq2);
#	calledInLine: 535
#....................................................................................................................................................#
	my ($seq1, $seq2) = @_;

	my $edit = '0';

	my $match = '1';
	my $mismatch = '-1';
	my $gap = '-1';

	my @matrix;
	$matrix[0][0]{score} = 0;
	$matrix[0][0]{pointer} = "none";
	for(my $j = 1; $j <= length($seq1); $j++) {
	   $matrix[0][$j]{score}   = $gap * $j;
	   $matrix[0][$j]{pointer} = "left";
	}
	for (my $i = 1; $i <= length($seq2); $i++) {
	   $matrix[$i][0]{score}   = $gap * $i;
	   $matrix[$i][0]{pointer} = "up";
	}

	# fill
	for(my $i = 1; $i <= length($seq2); $i++) {
	   for(my $j = 1; $j <= length($seq1); $j++) {
		  my ($diagonal_score, $left_score, $up_score);

		  # calculate match score
		  my $letter1 = substr($seq1, $j-1, 1);
		  my $letter2 = substr($seq2, $i-1, 1);
		  if ($letter1 eq $letter2) {
			 $diagonal_score = $matrix[$i-1][$j-1]{score} + $match;
		  } else {
			 $diagonal_score = $matrix[$i-1][$j-1]{score} + $mismatch;
		  }

		  # calculate gap scores
		  $up_score   = $matrix[$i-1][$j]{score} + $gap;
		  $left_score = $matrix[$i][$j-1]{score} + $gap;

		  # choose best score
		  if ($diagonal_score >= $up_score) {
			 if ($diagonal_score >= $left_score) {
				$matrix[$i][$j]{score}   = $diagonal_score;
				$matrix[$i][$j]{pointer} = "diagonal";
			 } else {
				$matrix[$i][$j]{score}   = $left_score;
				$matrix[$i][$j]{pointer} = "left";
			 }
		  } else {
			 if ($up_score >= $left_score) {
				$matrix[$i][$j]{score}   = $up_score;
				$matrix[$i][$j]{pointer} = "up";
			 } else {
				$matrix[$i][$j]{score}   = $left_score;
				$matrix[$i][$j]{pointer} = "left";
			 }
		  }
	   }
	}
	# trace-back
	my $align1 = "";
	my $align2 = "";

	# start at last cell of matrix
	my $j = length($seq1);
	my $i = length($seq2);

	while (1) {
	   last if $matrix[$i][$j]{pointer} eq "none"; # ends at first cell of matrix

	   if ($matrix[$i][$j]{pointer} eq "diagonal") {
		  $align1 .= substr($seq1, $j-1, 1);
		  $align2 .= substr($seq2, $i-1, 1);
		  $i--;
		  $j--;
	   } elsif ($matrix[$i][$j]{pointer} eq "left") {
		  $align1 .= substr($seq1, $j-1, 1);
		  $align2 .= "-";
		  $j--;
	   } elsif ($matrix[$i][$j]{pointer} eq "up") {
		  $align1 .= "-";
		  $align2 .= substr($seq2, $i-1, 1);
		  $i--;
	   }
	}
	$align1 = reverse $align1;
	$align2 = reverse $align2;

	for (my $i=0; $i<length($align1); ++$i){
		if (substr($align1,$i,1) ne substr($align2,$i,1)){
      		++$edit;
		}
	}

	return($edit);
}
sub checkAllExecutable {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1136
#	appearInSub: >none
#	primaryAppearInSection: 3_count|153
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedGraphToBigWig_bin, $bedtools_bin, $bgzip_bin, $bigWigAverageOverBed_bin, $cut_sh_path, $paraclu_bin, $samtools_bin, $tabix_bin
#	toCall: my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();
#	calledInLine: 156
#....................................................................................................................................................#
	
	my $dirPath = dirname(rel2abs($0));

	my $tabix_bin = "$dirPath/../resources/bin/tabix/tabix";
	my $bgzip_bin = "$dirPath/../resources/bin/bgzip/bgzip";
	my $bedtools_bin = "$dirPath/../resources/bin/bedtools/bedtools";
	my $samtools_bin = "$dirPath/../resources/bin/samtools/samtools";
	my $paraclu_bin = "$dirPath/../resources/bin/paraclu/paraclu";
	my $cut_sh_path = "$dirPath/../resources/bin/paraclu/paraclu-cut.sh";
	my $bedGraphToBigWig_bin = "$dirPath/../resources/bin/bedGraphToBigWig/bedGraphToBigWig";
	my $bigWigAverageOverBed_bin = "$dirPath/../resources/bin/bigWigAverageOverBed/bigWigAverageOverBed";
	
	&reportAndLogStatus("Checking all SCAFE executables", 10, "\n");#->1136
	
	{
		my $stdOut = `$tabix_bin  --version 2>&1`;
		if ($stdOut =~ m/tabix \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: tabix version: $1", 0, "\n");#->1136
		} else {
			die "tabix is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bgzip_bin --version 2>&1`;
		if ($stdOut =~ m/bgzip \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: bgzip version: $1", 0, "\n");#->1136
		} else {
			die "bgzip is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedtools_bin --version 2>&1`;
		if ($stdOut =~ m/bedtools v(\S+)/) {
			&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->1136
		} else {
			die "bedtools is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$samtools_bin 2>&1`;
		if ($stdOut =~ m/\s+(Version: \S+)\s+/) {
			&reportAndLogStatus("Checking: samtools version: $1", 0, "\n");#->1136
		} else {
			die "samtools is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$paraclu_bin 2>&1`;
		if ($stdOut =~ m/paraclu: I need a minValue and a fileName/) {
			&reportAndLogStatus("Checking: paraclu found.", 0, "\n");#->1136
		} else {
			die "paraclu is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$cut_sh_path 55C7128A 2>&1`;
		if ($stdOut =~ m/awk:/) {
			&reportAndLogStatus("Checking: paraclu-cut found.", 0, "\n");#->1136
		} else {
			die "paraclu-cut is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedGraphToBigWig_bin 2>&1`;
		if ($stdOut =~ m/bedGraphToBigWig v (\S+)/) {
			&reportAndLogStatus("Checking: bedGraphToBigWig version: $1", 0, "\n");#->1136
		} else {
			die "bedGraphToBigWig not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bigWigAverageOverBed_bin 2>&1`;
		if ($stdOut =~ m/bigWigAverageOverBed v(\S+)/) {
			&reportAndLogStatus("Checking: bigWigAverageOverBed version: $1", 0, "\n");#->1136
		} else {
			die "bigWigAverageOverBed is not installed properly. Quitting.\n";
		}
	}

	return ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin);
}
sub checkChunkResults {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1136
#	appearInSub: poolChunkResults|736, processPerChunk|974
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_count|153
#	input: $chunk_info_hsh_ref, $chunk_num
#	output: $valid
#	toCall: my ($valid) = &checkChunkResults($chunk_info_hsh_ref, $chunk_num);
#	calledInLine: 761, 1016
#....................................................................................................................................................#
	my ($chunk_info_hsh_ref, $chunk_num) = @_;
	
	my $valid = 'yes';
	foreach my $file_to_check (qw/chunk_log_path/) {
		my $file_path =  $chunk_info_hsh_ref->{$chunk_num}{$file_to_check};
		#&reportAndLogStatus("$file_path", 10, "\n");#->1136
		$valid = 'no' if not -s $file_path;
	}
 
	foreach my $ctss_type (qw/chunk_pass_ctss chunk_invader_ctss/) {
		my $file_path =  $chunk_info_hsh_ref->{$chunk_num}{'ctss'}{'sorted'}{$ctss_type};
		#&reportAndLogStatus("$file_path", 10, "\n");#->1136
		$valid = 'no' if not -s $file_path;
	}

	return ($valid);
}
sub checkFastaChromSizePath {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_count|153
#	secondaryAppearInSection: >none
#	input: $genome
#	output: $chrom_size_path, $fasta_path
#	toCall: my ($fasta_path, $chrom_size_path) = &checkFastaChromSizePath($genome);
#	calledInLine: 157
#....................................................................................................................................................#
	my ($genome) = @_;
	
	my $dirPath = dirname(rel2abs($0));
	my $fasta_path = "$dirPath/../resources/genome/$genome/fasta/genome.fa";
	my $chrom_size_path = "$dirPath/../resources/genome/$genome/tsv/chrom.sizes.tsv";
	die "genome $genome does not have fasta_path. Please rerun prep_genome step\n" if not -s $fasta_path;
	die "genome $genome does not have chrom_sizes_path. Please rerun prep_genome step\n" if not -s $chrom_size_path;

	return ($fasta_path, $chrom_size_path);
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|940, reportAndLogStatus|1136
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|133, 4_finishingTasks|167
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 99, 956, 960, 965, 969, 1152, 1153
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub filterCTSS {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: calculateEditDistance|204, reportAndLogStatus|1136
#	appearInSub: processPerChunk|974
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_count|153
#	input: $TS_oligo_seq, $bgzip_bin, $bgzip_sort_thread, $chunk_info_hsh_ref, $chunk_num, $count_cutoff_hsh_ref, $output_cutoff_hsh_ref
#	output: 
#	toCall: &filterCTSS($chunk_info_hsh_ref, $chunk_num, $TS_oligo_seq, $bgzip_bin, $bgzip_sort_thread, $output_cutoff_hsh_ref, $count_cutoff_hsh_ref);
#	calledInLine: 1024
#....................................................................................................................................................#
	my ($chunk_info_hsh_ref, $chunk_num, $TS_oligo_seq, $bgzip_bin, $bgzip_sort_thread, $output_cutoff_hsh_ref, $count_cutoff_hsh_ref) = @_;
	
	my $chunk_pass_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'ctss'}{'sorted'}{'chunk_pass_ctss'};
	my $chunk_unsort_pass_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'ctss'}{'unsort'}{'chunk_pass_ctss'};
	my $chunk_invader_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'ctss'}{'sorted'}{'chunk_invader_ctss'};
	my $chunk_unsort_invader_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'ctss'}{'unsort'}{'chunk_invader_ctss'};

	my $chunk_log_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_log_path'};
	my $chunk_upstream_seq_fasta_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_upstream_seq_fasta_path'};
	
	open PASSCTSS, ">", $chunk_unsort_pass_ctss_bed_path;
	open STRNDINVADCTSS, ">", $chunk_unsort_invader_ctss_bed_path;

	my $total_pos = 0;
	my $total_read = 0;
	my $filter_count_hsh_ref = {};
	
	foreach my $min_edit_distance (@{$count_cutoff_hsh_ref->{'min_edit_distance'}}) {
		foreach my $min_end_non_G_num (@{$count_cutoff_hsh_ref->{'min_end_non_G_num'}}) {
			$filter_count_hsh_ref->{$min_edit_distance}{$min_end_non_G_num}{'read'} = 0;
			$filter_count_hsh_ref->{$min_edit_distance}{$min_end_non_G_num}{'pos'} = 0;
		}
	}
	
	open FASTA, "< $chunk_upstream_seq_fasta_path";
	while (<FASTA>) {
		chomp;
		
		if ($_ =~ m/^>(.+)$/) {
			my $header = $1;
			#>chr15.20020713.+.1.1(+)
			$header =~ s/\(.\)$//;
			my ($chrom, $chromEnd, $strand, $original_ctssID, $score) = split /\.|:/, $header;
			my $chromStart = $chromEnd - 1;

			die "$score is not integer. Problem with getfasta.\n" if $score !~ m/^\d+$/;

			$total_pos++;
			$total_read += $score;

			&reportAndLogStatus("getting edit distance for chunk $chunk_num. $total_pos ctss position processed", 10, "\n") if $total_pos%100000==0;#->1136

			chomp (my $upstream_seq = <FASTA>);
			$upstream_seq = uc($upstream_seq);
			my ($edit_distance) = &calculateEditDistance($TS_oligo_seq, $upstream_seq);#->204
			my $last_3_nt = substr($upstream_seq, -3);
			my $end_non_G_num = ($last_3_nt ^ 'GGG') =~ tr/\0//c;
			
			if (($edit_distance <= $output_cutoff_hsh_ref->{'min_edit_distance'} and $end_non_G_num <= $output_cutoff_hsh_ref->{'min_end_non_G_num'})) {
				print STRNDINVADCTSS join "", (join "\t", ($chrom, $chromStart, $chromEnd, $original_ctssID, $score, $strand)), "\n";
			} else {
				print PASSCTSS join "", (join "\t", ($chrom, $chromStart, $chromEnd, $original_ctssID, $score, $strand)), "\n";
			}
			
			foreach my $min_edit_distance (@{$count_cutoff_hsh_ref->{'min_edit_distance'}}) {
				foreach my $min_end_non_G_num (@{$count_cutoff_hsh_ref->{'min_end_non_G_num'}}) {
					if (($edit_distance <= $min_edit_distance and $end_non_G_num <= $min_end_non_G_num)) {
						$filter_count_hsh_ref->{$min_edit_distance}{$min_end_non_G_num}{'read'} += $score;
						$filter_count_hsh_ref->{$min_edit_distance}{$min_end_non_G_num}{'pos'}++;
					}
				}
			}
		}
	};
	close FASTA;
	close PASSCTSS;
	close STRNDINVADCTSS;

	system "sort --parallel $bgzip_sort_thread -k2,2n -k6,6 $chunk_unsort_pass_ctss_bed_path | $bgzip_bin -@ $bgzip_sort_thread >$chunk_pass_ctss_bed_path";
	system "rm $chunk_unsort_pass_ctss_bed_path";
	system "sort --parallel $bgzip_sort_thread -k2,2n -k6,6 $chunk_unsort_invader_ctss_bed_path | $bgzip_bin -@ $bgzip_sort_thread >$chunk_invader_ctss_bed_path";
	system "rm $chunk_unsort_invader_ctss_bed_path";

	&reportAndLogStatus("done getting edit distance for chunk $chunk_num. $total_pos ctss position processed", 10, "\n") if $total_pos%100000==0;#->1136
			
	open LOG, ">", $chunk_log_path;
	print LOG join "", (join "\t", ('min_edit_distance', 'min_end_non_G_num', 'pos', 'read', 'pos_pct', 'read_pct', 'total_read', 'total_pos')), "\n";

	foreach my $min_edit_distance (@{$count_cutoff_hsh_ref->{'min_edit_distance'}}) {
		foreach my $min_end_non_G_num (@{$count_cutoff_hsh_ref->{'min_end_non_G_num'}}) {
			my $pos = $filter_count_hsh_ref->{$min_edit_distance}{$min_end_non_G_num}{'pos'};
			my $read = $filter_count_hsh_ref->{$min_edit_distance}{$min_end_non_G_num}{'read'};
			my $pos_pct = 0;
			my $read_pct = 0;
			if ($total_pos > 0) {
				$pos_pct = sprintf "%.5f", 100*$pos/$total_pos;
				$read_pct = sprintf "%.5f", 100*$read/$total_read;
			}
			print LOG join "", (join "\t", ($min_edit_distance, $min_end_non_G_num, $pos, $read, $pos_pct, $read_pct, $total_read, $total_pos)), "\n";
		}
	}
	close LOG;
	
	return ();
}
sub generateChunkInfoHsh {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1136
#	appearInSub: >none
#	primaryAppearInSection: 3_count|153
#	secondaryAppearInSection: >none
#	input: $chrom_size_hsh_ref, $chunk_size, $result_tmp_dir
#	output: $chunk_info_hsh_ref
#	toCall: my ($chunk_info_hsh_ref) = &generateChunkInfoHsh($chrom_size_hsh_ref, $chunk_size, $result_tmp_dir);
#	calledInLine: 159
#....................................................................................................................................................#
	my ($chrom_size_hsh_ref, $chunk_size, $result_tmp_dir) = @_;
	
	my $chunk_num = 1;
	my $chunk_info_hsh_ref = {};
	foreach my $chrom (sort keys %{$chrom_size_hsh_ref}) {
		my $size = $chrom_size_hsh_ref->{$chrom};
		foreach (my $startPos = 0; $startPos <= $size; $startPos += $chunk_size) {
			my $endPos = $startPos + $chunk_size;
			$endPos = $size if ($endPos > $size);
			my $file_tag = "$chrom.$startPos.$endPos";
			
			my $size_in_chunk = $endPos - $startPos;
			&reportAndLogStatus("chunk $chunk_num contains $size_in_chunk nt covering $chrom $startPos to $endPos", 10, "\n");#->1136

			my $chunk_upstream_seq_fasta_path = "$result_tmp_dir/$file_tag.upstream_seq.fasta";
			my $chunk_ctss_in_scope_bed_path = "$result_tmp_dir/$file_tag.ctss_in_scope.bed";
			my $chunk_scope_bed_path = "$result_tmp_dir/$file_tag.scope.bed";
			my $chunk_pass_ctss_bed_path = "$result_tmp_dir/$file_tag.pass.ctss.bed.gz";
			my $chunk_invader_ctss_bed_path = "$result_tmp_dir/$file_tag.invader.ctss.bed.gz";
			my $chunk_unsort_pass_ctss_bed_path = "$result_tmp_dir/$file_tag.unsort.pass.ctss.bed";
			my $chunk_unsort_invader_ctss_bed_path = "$result_tmp_dir/$file_tag.unsort.invader.ctss.bed";

			my $chunk_log_path = "$result_tmp_dir/$file_tag.log.txt";
			
			my ($chunk_chrom, $chunk_startPos, $chunk_endPos) = ($chrom, $startPos, $endPos);
			my $tabix_startPos = $chunk_startPos + 1; #---[2021/09/01 22:58] everything is zero based except tabix
			$chunk_info_hsh_ref->{$chunk_num}{'region_str'} = "$chunk_chrom:$chunk_startPos-$chunk_endPos";
			$chunk_info_hsh_ref->{$chunk_num}{'loc'} = [$chunk_chrom, $chunk_startPos, $chunk_endPos];
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_upstream_seq_fasta_path'} = $chunk_upstream_seq_fasta_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_ctss_in_scope_bed_path'} = $chunk_ctss_in_scope_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'tabix_region_str'} = "$chunk_chrom:$tabix_startPos-$chunk_endPos";
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_log_path'} = $chunk_log_path;

			$chunk_info_hsh_ref->{$chunk_num}{'ctss'}{'sorted'}{'chunk_pass_ctss'} = $chunk_pass_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'ctss'}{'unsort'}{'chunk_pass_ctss'} = $chunk_unsort_pass_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'ctss'}{'sorted'}{'chunk_invader_ctss'} = $chunk_invader_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'ctss'}{'unsort'}{'chunk_invader_ctss'} = $chunk_unsort_invader_ctss_bed_path;

			$chunk_num++;
		}
 	}

	return ($chunk_info_hsh_ref);
}
sub generateUpstreamSeq {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1136
#	appearInSub: processPerChunk|974
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_count|153
#	input: $TS_oligo_seq, $bedtools_bin, $chrom_size_path, $chunk_info_hsh_ref, $chunk_num, $ctss_bed_path, $fasta_path, $tabix_bin
#	output: $chunk_upstream_seq_fasta_path
#	toCall: my ($chunk_upstream_seq_fasta_path) = &generateUpstreamSeq($ctss_bed_path, $fasta_path, $TS_oligo_seq, $bedtools_bin, $tabix_bin, $chunk_num, $chunk_info_hsh_ref, $chrom_size_path);
#	calledInLine: 1023
#....................................................................................................................................................#
	my ($ctss_bed_path, $fasta_path, $TS_oligo_seq, $bedtools_bin, $tabix_bin, $chunk_num, $chunk_info_hsh_ref, $chrom_size_path) = @_;
	
	my $length = length($TS_oligo_seq);

	my ($chunk_chrom, $chunk_startPos, $chunk_endPos) = @{$chunk_info_hsh_ref->{$chunk_num}{'loc'}};
	my $chunk_upstream_seq_fasta_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_upstream_seq_fasta_path'};
	my $chunk_ctss_in_scope_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_ctss_in_scope_bed_path'};
	my $tabix_region_str = $chunk_info_hsh_ref->{$chunk_num}{'tabix_region_str'};
	
	&reportAndLogStatus("extracting ctss upstream seq for chunk $chunk_num", 10, "\n");#->1136

	open (TABIX, "$tabix_bin $ctss_bed_path $tabix_region_str |");
	open CTSSINSCOPE, ">", "$chunk_ctss_in_scope_bed_path";
	my $num_ctss_proc = 0;
	
	while (<TABIX>) {
		chomp;
		my ($chrom, $chromStart, $chromEnd, $original_ctssID, $score, $strand) = split /\t/;
		$num_ctss_proc++;
		
		$original_ctssID =~ s/\./_/g;
		$original_ctssID =~ s/\:/_/g;
		my $ctss_ID = "$chrom.$chromEnd.$strand.$original_ctssID.$score";
		
		&reportAndLogStatus("getting upstream seq for $chrom. $num_ctss_proc ctss position processed for chunk $chunk_num", 10, "\n") if $num_ctss_proc%1000000==0;#->1136
		
		my $upstream_start;
		my $upstream_end;
		
		if ($strand eq '+') {
			$upstream_start = $chromStart - $length;
			$upstream_end = $chromStart;
		
			if ($upstream_start < 0) {
				my $shift = abs($upstream_start);
				$upstream_start = $upstream_start + $shift;
				$upstream_end = $upstream_end + $shift;
			}
			
		} elsif ($strand eq '-') {
			$upstream_start = $chromEnd;
			$upstream_end = $chromEnd + $length;
		} else {
			die;
		}
		print CTSSINSCOPE join "", (join "\t", ($chrom, $upstream_start, $upstream_end, $ctss_ID, $score, $strand)), "\n";
	}
	close TABIX;
	close CTSSINSCOPE;
	
	&reportAndLogStatus("getting upstream seq for chunk $chunk_num", 10, "\n");#->1136
	system "$bedtools_bin getfasta -s -name -fi $fasta_path -bed $chunk_ctss_in_scope_bed_path -fo $chunk_upstream_seq_fasta_path";
	&reportAndLogStatus("done getting upstream seq for chunk $chunk_num. $num_ctss_proc ctss position processed", 10, "\n");#->1136
	
	return ($chunk_upstream_seq_fasta_path);
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|133
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 147
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub poolChunkResults {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: checkChunkResults|411, reportAndLogStatus|1136
#	appearInSub: >none
#	primaryAppearInSection: 3_count|153
#	secondaryAppearInSection: >none
#	input: $chunk_info_hsh_ref, $paramTag, $result_bed_dir, $result_log_dir, $tabix_bin
#	output: 
#	toCall: &poolChunkResults($tabix_bin, $chunk_info_hsh_ref, $result_bed_dir, $result_log_dir, $paramTag);
#	calledInLine: 161
#....................................................................................................................................................#
	my ($tabix_bin, $chunk_info_hsh_ref, $result_bed_dir, $result_log_dir, $paramTag) = @_;
	
	my $all_log_path = "$result_log_dir/$paramTag.invader.log.tsv";

	my $out_bed_hsh_ref = {
		'chunk_pass_ctss' => "$result_bed_dir/$paramTag.pass.ctss.bed.gz",
		'chunk_invader_ctss' => "$result_bed_dir/$paramTag.invader.ctss.bed.gz",
	};
	
	#---[2021/09/01 23:25] pool chunk bed
	foreach my $ctss_type (keys %{$out_bed_hsh_ref}) {
		my $out_ctss_type = $out_bed_hsh_ref->{$ctss_type};
		my @file_path_ary = ();
		foreach my $chunk_num (sort {$a <=> $b} keys %{$chunk_info_hsh_ref}) {
			my ($valid) = &checkChunkResults($chunk_info_hsh_ref, $chunk_num);#->411
			if ($valid eq 'yes') {
				my $chunk_sorted_ctss = $chunk_info_hsh_ref->{$chunk_num}{'ctss'}{'sorted'}{$ctss_type};
				push @file_path_ary, $chunk_sorted_ctss;
				&reportAndLogStatus("$ctss_type of chunk $chunk_num is found", 10, "\n");#->1136
			} else {
				die "results of chunk $chunk_num is not found. quitting\n";
			}
		}
		&reportAndLogStatus("Concatenating $ctss_type files", 10, "\n");#->1136
		my $file_path_str = join " ", @file_path_ary;
		system "cat $file_path_str >$out_ctss_type";
		&reportAndLogStatus("Tabix indexing combined $ctss_type", 10, "\n");#->1136
		system "$tabix_bin -p bed $out_ctss_type";
	}

	#---[2021/09/01 23:25] pool chunk log
	my $filter_count_hsh_ref = {};
	my $all_total_pos = 0;
	my $all_total_read = 0;
	foreach my $chunk_num (sort {$a <=> $b} keys %{$chunk_info_hsh_ref}) {

		my $chunk_log_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_log_path'};
		
		my $chunk_total_pos;
		my $chunk_total_read;
		open (CHUNKLOG, "<", $chunk_log_path);
		<CHUNKLOG>;
		while (<CHUNKLOG>) {
			chomp;
			my ($min_edit_distance, $min_end_non_G_num, $pos, $read, $pos_pct, $read_pct, $total_read, $total_pos) = split /\t/;
			$filter_count_hsh_ref->{$min_edit_distance}{$min_end_non_G_num}{'read'} += $read;
			$filter_count_hsh_ref->{$min_edit_distance}{$min_end_non_G_num}{'pos'} += $pos;
			$chunk_total_pos = $total_pos;
			$chunk_total_read = $total_read;
		}
		close CHUNKLOG;
		
		$all_total_pos += $chunk_total_pos;
		$all_total_read += $chunk_total_read;

	}

	open ALLLOG, ">", $all_log_path;
	print ALLLOG join "", (join "\t", ('min_edit_distance', 'min_end_non_G_num', 'pos', 'read', 'pos_pct', 'read_pct')), "\n";
	foreach my $min_edit_distance (sort {$a <=> $b} keys %{$filter_count_hsh_ref}) {
		foreach my $min_end_non_G_num (sort {$a <=> $b} keys %{$filter_count_hsh_ref->{$min_edit_distance}}) {
			my $pos = $filter_count_hsh_ref->{$min_edit_distance}{$min_end_non_G_num}{'pos'};
			my $read = $filter_count_hsh_ref->{$min_edit_distance}{$min_end_non_G_num}{'read'};
			my $pos_pct = sprintf "%.5f", 100*$pos/$all_total_pos;
			my $read_pct = sprintf "%.5f", 100*$read/$all_total_read;
			print ALLLOG join "", (join "\t", ($min_edit_distance, $min_end_non_G_num, $pos, $read, $pos_pct, $read_pct)), "\n";
		}
	}
	close ALLLOG;

	return ();
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_finishingTasks|167
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 170
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			@colLenCountHsh = sort {$b <=> $a} @colLenCountHsh;
			my $headerColLen = $colLenCountHsh[0]+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}
	
	@{$filelistLenCountHsh{'dir'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'dir'}};
	@{$filelistLenCountHsh{'name'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'name'}};
	@{$filelistLenCountHsh{'description'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'description'}};

	my $fileDir_colLen = $filelistLenCountHsh{'dir'}[0]+2;
	my $fileName_colLen = $filelistLenCountHsh{'name'}[0]+2;
	my $fileDescription_colLen = $filelistLenCountHsh{'description'}[0]+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|462
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|133, 4_finishingTasks|167
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 148, 171
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->462
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->462
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->462
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->462
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub processPerChunk {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: checkChunkResults|411, filterCTSS|480, generateUpstreamSeq|643, reportAndLogStatus|1136
#	appearInSub: >none
#	primaryAppearInSection: 3_count|153
#	secondaryAppearInSection: >none
#	input: $TS_oligo_seq, $bedtools_bin, $bgzip_bin, $bgzip_sort_thread, $chrom_size_path, $chunk_info_hsh_ref, $ctss_bed_path, $fasta_path, $max_thread, $output_cutoff_hsh_ref, $paramTag, $result_fasta_dir, $tabix_bin
#	output: 
#	toCall: &processPerChunk($ctss_bed_path, $fasta_path, $result_fasta_dir, $TS_oligo_seq, $bedtools_bin, $tabix_bin, $bgzip_bin, $bgzip_sort_thread, $max_thread, $output_cutoff_hsh_ref, $chunk_info_hsh_ref, $chrom_size_path, $paramTag);
#	calledInLine: 160
#....................................................................................................................................................#
	my ($ctss_bed_path, $fasta_path, $result_fasta_dir, $TS_oligo_seq, $bedtools_bin, $tabix_bin, $bgzip_bin, $bgzip_sort_thread, $max_thread, $output_cutoff_hsh_ref, $chunk_info_hsh_ref, $chrom_size_path, $paramTag) = @_;

	$TS_oligo_seq = uc($TS_oligo_seq);
	my %itemForThrHsh = ();
	my $threadID = 1;
	my $chrom_info_hsh_ref = {};
	
	foreach my $chunk_num (keys %{$chunk_info_hsh_ref}) {
		$threadID = 1 if $threadID > $max_thread;
		$itemForThrHsh{$threadID}{$chunk_num}++;
		$threadID++;
	}

	my $count_cutoff_hsh_ref = {
		'min_edit_distance' => [1,2,3,4,5,6,7,8],
		'min_end_non_G_num' => [1,2,3],
	};
	
	my %threadHsh =();
	foreach my $threadID (sort {$a <=> $b} keys %itemForThrHsh) {
		my $itemForThrHsh_ref = $itemForThrHsh{$threadID};
		($threadHsh{$threadID}) = threads->new(#---refer to http://www.perlmonks.org/?node_id=966781, the 
	
			sub {
				
				my ($itemForThrHsh_ref) = @_;
				my $total_chunk = keys %{$itemForThrHsh_ref};
				
				&reportAndLogStatus("$total_chunk chunks spawned to thread $threadID.", 10, "\n");#->1136
				foreach my $chunk_num (keys %{$itemForThrHsh_ref}) {

					my ($valid) = &checkChunkResults($chunk_info_hsh_ref, $chunk_num);#->411

					if ($valid eq 'yes') {
						&reportAndLogStatus("results of chunk $chunk_num is found. skipping", 10, "\n");#->1136

					} else {
						&reportAndLogStatus("start processing chunk $chunk_num in thread $threadID.", 10, "\n");#->1136
						&generateUpstreamSeq($ctss_bed_path, $fasta_path, $TS_oligo_seq, $bedtools_bin, $tabix_bin, $chunk_num, $chunk_info_hsh_ref, $chrom_size_path);#->643
						&filterCTSS($chunk_info_hsh_ref, $chunk_num, $TS_oligo_seq, $bgzip_bin, $bgzip_sort_thread, $output_cutoff_hsh_ref, $count_cutoff_hsh_ref);#->480
					}
				}

				return ();
			}
			,($itemForThrHsh_ref)
		);
	}
	
	while (keys %threadHsh) {

		my @threads = threads->list();
		my $thread_count = threads->list();
		my @running = threads->list(threads::running);
		my @joinable = threads->list(threads::joinable);
		my $running_count = @running;
		my $joinable_count = @joinable;

		&reportAndLogStatus("$thread_count threads exists. $running_count running and $joinable_count joinable", 10, "\n");#->1136

		foreach my $threadID (keys %threadHsh) {
			if (not $threadHsh{$threadID}->is_running() or $threadHsh{$threadID}->is_joinable() or $threadHsh{$threadID}->is_detached()) {
				&reportAndLogStatus("thread $threadID is finishing.", 10, "\n");#->1136
				$threadHsh{$threadID}->join();
				delete $threadHsh{$threadID};
			}
		}
		sleep 10;
	}

	return ();
}
sub readChromSize {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_count|153
#	secondaryAppearInSection: >none
#	input: $chrom_size_path
#	output: $chrom_size_hsh_ref
#	toCall: my ($chrom_size_hsh_ref) = &readChromSize($chrom_size_path);
#	calledInLine: 158
#....................................................................................................................................................#
	my ($chrom_size_path) = @_;
	
	my $chrom_size_hsh_ref = {};
	open (CHROMSIZE, "<", $chrom_size_path);
	while (<CHROMSIZE>) {
		chomp;
		my ($chrom, $size) = split /\s+/;
		$chrom_size_hsh_ref->{$chrom} = $size;
	}
	close CHROMSIZE;

	return ($chrom_size_hsh_ref);
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|110
#	secondaryAppearInSection: >none
#	input: none
#	output: $TS_oligo_seq, $ctss_bed_path, $genome, $max_thread, $min_edit_distance, $min_end_non_G_num, $outDir, $outputPrefix, $overwrite
#	toCall: my ($ctss_bed_path, $TS_oligo_seq, $min_edit_distance, $min_end_non_G_num, $max_thread, $genome, $outputPrefix, $outDir, $overwrite) = &readParameters();
#	calledInLine: 113
#....................................................................................................................................................#
	
	my ($ctss_bed_path, $TS_oligo_seq, $min_edit_distance, $min_end_non_G_num, $max_thread, $genome, $outputPrefix, $outDir, $overwrite);
	
	my $dirPath = dirname(rel2abs($0));
	$outDir = "$dirPath/output/";
	$min_edit_distance = 5;
	$min_end_non_G_num = 2;
	$max_thread = 5;
	$TS_oligo_seq = 'TTTCTTATATGGG';
	$overwrite = 'no';
	
	GetOptions 	(
		"ctss_bed_path=s"			=>	\$ctss_bed_path,
		"TS_oligo_seq=s"			=>	\$TS_oligo_seq,
		"genome=s"					=>	\$genome,
		"min_edit_distance:s"	=>	\$min_edit_distance,
		"min_end_non_G_num:i"	=>	\$min_end_non_G_num,
		"max_thread:s"				=>	\$max_thread,
		"outputPrefix=s"			=>	\$outputPrefix,
		"outDir=s"					=>	\$outDir,
		"overwrite:s"				=>	\$overwrite,
		'help'						=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $ctss_bed_path;
	
	#---check file
	my $file_check_hsh_ref = {
		'ctss_bed_path' => $ctss_bed_path,
	};
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}
	
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
	
	return($ctss_bed_path, $TS_oligo_seq, $min_edit_distance, $min_end_non_G_num, $max_thread, $genome, $outputPrefix, $outDir, $overwrite);
}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|462
#	appearInSub: checkAllExecutable|311, checkChunkResults|411, filterCTSS|480, generateChunkInfoHsh|587, generateUpstreamSeq|643, poolChunkResults|736, processPerChunk|974
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_count|153
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 334, 339, 348, 357, 366, 375, 384, 393, 402, 427, 433, 531, 564, 610, 663, 678, 704, 706, 765, 770, 773, 1013, 1019, 1022, 1043, 1047
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->462
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->462
	
	return ();
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 98
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































