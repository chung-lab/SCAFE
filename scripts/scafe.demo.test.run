#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use Getopt::Long 'HelpMessage';
use Time::HiRes qw( time );
use File::Spec::Functions qw(rel2abs abs2rel);
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                                  ---> demo.test.run <---
                        <--- demo, run demo data for testing --->

 Description:
   This scripts test run for demo data in the ./demo/input dir. It runs user-selected workflows.
   Demo input data must be downloaded from using ./script/download.demo.input
   Genome reference hg19.gencode_v32lift37 must be downloaded using ./scripts/download.resources.genome

 Usage:
   demo.test.run [options] --run_outDir
   
   --run_outDir           <required> [string]  directory for the output test runs
   --workflow             (optional) [string]  comma delimited list of workflows, 
                                               or use 'all' to run all workflows.
                                               Available workflows includes,
                                               scafe.workflow.sc.subsample ---> workflow, single-cell mode, subsample ctss
                                               scafe.workflow.sc.solo ---> workflow, single-cell mode, process a single sample
                                               scafe.workflow.cm.aggregate ---> workflow, common mode, aggregate ctss of multiple samples
                                               scafe.workflow.bk.subsample ---> workflow, bulk mode, subsample ctss
                                               scafe.workflow.bk.solo ---> workflow, bulk mode, process a single sample
                                               (default=all)
   --overwrite            (optional) [yes/no]  erase run_outDir before running (default=no)

 Dependencies:
   R packages: 'ROCR','PRROC', 'caret', 'e1071', 'ggplot2', 'scales', 'reshape2'
   bigWigAverageOverBed
   bedGraphToBigWig
   bedtools
   samtools
   paraclu
   paraclu-cut.sh

 For demo, cd to SCAFE dir and run,
   scafe.demo.test.run \
   --overwrite=yes \
   --run_outDir=./demo/output/

=head1 VERSION

v0.9.0-beta [March 20, 2021]
	-Initial pre-release

v1.0.0-rc [June 6, 2022]
	-scafe.workflow.sc.pool and scafe.workflow.bk.pool are obsolete, will run scafe.workflow.cm.aggregate instead

v1.0.1 [June 26, 2022]
	-No update

=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startTasks
#
#<section ID="startTasks" num="0">
my $ARGV_ary_ref = [@ARGV];
my ($run_outDir, $workflow, $overwrite) = &readParameters();#->389
my ($user_workflow_hsh_ref) = &parseWorkflowChoice($workflow);#->313
my ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath) = &prepDir($run_outDir, $ARGV_ary_ref);#->361
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->288
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_run
#
#<section ID="run" num="1">
my $genome='hg19.gencode_v32lift37';
my $run_tag='demo';
my ($path_hsh_ref) = &define_path($run_outDir, $script_dir, $scafe_dir);#->159
my ($task_info_hsh_ref) = &define_task($genome, $path_hsh_ref, $run_tag, $run_outDir, $user_workflow_hsh_ref);#->187
&run_task($task_info_hsh_ref, $path_hsh_ref, $result_script_dir);#->424
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	general [n=3]:
#		currentTime, logCalledCMDAndScript, readParameters
#
#	unassigned [n=5]:
#		define_path, define_task, parseWorkflowChoice
#		prepDir, run_task
#
#====================================================================================================================================================#

sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: prepDir|361
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 0_startTasks|101
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 375
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub define_path {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_run|113
#	secondaryAppearInSection: >none
#	input: $run_outDir, $scafe_dir, $script_dir
#	output: $path_hsh_ref
#	toCall: my ($path_hsh_ref) = &define_path($run_outDir, $script_dir, $scafe_dir);
#	calledInLine: 118
#....................................................................................................................................................#

	my ($run_outDir, $script_dir, $scafe_dir) = @_;
	
	my $path_hsh_ref = {
		'script_dir' => $script_dir,
		'UMI_CB_ctss_bed_path' => $scafe_dir."/demo/input/sc.subsample/demo.UMI_CB.ctss.bed.gz",
		'run_cellbarcode_path' => $scafe_dir."/demo/input/sc.subsample/demo.barcodes.tsv.gz",
		'sc.run_bam_path' => $scafe_dir."/demo/input/sc.solo/demo.cellranger.bam",
		'lib_list_path' => $scafe_dir."/demo/input/cm.aggregate/lib_list_path.txt",
		'long_ctss_bed_path' => $scafe_dir."/demo/input/bk.subsample/demo.long.ctss.bed.gz",
		'bk.run_bam_path' => $scafe_dir."/demo/input/bk.solo/demo.CAGE.bam",
	};

	return ($path_hsh_ref);

}
sub define_task {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_run|113
#	secondaryAppearInSection: >none
#	input: $genome, $path_hsh_ref, $run_outDir, $run_tag, $user_workflow_hsh_ref
#	output: $task_info_hsh_ref
#	toCall: my ($task_info_hsh_ref) = &define_task($genome, $path_hsh_ref, $run_tag, $run_outDir, $user_workflow_hsh_ref);
#	calledInLine: 119
#....................................................................................................................................................#

	my ($genome, $path_hsh_ref, $run_tag, $run_outDir, $user_workflow_hsh_ref) = @_;
	
	my $task_num = 0;
	my $task_info_hsh_ref = {};

	foreach my $workflow_choice (sort keys %{$user_workflow_hsh_ref}) {
		$task_num++;
		if ($workflow_choice eq 'scafe.workflow.cm.aggregate') {
			$task_info_hsh_ref->{$task_num} = {
				'task_name' => 'cm.aggregate',
				'script_name' => 'scafe.workflow.cm.aggregate',
				'task_log_path' => $run_outDir."/cm.aggregate/script/task.log.txt",
				'param' => [
					['overwrite', 'yes'],
					['lib_list_path', $path_hsh_ref->{'lib_list_path'}],
					['genome', $genome],
					['run_tag', $run_tag],
					['run_outDir', $run_outDir."/cm.aggregate"],
				],
			};

		} elsif ($workflow_choice eq 'scafe.workflow.bk.solo') {
			$task_info_hsh_ref->{$task_num} = {
				'task_name' => 'bk.solo',
				'script_name' => 'scafe.workflow.bk.solo',
				'task_log_path' => $run_outDir."/bk.solo/script/task.log.txt",
				'param' => [
					['overwrite', 'yes'],
					['run_bam_path', $path_hsh_ref->{'bk.run_bam_path'}],
					['genome', $genome],
					['run_tag', $run_tag],
					['run_outDir', $run_outDir."/bk.solo"],
				],
			};

		} elsif ($workflow_choice eq 'scafe.workflow.bk.subsample') {
			$task_info_hsh_ref->{$task_num} = {
				'task_name' => 'bk.subsample',
				'script_name' => 'scafe.workflow.bk.subsample',
				'task_log_path' => $run_outDir."/bk.subsample/script/task.log.txt",
				'param' => [
					['overwrite', 'yes'],
					['long_ctss_bed_path', $path_hsh_ref->{'long_ctss_bed_path'}],
					['subsample_num', 100000],
					['genome', $genome],
					['run_tag', $run_tag],
					['run_outDir', $run_outDir."/bk.subsample"],
				],
			};

		} elsif ($workflow_choice eq 'scafe.workflow.sc.solo') {
			$task_info_hsh_ref->{$task_num} = {
				'task_name' => 'sc.solo',
				'script_name' => 'scafe.workflow.sc.solo',
				'task_log_path' => $run_outDir."/sc.solo/script/task.log.txt",
				'param' => [
					['overwrite', 'yes'],
					['run_bam_path', $path_hsh_ref->{'sc.run_bam_path'}],
					['run_cellbarcode_path', $path_hsh_ref->{'run_cellbarcode_path'}],
					['genome', $genome],
					['run_tag', $run_tag],
					['run_outDir', $run_outDir."/sc.solo"],
				],
			};

		} elsif ($workflow_choice eq 'scafe.workflow.sc.subsample') {
			$task_info_hsh_ref->{$task_num} = {
				'task_name' => 'sc.subsample',
				'script_name' => 'scafe.workflow.sc.subsample',
				'task_log_path' => $run_outDir."/sc.subsample/script/task.log.txt",
				'param' => [
					['overwrite', 'yes'],
					['UMI_CB_ctss_bed_path', $path_hsh_ref->{'UMI_CB_ctss_bed_path'}],
					['run_cellbarcode_path', $path_hsh_ref->{'run_cellbarcode_path'}],
					['subsample_num', 100000],
					['genome', $genome],
					['run_tag', $run_tag],
					['run_outDir', $run_outDir."/sc.subsample"],
				],
			};
		
		} else {
			die "Undefined workflow parameters\n";
		}
	}
	
	return($task_info_hsh_ref);
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|101
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 108
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub parseWorkflowChoice {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|101
#	secondaryAppearInSection: >none
#	input: $workflow
#	output: $user_workflow_hsh_ref
#	toCall: my ($user_workflow_hsh_ref) = &parseWorkflowChoice($workflow);
#	calledInLine: 106
#....................................................................................................................................................#
	my ($workflow) = @_;
	
	my $user_workflow_hsh_ref = {};
	my $available_workflow_hsh_ref = {
		'scafe.workflow.sc.subsample' => '1',
		'scafe.workflow.sc.solo' => '1',
		'scafe.workflow.cm.aggregate' => '1',
		'scafe.workflow.bk.subsample' => '1',
		'scafe.workflow.bk.solo' => '1',
	};
	print "\n";
	print "#=======================#\n";
	print "Start running demo test\n";
	print "#=======================#\n";
	print "\n";
	
	if ($workflow eq 'all') {
		print "Adding all available workflow choices\n";
		foreach my $workflow_choice (keys %{$available_workflow_hsh_ref}) {
			$user_workflow_hsh_ref->{$workflow_choice}++;
			print "$workflow_choice added\n";
		}
	} else {
		print "Adding user defined workflow choices\n";
		foreach my $workflow_choice (split /,/, $workflow) {
			$user_workflow_hsh_ref->{$workflow_choice}++ if exists $available_workflow_hsh_ref->{$workflow_choice};
			print "$workflow_choice added\n";
		}
	}
	
	my $num_workflow = keys %{$user_workflow_hsh_ref};
	die "No workflow selected\n" if $num_workflow == 0;
	
	return ($user_workflow_hsh_ref);
}
sub prepDir {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: currentTime|141
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|101
#	secondaryAppearInSection: >none
#	input: $ARGV_ary_ref, $run_outDir
#	output: $ARGVStr, $result_script_dir, $scafe_dir, $scriptAbsPath, $script_dir
#	toCall: my ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath) = &prepDir($run_outDir, $ARGV_ary_ref);
#	calledInLine: 107
#....................................................................................................................................................#
	my ($run_outDir, $ARGV_ary_ref) = @_;

	my $scriptAbsPath = abs_path($0);
	my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @{$ARGV_ary_ref});#->141
	my @path_split = split /\//, $scriptAbsPath;
	my $scafe_dir_index = $#path_split-2;
	my $script_dir_index = $#path_split-1;
	my $scafe_dir = join "/", @path_split[0..$scafe_dir_index];
	my $script_dir = join "/", @path_split[0..$script_dir_index];

	my @mkDirAry;
	my $result_script_dir = "$run_outDir/script/"; push @mkDirAry, $result_script_dir;
	foreach my $dir (@mkDirAry) {system ("mkdir -pm 755 $dir");}

	return ($scafe_dir, $script_dir, $result_script_dir, $ARGVStr, $scriptAbsPath);
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startTasks|101
#	secondaryAppearInSection: >none
#	input: none
#	output: $overwrite, $run_outDir, $workflow
#	toCall: my ($run_outDir, $workflow, $overwrite) = &readParameters();
#	calledInLine: 105
#....................................................................................................................................................#
	
	my ($run_outDir, $workflow, $overwrite);
	
	$overwrite = 'no';
	$workflow = 'all';

	GetOptions 	(
		"workflow:s"		=>	\$workflow,
		"run_outDir=s"		=>	\$run_outDir,
		"overwrite:s"		=>	\$overwrite,
		'help'				=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $run_outDir;

	system "rm -rf $run_outDir" if ($overwrite eq 'yes');

	chop $run_outDir if ($run_outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $run_outDir/";
	
	return($run_outDir, $workflow, $overwrite);

}
sub run_task {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 1_run|113
#	secondaryAppearInSection: >none
#	input: $path_hsh_ref, $result_script_dir, $task_info_hsh_ref
#	output: none
#	toCall: &run_task($task_info_hsh_ref, $path_hsh_ref, $result_script_dir);
#	calledInLine: 120
#....................................................................................................................................................#
	
	my ($task_info_hsh_ref, $path_hsh_ref, $result_script_dir) = @_;
	
	my $task_log_info_hsh_ref = {};
	
	foreach my $task_num (sort {$a <=> $b} keys %{$task_info_hsh_ref}) {
		my $task_name = $task_info_hsh_ref->{$task_num}{'task_name'};
		my $script_name = $task_info_hsh_ref->{$task_num}{'script_name'};
		my $task_log_path = $task_info_hsh_ref->{$task_num}{'task_log_path'};
		my $script_path = $path_hsh_ref->{'script_dir'}.'/'.$script_name;
		die "script of $task_name does not exist at $script_path\n" if not -s $script_path;
		my @cmd_param_ary = ($script_path);
		foreach my $indiv_param_ary_ref (@{$task_info_hsh_ref->{$task_num}{'param'}}) {
			my ($param_name, $param_val) = @{$indiv_param_ary_ref};
			if (defined $param_val) {#---[2020/10/07 20:32] specifically for skipping training_signal_path if not input
				push @cmd_param_ary, "--$param_name=$param_val";
			}
		}
		my $cmd = join " ", @cmd_param_ary;
		system "$cmd";
		
		open (TASKLOG, "<", $task_log_path);
		while (<TASKLOG>) {
			chomp;
			my ($workflow_task_num, $workflow_task_name, $workflow_script_name, $status, $time) = split /\t/;
			$task_log_info_hsh_ref->{$script_name}{$workflow_task_num} = [$workflow_task_name, $workflow_script_name, $status, $time];
		}
		close TASKLOG;
	}
	
	print "\n";
	print "#=======================#\n";
	print "Results of Demo Test Run.\n";
	print "#=======================#\n";
	print "\n";
	
	printf ("%-30s %-35s %-10s\n", 'workflow', 'tool', 'status');
	printf ("%-30s %-35s %-10s\n", '==============', '==============', '==============');
	foreach my $script_name (sort keys %{$task_log_info_hsh_ref}) {
		foreach my $workflow_task_num (sort {$a <=> $b} keys %{$task_log_info_hsh_ref->{$script_name}}) {
			my ($workflow_task_name, $workflow_script_name, $status, $time) = @{$task_log_info_hsh_ref->{$script_name}{$workflow_task_num}};
			if ($status ne 'started') {
				printf ("%-30s %-35s %-10s\n", $script_name, $workflow_script_name, $status);
			}
		}
	}
	
}

exit;


















































