#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use List::Util qw (sum shuffle min max);
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                                   ---> scafe.tool.cm.directionality <---
                      <--- tool, common mode, calculate directionality of tCREs --->

 Description:
   This tool counts the ctss within tCREs and calculate their strand bias (i.e. directionality)

 Usage:
   scafe.tool.cm.directionality [options] --CRE_bed_path --CRE_info_path --ctss_bed_path --outputPrefix --outDir
   
   --CRE_bed_path           <required> [string] bed file contains the tCRE ranges, 
                                                *.CRE.coord.bed.gz from scafe.tool.cm.annotate
   --CRE_info_path          <required> [string] information table of tCRE, 
                                                *.CRE.info.tsv.gz from scafe.tool.cm.annotate
   --ctss_bed_path          <required> [string] ctss file for counting,
                                                *collapse.ctss.bed.gz from scafe.tool.sc.bam_to_ctss, 
                                                5th column is number of read
   --ctss_scope_bed_path    <optional> [string] bed file contains the regions for filtering CTSS, e.g. tssCluster ranges, 
                                                so only the ctss within these ranges (i.e. scope) will be count. This is to 
                                                prevent over permissive counting to ctss in the CRE range by stricting only 
                                                ctss within valid tssClusters to be counted. 
                                                *.tssCluster.default.filtered.bed.gz from scafe.tool.cm.filter.
                                                It will skip filtering if not file was provide (default=null).
   --outputPrefix           <required> [string] prefix for the output files
   --outDir                 <required> [string] directory for the output files
   --overwrite              (optional) [yes/no] erase outDir/outputPrefix before running (default=no)

 Dependencies:
   bedtools

 For demo, cd to SCAFE dir and run,
   scafe.tool.cm.directionality \
   --overwrite=yes \
   --CRE_bed_path=./demo/output/sc.solo/annotate/demo/bed/demo.CRE.coord.bed.gz \
   --CRE_info_path=./demo/output/sc.solo/annotate/demo/log/demo.CRE.info.tsv.gz \
   --ctss_bed_path=./demo/output/sc.solo/bam_to_ctss/demo/bed/demo.collapse.ctss.bed.gz \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.solo/directionality/

=head1 VERSION

v0.9.0-beta [March 20, 2021]
	-Non-exists

v1.0.0 [June 6, 2022]
	-Initial pre-release

v1.0.1 [June 26, 2022]
	-No update

=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->1028
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->383
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($CRE_bed_path, $ctss_bed_path, $CRE_info_path, $ctss_scope_bed_path, $overwrite, $outputPrefix, $outDir) = &readParameters();#->955
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $paramTag = "$outputPrefix";
my $filter_ctss = 'no';
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineOutDirPath
#
#<section ID="defineOutDirPath" num="2">
my @mkDirAry;
my $result_dir = "$outDir/$paramTag/"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $result_bed_dir = "$result_dir/bed/"; push @mkDirAry, $result_bed_dir;
my $result_log_dir = "$result_dir/log/"; push @mkDirAry, $result_log_dir;
my $result_script_dir = "$result_dir/script/"; push @mkDirAry, $result_script_dir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 777 $dir");}
open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->662
&printStartOrFinishMessage("startMessage");#->885
my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();#->255
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_output
#
#<section ID="output" num="3">
my ($CRE_info_hsh_ref) = &readCREInfo($CRE_info_path);#->919
&getCREBed($CRE_info_hsh_ref, $CRE_bed_path);#->565
my ($count_ctss_bed_path) = &generateCountCtss($ctss_bed_path, $ctss_scope_bed_path, $bedtools_bin, $result_bed_dir);#->468
&getSummitMidpoint($count_ctss_bed_path, $CRE_bed_path, $CRE_info_hsh_ref, $bedtools_bin);#->601
&defineOritentation($CRE_info_hsh_ref);#->401
my ($count_range_bed_path) = &generateCountRange($result_bed_dir, $CRE_info_hsh_ref);#->493
&countRegCtss($count_ctss_bed_path, $count_range_bed_path, $CRE_info_hsh_ref, $bedtools_bin);#->355
&calculateDirectionality($CRE_info_hsh_ref);#->201
&printDirectionality($CRE_info_hsh_ref, $result_log_dir, $paramTag);#->719
&printCREBed($CRE_info_hsh_ref, $result_bed_dir, $paramTag);#->686
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_finishingTasks
#
#<section ID="finishingTasks" num="4">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->770
&printStartOrFinishMessage("finishMessage");#->885
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	general [n=5]:
#		currentTime, logCalledCMDAndScript, printStartOrFinishMessage
#		readParameters, timeStamp
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=11]:
#		calculateDirectionality, checkAllExecutable, countRegCtss
#		defineOritentation, generateCountCtss, generateCountRange
#		getCREBed, getSummitMidpoint, printCREBed
#		printDirectionality, readCREInfo
#
#====================================================================================================================================================#

sub calculateDirectionality {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1006
#	appearInSub: >none
#	primaryAppearInSection: 3_output|147
#	secondaryAppearInSection: >none
#	input: $CRE_info_hsh_ref
#	output: 
#	toCall: &calculateDirectionality($CRE_info_hsh_ref);
#	calledInLine: 157
#....................................................................................................................................................#
	my ($CRE_info_hsh_ref) = @_;
	
	&reportAndLogStatus("Calculating directionality", 10, "\n");#->1006
	
	foreach my $CREID (keys %{$CRE_info_hsh_ref}) {
		my $orientation = $CRE_info_hsh_ref->{$CREID}{'orientation'};
		my $directionality;
		my $fwd_count = $CRE_info_hsh_ref->{$CREID}{'reg_count'}{'+'};
		my $rev_count = $CRE_info_hsh_ref->{$CREID}{'reg_count'}{'-'};
		
		if ($orientation eq "unidirectional") {
			$directionality = 0;
		} else {

			my $strand_diff = abs($fwd_count-$rev_count);
			my $strand_sum = $fwd_count+$rev_count;
			
			if ($strand_sum == 0) {
				$directionality = 999;
				
			} else {
				$directionality = 1-($strand_diff/$strand_sum);
				$directionality = -1*$directionality if $orientation eq 'convergent';
			}
		}
		
		my $bias_strand;
		if ($rev_count == $fwd_count) {
			$bias_strand = '.';
		} elsif ($rev_count > $fwd_count) {
			$bias_strand = '-';
		} elsif ($rev_count < $fwd_count) {
			$bias_strand = '+';
		}
		
		$CRE_info_hsh_ref->{$CREID}{'directionality'} = $directionality;
		$CRE_info_hsh_ref->{$CREID}{'bias_strand'} = $bias_strand;
		
	}

	return ();
}
sub checkAllExecutable {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1006
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|129
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedGraphToBigWig_bin, $bedtools_bin, $bgzip_bin, $bigWigAverageOverBed_bin, $cut_sh_path, $paraclu_bin, $samtools_bin, $tabix_bin
#	toCall: my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();
#	calledInLine: 142
#....................................................................................................................................................#
	
	my $dirPath = dirname(rel2abs($0));

	my $tabix_bin = "$dirPath/../resources/bin/tabix/tabix";
	my $bgzip_bin = "$dirPath/../resources/bin/bgzip/bgzip";
	my $bedtools_bin = "$dirPath/../resources/bin/bedtools/bedtools";
	my $samtools_bin = "$dirPath/../resources/bin/samtools/samtools";
	my $paraclu_bin = "$dirPath/../resources/bin/paraclu/paraclu";
	my $cut_sh_path = "$dirPath/../resources/bin/paraclu/paraclu-cut.sh";
	my $bedGraphToBigWig_bin = "$dirPath/../resources/bin/bedGraphToBigWig/bedGraphToBigWig";
	my $bigWigAverageOverBed_bin = "$dirPath/../resources/bin/bigWigAverageOverBed/bigWigAverageOverBed";
	
	&reportAndLogStatus("Checking all SCAFE executables", 10, "\n");#->1006
	
	{
		my $stdOut = `$tabix_bin  --version 2>&1`;
		if ($stdOut =~ m/tabix \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: tabix version: $1", 0, "\n");#->1006
		} else {
			die "tabix is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bgzip_bin --version 2>&1`;
		if ($stdOut =~ m/bgzip \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: bgzip version: $1", 0, "\n");#->1006
		} else {
			die "bgzip is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedtools_bin --version 2>&1`;
		if ($stdOut =~ m/bedtools v(\S+)/) {
			&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->1006
		} else {
			die "bedtools is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$samtools_bin 2>&1`;
		if ($stdOut =~ m/\s+(Version: \S+)\s+/) {
			&reportAndLogStatus("Checking: samtools version: $1", 0, "\n");#->1006
		} else {
			die "samtools is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$paraclu_bin 2>&1`;
		if ($stdOut =~ m/paraclu: I need a minValue and a fileName/) {
			&reportAndLogStatus("Checking: paraclu found.", 0, "\n");#->1006
		} else {
			die "paraclu is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$cut_sh_path 55C7128A 2>&1`;
		if ($stdOut =~ m/awk:/) {
			&reportAndLogStatus("Checking: paraclu-cut found.", 0, "\n");#->1006
		} else {
			die "paraclu-cut is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedGraphToBigWig_bin 2>&1`;
		if ($stdOut =~ m/bedGraphToBigWig v (\S+)/) {
			&reportAndLogStatus("Checking: bedGraphToBigWig version: $1", 0, "\n");#->1006
		} else {
			die "bedGraphToBigWig not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bigWigAverageOverBed_bin 2>&1`;
		if ($stdOut =~ m/bigWigAverageOverBed v(\S+)/) {
			&reportAndLogStatus("Checking: bigWigAverageOverBed version: $1", 0, "\n");#->1006
		} else {
			die "bigWigAverageOverBed is not installed properly. Quitting.\n";
		}
	}

	return ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin);
}
sub countRegCtss {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1006
#	appearInSub: >none
#	primaryAppearInSection: 3_output|147
#	secondaryAppearInSection: >none
#	input: $CRE_info_hsh_ref, $bedtools_bin, $count_ctss_bed_path, $count_range_bed_path
#	output: 
#	toCall: &countRegCtss($count_ctss_bed_path, $count_range_bed_path, $CRE_info_hsh_ref, $bedtools_bin);
#	calledInLine: 156
#....................................................................................................................................................#
	my ($count_ctss_bed_path, $count_range_bed_path, $CRE_info_hsh_ref, $bedtools_bin) = @_;
	
	&reportAndLogStatus("Getting CRE directionality", 10, "\n");#->1006

	open BEDTOOLS, "$bedtools_bin intersect -s -wo -a $count_range_bed_path -b $count_ctss_bed_path |";
	while (<BEDTOOLS>) {
		my @splt = split /\t/;
		my $CREID = $splt[3];
		my $strand = $splt[5];
		my $count = $splt[10];
		$CRE_info_hsh_ref->{$CREID}{'reg_count'}{$strand} += $count;
	}
	close BEDTOOLS;
	
	return ();
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|885, reportAndLogStatus|1006
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|129, 4_finishingTasks|164
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 101, 901, 905, 910, 914, 1022, 1023
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub defineOritentation {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1006
#	appearInSub: >none
#	primaryAppearInSection: 3_output|147
#	secondaryAppearInSection: >none
#	input: $CRE_info_hsh_ref
#	output: 
#	toCall: &defineOritentation($CRE_info_hsh_ref);
#	calledInLine: 154
#....................................................................................................................................................#
	my ($CRE_info_hsh_ref) = @_;
	
	&reportAndLogStatus("Defining orientation", 10, "\n");#->1006
	
	foreach my $CREID (keys %{$CRE_info_hsh_ref}) {
		my $num_strand_ctss = keys %{$CRE_info_hsh_ref->{$CREID}{'summit'}};
		my $orientation;
		my $abs_summit_diff;
		my $summit_center;
		
		if (exists $CRE_info_hsh_ref->{$CREID}{'summit'}{'.'}) {
			$orientation = 'undef';
			$abs_summit_diff = -1;
			$summit_center = -1;
			
		} else {
			if ($num_strand_ctss == 1) {
				$orientation = 'unidirectional';
				$abs_summit_diff = -1;
				my ($strand) = keys %{$CRE_info_hsh_ref->{$CREID}{'summit'}};
				$summit_center = $CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'pos'};
			} elsif ($num_strand_ctss == 2) {
				my $fwd_summit_pos = $CRE_info_hsh_ref->{$CREID}{'summit'}{'+'}{'pos'};
				my $rev_summit_pos = $CRE_info_hsh_ref->{$CREID}{'summit'}{'-'}{'pos'};

				$orientation = 'divergent';
				$orientation = 'convergent' if $rev_summit_pos > $fwd_summit_pos;
				$abs_summit_diff = abs($fwd_summit_pos - $rev_summit_pos);
				my ($left_summit, $right_summit) = sort {$a <=> $b} ($fwd_summit_pos, $rev_summit_pos);
				$summit_center = int($left_summit + ($abs_summit_diff/2));
			} else {
				die;
			}
		}

		$CRE_info_hsh_ref->{$CREID}{'orientation'} = $orientation;
		$CRE_info_hsh_ref->{$CREID}{'abs_summit_diff'} = $abs_summit_diff;
		$CRE_info_hsh_ref->{$CREID}{'summit_center'} = $summit_center;

		if ($orientation eq 'unidirectional' or $orientation eq 'undef') {
			$CRE_info_hsh_ref->{$CREID}{'oritn_summit_diff'} = 0;

		} elsif ($orientation eq 'divergent') {
			$CRE_info_hsh_ref->{$CREID}{'oritn_summit_diff'} = $abs_summit_diff;

		} elsif ($orientation eq 'convergent') {
			$CRE_info_hsh_ref->{$CREID}{'oritn_summit_diff'} = -1*$abs_summit_diff;

		} else {
			die;
		}
	}

	return ();
}
sub generateCountCtss {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1006
#	appearInSub: >none
#	primaryAppearInSection: 3_output|147
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $ctss_bed_path, $ctss_scope_bed_path, $result_bed_dir
#	output: $count_ctss_bed_path
#	toCall: my ($count_ctss_bed_path) = &generateCountCtss($ctss_bed_path, $ctss_scope_bed_path, $bedtools_bin, $result_bed_dir);
#	calledInLine: 152
#....................................................................................................................................................#
	my ($ctss_bed_path, $ctss_scope_bed_path, $bedtools_bin, $result_bed_dir) = @_;
	
	my $count_ctss_bed_path = "$result_bed_dir/count.ctss.bed.gz";
	if (defined $ctss_scope_bed_path) {
		&reportAndLogStatus("Filtering the ctss by tssCluster", 10, "\n");#->1006
		system "$bedtools_bin intersect -sorted -s -a $ctss_bed_path -b $ctss_scope_bed_path | gzip -c >$count_ctss_bed_path";
	} else {
		&reportAndLogStatus("using original ctss for counting", 10, "\n");#->1006
		$count_ctss_bed_path = $ctss_bed_path;
	}
	
	return ($count_ctss_bed_path);
}
sub generateCountRange {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1006
#	appearInSub: >none
#	primaryAppearInSection: 3_output|147
#	secondaryAppearInSection: >none
#	input: $CRE_info_hsh_ref, $result_bed_dir
#	output: $count_range_bed_path
#	toCall: my ($count_range_bed_path) = &generateCountRange($result_bed_dir, $CRE_info_hsh_ref);
#	calledInLine: 155
#....................................................................................................................................................#
	my ($result_bed_dir, $CRE_info_hsh_ref) = @_;
	
	&reportAndLogStatus("generating region count bed", 10, "\n");#->1006
	
	my $count_range_bed_path = "$result_bed_dir/count_range.bed.gz";
	$globalReadmeHsh_ref->{$count_range_bed_path}{'description'} = "Bed file contains the regions used to count signal, based on the summits on the two strands";
	open COUNTBED, "| sort -k1,1 -k2,2n | gzip -c >$count_range_bed_path";
	foreach my $CREID (keys %{$CRE_info_hsh_ref}) {
	
		next if (exists $CRE_info_hsh_ref->{$CREID}{'summit'}{'.'});
	
		my ($CRE_chrom, $CRE_start, $CRE_end) = @{$CRE_info_hsh_ref->{$CREID}{'bed'}};
		my $orientation = $CRE_info_hsh_ref->{$CREID}{'orientation'};

		my $strand_hsh_ref = {
			'+' => {
				'opposite_strand' => '-',
				'replace_end' => 'start',
			},
			'-' => {
				'opposite_strand' => '+',
				'replace_end' => 'end',
			},
		};
		
		foreach my $strand (keys %{$CRE_info_hsh_ref->{$CREID}{'summit'}}) {
			my $count_rng_hsh = {
				'start' => $CRE_start,
				'end' => $CRE_end,
			};
			
			my $opposite_strand = $strand_hsh_ref->{$strand}{'opposite_strand'};
			my $replace_end = $strand_hsh_ref->{$strand}{'replace_end'};

			if ($orientation ne 'unidirectional') {
				die if not exists $CRE_info_hsh_ref->{$CREID}{'summit'}{$opposite_strand}{'pos'};
				
				$count_rng_hsh->{$replace_end} = $CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'pos'};

				my $abs_summit_diff = $CRE_info_hsh_ref->{$CREID}{'abs_summit_diff'};

				if ($replace_end eq 'start') {
					$count_rng_hsh->{$replace_end} = $count_rng_hsh->{$replace_end} - $abs_summit_diff;
				} else {
					$count_rng_hsh->{$replace_end} = $count_rng_hsh->{$replace_end} + $abs_summit_diff;
				}
				
				$count_rng_hsh->{$replace_end}-- if $replace_end eq 'start';
			}

			$count_rng_hsh->{'start'} = $CRE_start if $count_rng_hsh->{'start'} < $CRE_start;
			$count_rng_hsh->{'end'} = $CRE_end if $count_rng_hsh->{'end'} > $CRE_end;
			
			print COUNTBED join "", (join "\t", ($CRE_chrom, $count_rng_hsh->{'start'}, $count_rng_hsh->{'end'}, $CREID, 0, $strand)), "\n";
		}
	}
	close COUNTBED;
	
	return ($count_range_bed_path);
}
sub getCREBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1006
#	appearInSub: >none
#	primaryAppearInSection: 3_output|147
#	secondaryAppearInSection: >none
#	input: $CRE_bed_path, $CRE_info_hsh_ref
#	output: 
#	toCall: &getCREBed($CRE_info_hsh_ref, $CRE_bed_path);
#	calledInLine: 151
#....................................................................................................................................................#
	my ($CRE_info_hsh_ref, $CRE_bed_path) = @_;
	
	&reportAndLogStatus("Getting CRE bed", 10, "\n");#->1006
	if ($CRE_bed_path =~ m/\.gz$/) {
		open (CRE, " gzip -dc $CRE_bed_path |");
	} else {
		open (CRE, "<", $CRE_bed_path);
	}
	while (<CRE>) {
		chomp;
		my ($chrom, $chromStart, $chromEnd, $CREID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts) = split /\t/;
		die "CREID $CREID does not exists\n" if not exists $CRE_info_hsh_ref->{$CREID};
		$CRE_info_hsh_ref->{$CREID}{'bed'} = [$chrom, $chromStart, $chromEnd, $CREID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts];
		$CRE_info_hsh_ref->{$CREID}{'chrom'} = $chrom;

	}
	close CRE;
	
	foreach my $CREID (keys %{$CRE_info_hsh_ref}) {
		die "CREID $CREID does not not have bed range\n" if not exists $CRE_info_hsh_ref->{$CREID}{'bed'};
	}

	return ();
}
sub getSummitMidpoint {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1006
#	appearInSub: >none
#	primaryAppearInSection: 3_output|147
#	secondaryAppearInSection: >none
#	input: $CRE_bed_path, $CRE_info_hsh_ref, $bedtools_bin, $count_ctss_bed_path
#	output: 
#	toCall: &getSummitMidpoint($count_ctss_bed_path, $CRE_bed_path, $CRE_info_hsh_ref, $bedtools_bin);
#	calledInLine: 153
#....................................................................................................................................................#
	my ($count_ctss_bed_path, $CRE_bed_path, $CRE_info_hsh_ref, $bedtools_bin) = @_;
	
	&reportAndLogStatus("Getting CRE summit and midpoint", 10, "\n");#->1006
	open BEDTOOLS, "$bedtools_bin intersect -wo -a $CRE_bed_path -b $count_ctss_bed_path |";
	while (<BEDTOOLS>) {
		my @splt = split /\t/;
		my $CREID = $splt[3];
		my $pos = $splt[14];
		my $score = $splt[16];
		my $strand = $splt[17];
		#chr11	17297903	17298404	chr11_17297903_17298404	61	.	17298303	17298304	106,61,154	1	501	0	chr1	17298288	17298289	1	1	+	1
		if (not exists $CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}) {
			$CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'score'} = $score;
			$CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'pos'} = $pos;
		} elsif ($score >= $CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'score'}) {

			if ($score > $CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'score'}) {

				$CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'score'} = $score;
				$CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'pos'} = $pos;

			} elsif ($score == $CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'score'}) {
				my $existing_pos = $CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'pos'};

				if ($strand eq '+' and $existing_pos < $pos) {
					$CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'pos'} = $pos;
				} elsif ($strand eq '-' and $existing_pos > $pos) {
					$CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'pos'} = $pos;
				}
				
			} else {
				die;
			}
		}
	}
	close BEDTOOLS;

	foreach my $CREID (keys %{$CRE_info_hsh_ref}) {
		if (not exists $CRE_info_hsh_ref->{$CREID}{'summit'}) {
			my $strand = '.';
			my $score = -1;
			my $pos = -1;
			$CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'score'} = $score;
			$CRE_info_hsh_ref->{$CREID}{'summit'}{$strand}{'pos'} = $pos;
		}
	}
	
	return ();
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|129
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 140
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;

	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub printCREBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1006
#	appearInSub: >none
#	primaryAppearInSection: 3_output|147
#	secondaryAppearInSection: >none
#	input: $CRE_info_hsh_ref, $paramTag, $result_bed_dir
#	output: 
#	toCall: &printCREBed($CRE_info_hsh_ref, $result_bed_dir, $paramTag);
#	calledInLine: 159
#....................................................................................................................................................#
	my ($CRE_info_hsh_ref, $result_bed_dir, $paramTag) = @_;
	
	&reportAndLogStatus("printing summit_center bed", 10, "\n");#->1006
	
	my $directionality_bed_path = "$result_bed_dir/$paramTag.CRE.directionality.summit_center.bed.gz";
	$globalReadmeHsh_ref->{$directionality_bed_path}{'description'} = "Bed file contains the original CRE ranges, with the thickEnd as the midpiont bewteen the summit of the two strands and the score as the directionality";

	open OUTBED, "| sort -k1,1 -k2,2n -k6,6 | gzip -c >$directionality_bed_path";
	foreach my $CREID (sort keys %{$CRE_info_hsh_ref}) {
		my ($chrom, $chromStart, $chromEnd, $CREID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts) = @{$CRE_info_hsh_ref->{$CREID}{'bed'}};
		my $directionality = $CRE_info_hsh_ref->{$CREID}{'directionality'};
		my $summit_center = $CRE_info_hsh_ref->{$CREID}{'summit_center'};
		$thickStart = $summit_center - 1;
		$thickEnd = $summit_center;
		$score = $directionality;
		print OUTBED join "", (join "\t", ($chrom, $chromStart, $chromEnd, $CREID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts)), "\n";
	}
	close OUTBED;

	return ();
}
sub printDirectionality {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_output|147
#	secondaryAppearInSection: >none
#	input: $CRE_info_hsh_ref, $paramTag, $result_log_dir
#	output: 
#	toCall: &printDirectionality($CRE_info_hsh_ref, $result_log_dir, $paramTag);
#	calledInLine: 158
#....................................................................................................................................................#
	my ($CRE_info_hsh_ref, $result_log_dir, $paramTag) = @_;
	
	my $directionality_log_path = "$result_log_dir/$paramTag.directionality.log.tsv.gz";
	open OUTLOG, "| gzip -c >$directionality_log_path";

	my @headerAry = ('CREID', 'directionality', 'orientation', 'bias_strand', 'fwd_count', 'rev_count', 'chrom', 'summit_center', 'abs_summit_diff', 'oritn_summit_diff');
	print OUTLOG join "", (join "\t", @headerAry), "\n";

	$globalReadmeHsh_ref->{$directionality_log_path}{'description'} = "Directionality information of CREs, with count and summit information on both strands";
	@{$globalReadmeHsh_ref->{$directionality_log_path}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$directionality_log_path}{'header'}{'CREID'} = '[unique ID] Identifier of the CRE';
	$globalReadmeHsh_ref->{$directionality_log_path}{'header'}{'directionality'} = '[-1 to 1] 0 is purely unidirectional, +ve value refers to divergently bidirectional, greater value more balanced e.g. 1 refers to perfectly balanced divergently bidirectional. -ve refers to convergent';
	$globalReadmeHsh_ref->{$directionality_log_path}{'header'}{'orientation'} = '[unidirectional, convergent or divergent] unidirectional when signal on only one strand, divergent when reverse strand signal summit is upstream of the forward strand signal summit, or convergent if opposite';
	$globalReadmeHsh_ref->{$directionality_log_path}{'header'}{'bias_strand'} = '[+,- or .] Dorminant strand (strand with higher signal), . if equal on both strand';
	$globalReadmeHsh_ref->{$directionality_log_path}{'header'}{'fwd_count'} = '[integer] count on the forward strand';
	$globalReadmeHsh_ref->{$directionality_log_path}{'header'}{'rev_count'} = '[integer] count on the reverse strand';
	$globalReadmeHsh_ref->{$directionality_log_path}{'header'}{'chrom'} = '[string] chromosome';
	$globalReadmeHsh_ref->{$directionality_log_path}{'header'}{'summit_center'} = '[integer] midpoint of the summit on two strands, or the summit itself if there is only signal on one strand';
	$globalReadmeHsh_ref->{$directionality_log_path}{'header'}{'abs_summit_diff'} = '[integer] absolute distance between the summit on the two strands';
	$globalReadmeHsh_ref->{$directionality_log_path}{'header'}{'oritn_summit_diff'} = '[string] distance between the summit on the two strands, +ve if divergent and -ve if convergent';

	foreach my $CREID (sort keys %{$CRE_info_hsh_ref}) {
		my $directionality = $CRE_info_hsh_ref->{$CREID}{'directionality'};
		my $fwd_count = $CRE_info_hsh_ref->{$CREID}{'reg_count'}{'+'};
		my $rev_count = $CRE_info_hsh_ref->{$CREID}{'reg_count'}{'-'};
		my $bias_strand = $CRE_info_hsh_ref->{$CREID}{'bias_strand'};
		my $orientation = $CRE_info_hsh_ref->{$CREID}{'orientation'};
		my $oritn_summit_diff = $CRE_info_hsh_ref->{$CREID}{'oritn_summit_diff'};
		my $abs_summit_diff = $CRE_info_hsh_ref->{$CREID}{'abs_summit_diff'};
		my $summit_center = $CRE_info_hsh_ref->{$CREID}{'summit_center'};
		my $chrom = $CRE_info_hsh_ref->{$CREID}{'chrom'};

		print OUTLOG join "", (join "\t", ($CREID, $directionality, $orientation, $bias_strand, $fwd_count, $rev_count, $chrom, $summit_center, $abs_summit_diff, $oritn_summit_diff)), "\n";
	}
	close OUTLOG;

	return ();
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_finishingTasks|164
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 167
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort {$a cmp $b} keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			my $headerColLen = max(@colLenCountHsh)+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}

	my $fileDir_colLen = max(@{$filelistLenCountHsh{'dir'}})+2;
	my $fileName_colLen = max(@{$filelistLenCountHsh{'name'}})+2;
	my $fileDescription_colLen = max(@{$filelistLenCountHsh{'description'}})+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|383
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|129, 4_finishingTasks|164
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 141, 168
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->383
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->383
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->383
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->383
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub readCREInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1006
#	appearInSub: >none
#	primaryAppearInSection: 3_output|147
#	secondaryAppearInSection: >none
#	input: $CRE_info_path
#	output: $CRE_info_hsh_ref
#	toCall: my ($CRE_info_hsh_ref) = &readCREInfo($CRE_info_path);
#	calledInLine: 150
#....................................................................................................................................................#
	my ($CRE_info_path) = @_;
	
	my $CRE_info_hsh_ref = {};

	&reportAndLogStatus("reading count region info", 0, "\n");#->1006
	if ($CRE_info_path =~ m/\.gz$/) {
		open (CRE, " gzip -dc $CRE_info_path |");
	} else {
		open (CRE, "<", $CRE_info_path);
	}
	<CRE>;
	while (<CRE>) {
		chomp;
		my ($CREID) = split /\t/;
		$CRE_info_hsh_ref->{$CREID}{'reg_count'}{'+'} = 0;
		$CRE_info_hsh_ref->{$CREID}{'reg_count'}{'-'} = 0;
	}
	close CRE;
	
	my $num_CRE = keys %{$CRE_info_hsh_ref};
	&reportAndLogStatus("info of $num_CRE CRE stored", 0, "\n");#->1006
		
	return ($CRE_info_hsh_ref);
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|112
#	secondaryAppearInSection: >none
#	input: none
#	output: $CRE_bed_path, $CRE_info_path, $ctss_bed_path, $ctss_scope_bed_path, $outDir, $outputPrefix, $overwrite
#	toCall: my ($CRE_bed_path, $ctss_bed_path, $CRE_info_path, $ctss_scope_bed_path, $overwrite, $outputPrefix, $outDir) = &readParameters();
#	calledInLine: 115
#....................................................................................................................................................#
	
	my ($CRE_bed_path, $ctss_bed_path, $CRE_info_path, $ctss_scope_bed_path, $overwrite, $outputPrefix, $outDir);
	
	$overwrite = 'no';
	$ctss_scope_bed_path = undef;
	
	GetOptions 	(
		"CRE_bed_path=s"				=>	\$CRE_bed_path,
		"CRE_info_path=s"				=>	\$CRE_info_path,
		"ctss_bed_path=s"				=>	\$ctss_bed_path,
		"outputPrefix=s"				=>	\$outputPrefix,
		"outDir=s"						=>	\$outDir,
		"ctss_scope_bed_path:s"		=>	\$ctss_scope_bed_path,
		"overwrite:s"					=>	\$overwrite,
		'help'							=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $CRE_bed_path;
	
	#---check file
	my $file_check_hsh_ref = {
		'CRE_bed_path' => $CRE_bed_path,
		'CRE_info_path' => $CRE_info_path,
		'ctss_bed_path' => $ctss_bed_path,
	};

	if (defined $ctss_scope_bed_path) {
		$file_check_hsh_ref->{'ctss_scope_bed_path'} = $ctss_scope_bed_path;
	}
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}
		
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
	
	return($CRE_bed_path, $ctss_bed_path, $CRE_info_path, $ctss_scope_bed_path, $overwrite, $outputPrefix, $outDir);
}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|383
#	appearInSub: calculateDirectionality|201, checkAllExecutable|255, countRegCtss|355, defineOritentation|401, generateCountCtss|468, generateCountRange|493, getCREBed|565, getSummitMidpoint|601, printCREBed|686, readCREInfo|919
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|129, 3_output|147
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 214, 278, 283, 292, 301, 310, 319, 328, 337, 346, 368, 414, 483, 486, 506, 578, 614, 699, 934, 950
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->383
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->383
	
	return ();
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 100
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































