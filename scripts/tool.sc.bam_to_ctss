#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use threads ('stack_size' => 64*4096);
use threads::shared;
use List::Util qw (sum shuffle min max);
use Cwd 'abs_path';
use Math::Round qw (nearest);
use AutoLoader qw/AUTOLOAD/;
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

                      O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                    O~~    O~~ O~~   O~~     O~ ~~     O~~      O~~       
                     O~~      O~~           O~  O~~    O~~      O~~       
                       O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                          O~~ O~~         O~~~~~A O~~  O~~      O~~       
                    O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                      O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA

                      Single Cell Analysis of Five'End (SCAFE) Tool Suite 
                               ---> tool.sc.bam_to_ctss <---
                     <--- tool, single-cell mode, convert bam to ctss --->

 Description:
   This tool converts a bam file to a ctss bed file, identifies read 5'end (capped TSS, i.e. ctss),
   extracts the unencoded G information, pileup ctss, and deduplicate the UMI

 Usage:
   tool.sc.bam_to_ctss [options] --bamPath --genome --outputPrefix --outDir
   
   --bamPath      <required> [string]  bam file from cellranger, can be read 1 only or pair-end
   --genome       <required> [string]  name of genome reference, e.g. hg19.gencode_v32lift37
   --outputPrefix <required> [string]  prefix for the output files
   --outDir       <required> [string]  directory for the output files
   --include_flag (optional) [string]  samflag to be included, comma delimited 
                                       e.g. '64' to include read1, (default=null)
   --exclude_flag (optional) [string]  samflag to be excluded, comma delimited, 
                                       e.g. '128,256,4' to exclude read2, secondary alignment 
                                       and unaligned reads (default=128,256,4)
   --min_MAPQ     (optional) [integer] minimum MAPQ to include (default=0)
   --max_thread   (optional) [integer] maximum number of parallel threads, capped at 10 to 
                                       avoid memory overflow (default=5)
   --TS_oligo_seq (optional) [string]  Template switching oligo sequence for identification of 
                                       5'end (default=TTTCTTATATGGG) 
   --overwrite    (optional) [yes/no]  erase outDir/outputPrefix before running (default=no)

 Dependencies:
   bedtools
   samtools

 For demo, cd to SCAFE dir and run,
   ./scripts/tool.sc.bam_to_ctss \
   --overwrite=yes \
   --bamPath=./demo/input/sc.solo/demo.cellranger.bam \
   --genome=hg19.gencode_v32lift37 \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.solo/bam_to_ctss/

=head1 VERSION

1.0

=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->1403
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->428
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($bamPath, $exclude_flag, $include_flag, $min_MAPQ, $max_thread, $TS_oligo_seq, $genome, $outputPrefix, $outDir, $overwrite) = &readParameters();#->1328
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $paramTag = "$outputPrefix";
my $rm_tmp_file = 'yes';
my $sanity_check_toggle = 'yes';
my $num_chunk = 100;
my $TS_oligo_check_tail_length = 5;
my $max_mismatch = 1;
my $regex_match_margin = 5;
my $softclip_margin = 7;
my $min_match_length = 5;
my $max_non_G_mismatch = 2;
$max_thread = 10 if $max_thread > 10;
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineOutDirPath
#
#<section ID="defineOutDirPath" num="2">
my @mkDirAry;
my $result_dir = "$outDir/$paramTag"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $result_bed_dir = "$result_dir/bed/"; push @mkDirAry, $result_bed_dir;
my $result_log_dir = "$result_dir/log/"; push @mkDirAry, $result_log_dir;
my $result_script_dir = "$result_dir/script/"; push @mkDirAry, $result_script_dir;
my $result_tmp_dir = "$result_dir/tmp/"; push @mkDirAry, $result_tmp_dir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 777 $dir");}

open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->818
&printStartOrFinishMessage("startMessage");#->1199
my ($samtools_bin) = &checkSamtoolsVersion();#->288
my ($bedtools_bin) = &checkBedtoolsVersion();#->210
my ($chrom_name_path, $chrom_size_path, $genome_fasta_path) = &checkChromNameSizeGenomeFastaPath($genome);#->241
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_convert
#
#<section ID="convert" num="3">
my ($chrom_name_size_hsh_ref, $out_chrom_size_hsh_ref) = &generateChromNameConversionHsh($chrom_name_path, $chrom_size_path, $samtools_bin, $bamPath);#->446
my ($chunk_size) = &generateChunkSize($out_chrom_size_hsh_ref, $num_chunk);#->570
my ($chunk_info_hsh_ref) = &generateChunkInfoHsh($chrom_name_size_hsh_ref, $chunk_size, $result_tmp_dir);#->516
&processPerChunk($bamPath, $bedtools_bin, $samtools_bin, $max_thread, $chunk_info_hsh_ref, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $min_MAPQ, $TS_oligo_seq, $genome_fasta_path, $out_chrom_size_hsh_ref, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch);#->1233
&poolChunkResults($chunk_info_hsh_ref, $result_bed_dir, $result_log_dir, $paramTag, $result_tmp_dir, $rm_tmp_file);#->958
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_finishingTasks
#
#<section ID="finishingTasks" num="4">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->1084
&printStartOrFinishMessage("finishMessage");#->1199
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	checkTools [n=2]:
#		checkBedtoolsVersion, checkSamtoolsVersion
#
#	general [n=7]:
#		checkBedtoolsVersion, checkSamtoolsVersion, currentTime
#		logCalledCMDAndScript, printStartOrFinishMessage, readParameters
#		timeStamp
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	specific [n=1]:
#		convertBamToCTSS
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=11]:
#		checkChromNameSizeGenomeFastaPath, checkChunkResults, generateChromNameConversionHsh
#		generateChunkInfoHsh, generateChunkSize, generateMisMatchRegex
#		getCTSS, getChunkFasta, pileupCBDedupUMI
#		poolChunkResults, processPerChunk
#
#====================================================================================================================================================#

sub checkBedtoolsVersion {
#....................................................................................................................................................#
#	subroutineCategory: general, checkTools
#	dependOnSub: reportAndLogStatus|1381
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|132
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedtools_bin
#	toCall: my ($bedtools_bin) = &checkBedtoolsVersion();
#	calledInLine: 148
#....................................................................................................................................................#

	my $dirPath = dirname(rel2abs($0));

	my $bedtools_bin = "bedtools";
	
	my $stdOut = `$bedtools_bin --version 2>&1`;
	if ($stdOut =~ m/bedtools v(\S+)/) {
		&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->1381
	} else {
		$bedtools_bin = "$dirPath/../resources/bin/bedtools/bedtools";
		if ($stdOut =~ m/bedtools v(\S+)/) {
			&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->1381
		} else {
			die "bedtools not installed properly. Quitting.\n";
		}
	}
	
	return($bedtools_bin);
}
sub checkChromNameSizeGenomeFastaPath {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|132
#	secondaryAppearInSection: >none
#	input: $genome
#	output: $chrom_name_path, $chrom_size_path, $genome_fasta_path
#	toCall: my ($chrom_name_path, $chrom_size_path, $genome_fasta_path) = &checkChromNameSizeGenomeFastaPath($genome);
#	calledInLine: 149
#....................................................................................................................................................#
	my ($genome) = @_;
	
	my $dirPath = dirname(rel2abs($0));
	my $chrom_name_path = "$dirPath/../resources/genome/$genome/tsv/chrom.bam_name.tsv";
	my $chrom_size_path = "$dirPath/../resources/genome/$genome/tsv/chrom.sizes.tsv";
	my $genome_fasta_path = "$dirPath/../resources/genome/$genome/fasta/genome.fa";
	die "genome $genome does not have chrom_name_path. Please rerun prep_genome step\n" if not -s $chrom_name_path;
	die "genome $genome does not have chrom_size_path. Please rerun prep_genome step\n" if not -s $chrom_size_path;
	die "genome $genome does not have genome_fasta_path. Please rerun prep_genome step\n" if not -s $genome_fasta_path;
	
	return ($chrom_name_path, $chrom_size_path, $genome_fasta_path);
}
sub checkChunkResults {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1381
#	appearInSub: poolChunkResults|958, processPerChunk|1233
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_convert|154
#	input: $chunk_info_hsh_ref, $chunk_num, $file_check_ary_ref
#	output: $valid
#	toCall: my ($valid) = &checkChunkResults($chunk_info_hsh_ref, $chunk_num, $file_check_ary_ref);
#	calledInLine: 992, 1271
#....................................................................................................................................................#
	my ($chunk_info_hsh_ref, $chunk_num, $file_check_ary_ref) = @_;
	
	my $valid = 'yes';
	foreach my $file_to_check (@{$file_check_ary_ref}) {
		my $file_path =  $chunk_info_hsh_ref->{$chunk_num}{$file_to_check};
		#&reportAndLogStatus("$file_path", 10, "\n");#->1381
		$valid = 'no' if not -f $file_path;
	}
	
	return ($valid);
}
sub checkSamtoolsVersion {
#....................................................................................................................................................#
#	subroutineCategory: general, checkTools
#	dependOnSub: reportAndLogStatus|1381
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|132
#	secondaryAppearInSection: >none
#	input: none
#	output: $samtools_bin
#	toCall: my ($samtools_bin) = &checkSamtoolsVersion();
#	calledInLine: 147
#....................................................................................................................................................#
	
	my $dirPath = dirname(rel2abs($0));
	my $samtools_bin = "samtools";
	
	my $stdOut = `$samtools_bin 2>&1`;
	if ($stdOut =~ m/\s+(Version: \S+)\s+/) {
		&reportAndLogStatus("Checking: samtools version: $1", 0, "\n");#->1381
	} else {
		$samtools_bin = "$dirPath/../resources/bin/samtools/samtools";
		if ($stdOut =~ m/\s+(Version: \S+)\s+/) {
		&reportAndLogStatus("Checking: samtools version: $1", 0, "\n");#->1381
		} else {
			die "samtools not installed properly. Quitting.\n";
		}
	}
	
	return($samtools_bin);
}
sub convertBamToCTSS {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: generateMisMatchRegex|595, getCTSS|647, reportAndLogStatus|1381
#	appearInSub: processPerChunk|1233
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_convert|154
#	input: $TS_oligo_check_tail_length, $TS_oligo_seq, $bamPath, $bedtools_bin, $chrom_name_size_hsh_ref, $chunk_UMI_CB_ctss_bed_path, $chunk_endPos, $chunk_fasta_offset_pos, $chunk_fasta_path, $chunk_log_path, $chunk_sanity_check_path, $chunk_seq_str, $chunk_startPos, $chunk_unsort_UMI_CB_ctss_bed_path, $exclude_flag, $include_flag, $max_mismatch, $max_non_G_mismatch, $min_MAPQ, $min_match_length, $regex_match_margin, $region_str, $samtools_bin, $sanity_check_toggle, $softclip_margin
#	output: 
#	toCall: &convertBamToCTSS($bamPath, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $bedtools_bin, $samtools_bin, $min_MAPQ, $chunk_UMI_CB_ctss_bed_path, $chunk_unsort_UMI_CB_ctss_bed_path, $region_str, $chunk_log_path, $chunk_startPos, $chunk_endPos, $TS_oligo_seq, $chunk_fasta_path, $chunk_seq_str, $chunk_fasta_offset_pos, $chunk_sanity_check_path, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch);
#	calledInLine: 1292
#....................................................................................................................................................#
	my ($bamPath, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $bedtools_bin, $samtools_bin, $min_MAPQ, $chunk_UMI_CB_ctss_bed_path, $chunk_unsort_UMI_CB_ctss_bed_path, $region_str, $chunk_log_path, $chunk_startPos, $chunk_endPos, $TS_oligo_seq, $chunk_fasta_path, $chunk_seq_str, $chunk_fasta_offset_pos, $chunk_sanity_check_path, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch) = @_;
	
	if (not -s $chunk_UMI_CB_ctss_bed_path) {
		#&reportAndLogStatus("converting $paramTag bam to ctss bed", 10, "\n");#->1381
		my $perl_covert_readname = 'while (<STDIN>) {chomp; @samAry = split /\t/;if ($_ =~ m/\tCB:Z:([^\t]+)\t.+\tUB:Z:([^\t]+)/) {$samAry[0] = $1."_".$2."_".$samAry[9];print join "", (join "\t", @samAry[0..10]), "\n";} elsif ($_ =~ m/^\@/) {print "$_\n";}};';
		my $margin = 20;
		my $minLen = 30;
		my $maxLen = 300;
		my $num_proc = 0;
		my $ex_F_param = '';
		my $in_f_param = '';
		if (defined $exclude_flag) {
			my @flagAry = ();
			foreach my $flag (split /,/, $exclude_flag) {
				push @flagAry, "-F $flag";
			}
			$ex_F_param = join " ", @flagAry;
		}

		if (defined $include_flag) {
			my @flagAry = ();
			foreach my $flag (split /,/, $include_flag) {
				push @flagAry, "-f $flag";
			}
			$in_f_param = join " ", @flagAry;
		}

		#---[6/18/15 14:23] get all
		open (BAMIN, "$samtools_bin view -h $in_f_param $ex_F_param $bamPath $region_str 2>/dev/null | perl -e \'$perl_covert_readname\' | $samtools_bin view -b - | $bedtools_bin bamtobed -cigar -i stdin |");
		#open (CTSSOUT, "| sort -k1,1 -k2,2n -k6,6 >$chunk_UMI_CB_ctss_bed_path");
		open (CTSSOUT, ">", $chunk_unsort_UMI_CB_ctss_bed_path);
		open SANITYCHECK, ">", $chunk_sanity_check_path;
		print SANITYCHECK join "", (join "\t", ('out_chrom', 'bedStart', 'bedEnd', 'strand', 'rd_seq', 'check_read_seq', 'check_genome_seq', 'cigar', 'softclip_length', 'match_length', 'check_read_pos', 'trim_length', 'num_unencoded_G', 'non_G_mismatch')), "\n";

		my $TS_oligo_length = length $TS_oligo_seq;
		my $check_TS_oligo_substr = -1*$TS_oligo_check_tail_length;

		my $check_TS_oligo_seq = substr $TS_oligo_seq, $check_TS_oligo_substr;
		
		my $min_softclip_length = $TS_oligo_length - $softclip_margin;
		my $max_softclip_length = $TS_oligo_length + $softclip_margin;
		my $min_regex_match_pos = $TS_oligo_length - $regex_match_margin;
		my $max_regex_match_pos = $TS_oligo_length + $regex_match_margin;

		my $match_string = $check_TS_oligo_seq;
		my ($regex_string) = &generateMisMatchRegex($match_string, $max_mismatch);#->595
		my $check_TS_oligo_regex = $regex_string;
		
		my $chunk_total_read_num = 0;
		my $chunk_passed_read_num = 0;
		
		while (my $line = <BAMIN>) {
			chomp $line;
			my ($chrom, $bedStart, $bedEnd, $CB_UMI_Seq, $MAPQ, $strand, $cigar) = split /\t+/, $line;
			$chunk_total_read_num++;
			
			next if $MAPQ < $min_MAPQ;
			my ($CB, $UMI, $bam_seq) = split /\_/, $CB_UMI_Seq;
			my $readname = join "_", ($CB, $UMI);
			$bam_seq =~ s/\/\d$//;
			my $out_chrom = $chrom_name_size_hsh_ref->{$chrom}{'out_chrom'};
			my $size = $chrom_name_size_hsh_ref->{$chrom}{'size'};

			
			#&reportAndLogStatus("passed_read_num = $passed_read_num", 10, "\n") if ($passed_read_num%10000 == 0);#->1381
			my ($end5Start, $unencoded_G, $sanity_check_ary_ref) = &getCTSS($bedStart, $bedEnd, $strand, $bam_seq, $check_TS_oligo_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_softclip_length, $max_softclip_length, $min_regex_match_pos, $max_regex_match_pos, $check_TS_oligo_regex, $min_match_length, $max_non_G_mismatch);#->647
			
			if (defined $end5Start) {
				my $end5End = $end5Start+1;
				if ($end5Start >= $chunk_startPos and $end5End <= $chunk_endPos) {
					if ($end5Start >= $margin and $end5End <= ($size - $margin)) {
						$chunk_passed_read_num++;
						print CTSSOUT join "", (join "\t", ($out_chrom, $end5Start, $end5End, $readname, $unencoded_G, $strand)), "\n";
						if ($sanity_check_toggle eq 'yes') {
							print SANITYCHECK join "", (join "\t", (@{$sanity_check_ary_ref})), "\n";
						}
					}
				}
			}
		}
	
		open (LOG, ">$chunk_log_path");
		print LOG "$chunk_passed_read_num\t$chunk_total_read_num\n";
		close LOG;
	
		close BAMIN;
		close CTSSOUT;
		close SANITYCHECK;

		system "sort -k1,1 -k2,2n -k6,6 $chunk_unsort_UMI_CB_ctss_bed_path >$chunk_UMI_CB_ctss_bed_path";
		system "rm $chunk_unsort_UMI_CB_ctss_bed_path";
		
	} else {
		&reportAndLogStatus("chunk_UMI_CB_ctss_bed_path found. Skipping conversion.", 10, "\n");#->1381
	}

	return ();
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|1199, reportAndLogStatus|1381
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|132, 4_finishingTasks|166
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 95, 1215, 1219, 1224, 1228, 1397, 1398
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub generateChromNameConversionHsh {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1381
#	appearInSub: >none
#	primaryAppearInSection: 3_convert|154
#	secondaryAppearInSection: >none
#	input: $bamPath, $chrom_name_path, $chrom_size_path, $samtools_bin
#	output: $chrom_name_size_hsh_ref, $out_chrom_size_hsh_ref
#	toCall: my ($chrom_name_size_hsh_ref, $out_chrom_size_hsh_ref) = &generateChromNameConversionHsh($chrom_name_path, $chrom_size_path, $samtools_bin, $bamPath);
#	calledInLine: 157
#....................................................................................................................................................#
	
	my ($chrom_name_path, $chrom_size_path, $samtools_bin, $bamPath) = @_;

	my $min_hit_read_pct = 10;
	&reportAndLogStatus("getting bam header chromosome", 10, "\n");#->1381
	my $actual_bam_chrom_name_hsh_ref = {};
	my $total_num_read = 0;
	open SAMTOOLS, "$samtools_bin idxstats $bamPath|";
	while (<SAMTOOLS>) {
		chomp;
		my ($actual_bam_chrom_name, $size, $num_read) = split /\t/;
		if ($actual_bam_chrom_name ne "*") {
			$actual_bam_chrom_name_hsh_ref->{$actual_bam_chrom_name} = $num_read;
			$total_num_read+=$num_read;
			&reportAndLogStatus("chrom $actual_bam_chrom_name found in bam with size $size and num_read $num_read", 10, "\n");#->1381
		}
	}
	close SAMTOOLS;

	my $chrom_name_size_hsh_ref = {};
	my $tmp_chrom_hsh_ref = {};
	my $out_chrom_size_hsh_ref = {};
	my $hit_num_read = 0;
	open (CHROMNAME, "<", $chrom_name_path);
	while (<CHROMNAME>) {
		chomp;
		my ($out_chrom, $bam_chrom_name) = split /\s+/;
		
		if (exists $actual_bam_chrom_name_hsh_ref->{$out_chrom}) {
			$bam_chrom_name = $out_chrom;
			$hit_num_read += $actual_bam_chrom_name_hsh_ref->{$out_chrom};
		} elsif (exists $actual_bam_chrom_name_hsh_ref->{$bam_chrom_name}) {
			$hit_num_read += $actual_bam_chrom_name_hsh_ref->{$bam_chrom_name};
		}
		
		$chrom_name_size_hsh_ref->{$bam_chrom_name}{'out_chrom'} = $out_chrom;
		$tmp_chrom_hsh_ref->{$out_chrom} = $bam_chrom_name;
	}
	close CHROMNAME;

	my $hit_read_pct = 100*($hit_num_read/$total_num_read);
	&reportAndLogStatus("$hit_read_pct % of read in bam is within chrom list scope", 10, "\n");#->1381
	if ($hit_read_pct < $min_hit_read_pct) {
		die "Quitting due to low % of read in bam is within chrom list scope.\n";
	}

	open (CHROMSIZE, "<", $chrom_size_path);
	while (<CHROMSIZE>) {
		chomp;
		my ($out_chrom, $size) = split /\s+/;
		my $bam_chrom_name = $tmp_chrom_hsh_ref->{$out_chrom};
		$chrom_name_size_hsh_ref->{$bam_chrom_name}{'size'} = $size;
		$out_chrom_size_hsh_ref->{$out_chrom} = $size;
	}
	close CHROMSIZE;

	return ($chrom_name_size_hsh_ref, $out_chrom_size_hsh_ref);
}
sub generateChunkInfoHsh {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1381
#	appearInSub: >none
#	primaryAppearInSection: 3_convert|154
#	secondaryAppearInSection: >none
#	input: $chrom_name_size_hsh_ref, $chunk_size, $result_tmp_dir
#	output: $chunk_info_hsh_ref
#	toCall: my ($chunk_info_hsh_ref) = &generateChunkInfoHsh($chrom_name_size_hsh_ref, $chunk_size, $result_tmp_dir);
#	calledInLine: 159
#....................................................................................................................................................#
	my ($chrom_name_size_hsh_ref, $chunk_size, $result_tmp_dir) = @_;
	
	my $chunk_num = 1;
	my $chunk_info_hsh_ref = {};
	foreach my $chrom (sort {$chrom_name_size_hsh_ref->{$a}{'out_chrom'} cmp $chrom_name_size_hsh_ref->{$b}{'out_chrom'}} keys %{$chrom_name_size_hsh_ref}) {
		my $size = $chrom_name_size_hsh_ref->{$chrom}{'size'};
		my $out_chrom = $chrom_name_size_hsh_ref->{$chrom}{'out_chrom'};
		foreach (my $startPos = 0; $startPos <= $size; $startPos += $chunk_size) {
			my $endPos = $startPos + $chunk_size;
			$endPos = $size if ($endPos > $size);
			my $file_tag = "$out_chrom.$startPos.$endPos";
			
			my $size_in_chunk = $endPos - $startPos;
			&reportAndLogStatus("chunk $chunk_num contains $size_in_chunk nt covering $out_chrom $startPos to $endPos", 10, "\n");#->1381

			my $chunk_CB_ctss_bed_path = "$result_tmp_dir/$file_tag.CB.ctss.bed";
			my $chunk_collapse_ctss_bed_path = "$result_tmp_dir/$file_tag.collapse.ctss.bed";
			my $chunk_ung_collapse_ctss_bed_path = "$result_tmp_dir/$file_tag.unencoded_G.collapse.ctss.bed";
			my $chunk_UMI_CB_ctss_bed_path = "$result_tmp_dir/$file_tag.UMI_CB.ctss.bed";
			my $chunk_unsort_UMI_CB_ctss_bed_path = "$result_tmp_dir/$file_tag.unsorted.UMI_CB.ctss.bed";
			my $chunk_log_path = "$result_tmp_dir/$file_tag.log.txt";
			my $chunk_fasta_path = "$result_tmp_dir/$file_tag.seq.fasta";
			my $chunk_sanity_check_path = "$result_tmp_dir/$file_tag.unencoded_G.sanity_check.txt";

			my ($chunk_chrom, $chunk_startPos, $chunk_endPos) = ($chrom, $startPos, $endPos);
			$chunk_info_hsh_ref->{$chunk_num}{'file_tag'} = $file_tag;
			$chunk_info_hsh_ref->{$chunk_num}{'loc'} = [$chunk_chrom, $chunk_startPos, $chunk_endPos];
			$chunk_info_hsh_ref->{$chunk_num}{'region_str'} = "$chunk_chrom:$chunk_startPos-$chunk_endPos";
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_ung_collapse_ctss_bed_path'} = $chunk_ung_collapse_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_unsort_UMI_CB_ctss_bed_path'} = $chunk_unsort_UMI_CB_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_UMI_CB_ctss_bed_path'} = $chunk_UMI_CB_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_CB_ctss_bed_path'} = $chunk_CB_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_collapse_ctss_bed_path'} = $chunk_collapse_ctss_bed_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_log_path'} = $chunk_log_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_sanity_check_path'} = $chunk_sanity_check_path;
			$chunk_info_hsh_ref->{$chunk_num}{'chunk_fasta_path'} = $chunk_fasta_path;
			$chunk_num++;
		}
 	}

	return ($chunk_info_hsh_ref);
}
sub generateChunkSize {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_convert|154
#	secondaryAppearInSection: >none
#	input: $num_chunk, $out_chrom_size_hsh_ref
#	output: $chunk_size
#	toCall: my ($chunk_size) = &generateChunkSize($out_chrom_size_hsh_ref, $num_chunk);
#	calledInLine: 158
#....................................................................................................................................................#
	
	my ($out_chrom_size_hsh_ref, $num_chunk) = @_;
	
	my $total_size = 0;

	foreach my $out_chrom (keys %{$out_chrom_size_hsh_ref}) {
		$total_size += $out_chrom_size_hsh_ref->{$out_chrom};
	}
	
	my $chunk_size = nearest (1000, $total_size/$num_chunk);

	return ($chunk_size);
}
sub generateMisMatchRegex {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: convertBamToCTSS|318
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $match_string, $max_mismatch
#	output: $regex_string
#	toCall: my ($regex_string) = &generateMisMatchRegex($match_string, $max_mismatch);
#	calledInLine: 374
#....................................................................................................................................................#
	my ($match_string, $max_mismatch) = @_;

	my @mismatch_2_ary;
	my @mismatch_1_ary;
	
	for my $i (0..length($match_string)-1) {
		my $mismatch_1_subpattern = join('',
			substr($match_string, 0, $i),
			'\\w',  # or '\\w'
			substr($match_string, $i+1),
		);
		push @mismatch_1_ary, $mismatch_1_subpattern;

		for my $j ($i+1..length($match_string)-1) {
			my $mismatch_2_subpattern = join('',
				substr($match_string, 0, $i),
				'\\w',  # or '\\w'
				substr($match_string, $i+1, $j-$i-1),
				'\\w',  # or '\\w'
				substr($match_string, $j+1),
			);
			push @mismatch_2_ary, $mismatch_2_subpattern;
		}
	}
	
	my $regex_string;
	if ($max_mismatch eq 0) {
		$regex_string = $match_string;
	} elsif ($max_mismatch eq 1) {
		$regex_string = join('|', @mismatch_1_ary);

	} elsif ($max_mismatch eq 2) {
		$regex_string = join('|', @mismatch_2_ary);

	} else {
		die;
	}
	
	return ($regex_string);
}
sub getCTSS {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1381
#	appearInSub: convertBamToCTSS|318
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: $bam_seq, $bedEnd, $bedStart, $check_TS_oligo_regex, $check_TS_oligo_seq, $chunk_endPos, $chunk_fasta_offset_pos, $chunk_seq_str, $chunk_startPos, $cigar, $max_non_G_mismatch, $max_regex_match_pos, $max_softclip_length, $min_match_length, $min_regex_match_pos, $min_softclip_length, $out_chrom, $samtools_bin, $strand
#	output: $end5Start, $num_unencoded_G, $sanity_check_ary_ref
#	toCall: my ($end5Start, $num_unencoded_G, $sanity_check_ary_ref) = &getCTSS($bedStart, $bedEnd, $strand, $bam_seq, $check_TS_oligo_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_softclip_length, $max_softclip_length, $min_regex_match_pos, $max_regex_match_pos, $check_TS_oligo_regex, $min_match_length, $max_non_G_mismatch);
#	calledInLine: 394
#....................................................................................................................................................#
	my ($bedStart, $bedEnd, $strand, $bam_seq, $check_TS_oligo_seq, $chunk_startPos, $chunk_endPos, $chunk_seq_str, $chunk_fasta_offset_pos, $samtools_bin, $out_chrom, $cigar, $min_softclip_length, $max_softclip_length, $min_regex_match_pos, $max_regex_match_pos, $check_TS_oligo_regex, $min_match_length, $max_non_G_mismatch) = @_;
	
	my ($end5Start, $num_unencoded_G);
	my $sanity_check_ary_ref = [];
	my $num_nt_extract_check = 10;

	my ($readStart, $readEnd) = ($bedStart, $bedEnd);

	my $rd_seq = $bam_seq;

	my $softclip_valid = 'no';
	my $match_valid = 'no';
	my $TSS_within_chunk = 'no';
	my $softclip_length = 0;
	my $match_length = 0;
	if ($strand eq '+') {
		if ($cigar =~ m/^(\d+)S(\d+)M/) {
			$softclip_length = $1;
			$match_length = $2;
			$readStart -= $softclip_length;
		}
		$TSS_within_chunk = 'yes' if $readStart >= $chunk_startPos;
	} else {
		$rd_seq = reverse $rd_seq;
		$rd_seq =~ tr/ATGCatgc/TACGtacg/;
		if ($cigar =~ m/(\d+)M(\d+)S$/) {
			$softclip_length = $2;
			$match_length = $1;
			$readEnd += $softclip_length;
		}
		$TSS_within_chunk = 'yes' if $readEnd <= $chunk_endPos;
	}

	$softclip_valid = 'yes' if ($softclip_length >= $min_softclip_length and $softclip_length <= $max_softclip_length);
	$match_valid = 'yes' if ($match_length >= $min_match_length);

	if ($softclip_valid eq 'yes' and $match_valid eq 'yes' and $TSS_within_chunk eq 'yes') {
		
		my $trim_rd_seq_match = substr $rd_seq, 0, $max_regex_match_pos;
		
		if ($trim_rd_seq_match =~ /$check_TS_oligo_regex/g) {
			my $match_end_rd_pos = $+[0];

			if ($match_end_rd_pos <= $max_regex_match_pos and $match_end_rd_pos >= $min_regex_match_pos) {#---valid only if the TSO is within the TS_oligo_check_range
			
				#---take 10nt for checking
				my $check_genome_seq;
				my $check_genome_pos_start;
				if ($strand eq '+') {

					$check_genome_pos_start = $readStart + $match_end_rd_pos - $chunk_fasta_offset_pos + 1;
					$check_genome_seq = substr ($chunk_seq_str, $check_genome_pos_start, $num_nt_extract_check);

				} else {
					my $check_genome_pos_end = $readEnd - $match_end_rd_pos - $chunk_fasta_offset_pos;
					$check_genome_pos_start = $check_genome_pos_end - $num_nt_extract_check + 1;

					$check_genome_seq = substr ($chunk_seq_str, $check_genome_pos_start, $num_nt_extract_check);
					$check_genome_seq = reverse($check_genome_seq);
					$check_genome_seq =~ tr/ATGC/TACG/;
				}

				my $check_read_pos = $match_end_rd_pos;
				my $check_read_seq = substr $rd_seq, $check_read_pos, $num_nt_extract_check;
			
				my $trim_length = $match_end_rd_pos;
				$num_unencoded_G = 0;
				my $matched = 'no';
				my $non_G_mismatch = 0;
				foreach my $shift_pos (0..$num_nt_extract_check) {
					my $read_nt = substr($check_read_seq, $shift_pos, 1);
					my $genome_nt = substr($check_genome_seq, $shift_pos, 1);
					
					if (not defined $genome_nt) {
						&reportAndLogStatus("num_nt_extract_check=$num_nt_extract_check", 10, "\n");#->1381
						&reportAndLogStatus("shift_pos=$shift_pos", 10, "\n");#->1381
						&reportAndLogStatus("check_genome_seq=$check_genome_seq", 10, "\n");#->1381
						&reportAndLogStatus("out_chrom=$out_chrom", 10, "\n");#->1381
						&reportAndLogStatus("bedStart=$bedStart", 10, "\n");#->1381
						&reportAndLogStatus("bedEnd=$bedEnd", 10, "\n");#->1381
						&reportAndLogStatus("readEnd=$readEnd", 10, "\n");#->1381
						&reportAndLogStatus("chunk_endPos=$chunk_endPos", 10, "\n");#->1381
						&reportAndLogStatus("readStart=$readStart", 10, "\n");#->1381
						&reportAndLogStatus("chunk_startPos=$chunk_startPos", 10, "\n");#->1381
						&reportAndLogStatus("strand=$strand", 10, "\n");#->1381
 					}
					
					if ($read_nt ne $genome_nt) {
						if ($read_nt eq 'G') {
							$num_unencoded_G++;
						} else {
							$non_G_mismatch++;
						};
						$trim_length++;
						last if $non_G_mismatch > $max_non_G_mismatch;
					} else {
						$matched = 'yes';
						last;
					}
				}
				
				if ($matched eq 'yes') {
					$sanity_check_ary_ref = [$out_chrom, $bedStart, $bedEnd, $strand, $rd_seq, $check_read_seq, $check_genome_seq, $cigar, $softclip_length, $match_length, $check_read_pos, $trim_length, $num_unencoded_G, $non_G_mismatch];
					if ($strand eq '+') {
						$end5Start = $readStart + $trim_length;

					} elsif ($strand eq '-') {
						$end5Start = $readEnd - $trim_length - 1;
	
					} else {
						die "strand=$strand, must be + or -\n";
					}
	
					$end5Start = 0 if $end5Start < 0;
				}
			}
		}
	}
	
	return ($end5Start, $num_unencoded_G, $sanity_check_ary_ref);
}
sub getChunkFasta {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1381
#	appearInSub: processPerChunk|1233
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_convert|154
#	input: $chunk_endPos, $chunk_fasta_path, $chunk_startPos, $genome_fasta_path, $out_chrom, $samtools_bin, $size
#	output: $chunk_fasta_offset_pos, $chunk_seq_str
#	toCall: my ($chunk_seq_str, $chunk_fasta_offset_pos) = &getChunkFasta($chunk_fasta_path, $out_chrom, $chunk_startPos, $chunk_endPos, $genome_fasta_path, $size, $samtools_bin);
#	calledInLine: 1291
#....................................................................................................................................................#
	my ($chunk_fasta_path, $out_chrom, $chunk_startPos, $chunk_endPos, $genome_fasta_path, $size, $samtools_bin) = @_;
	
	&reportAndLogStatus("Extracting chunk fasta", 10, "\n");#->1381
	
	my $fasta_start_pos = $chunk_startPos - 500;
	$fasta_start_pos = 1 if $fasta_start_pos < 1;
	
	my $fasta_end_pos = $chunk_endPos + 500;
	$fasta_end_pos = $size if $fasta_end_pos > $size;

	my $chunk_fasta_name = "$out_chrom:$fasta_start_pos-$fasta_end_pos";
	system ("$samtools_bin faidx $genome_fasta_path $chunk_fasta_name >$chunk_fasta_path");
	my $chunk_seq_str = '';
	
	open CHUNKFASTA, "<", $chunk_fasta_path;
	<CHUNKFASTA>;
	while (<CHUNKFASTA>) {
		chomp;
		$chunk_seq_str = $chunk_seq_str.$_;
	}
	close CHUNKFASTA;
	$chunk_seq_str = uc $chunk_seq_str;
	my $chunk_fasta_offset_pos = $fasta_start_pos;

	return ($chunk_seq_str, $chunk_fasta_offset_pos);
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|132
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 145
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub pileupCBDedupUMI {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1381
#	appearInSub: processPerChunk|1233
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_convert|154
#	input: $chunk_CB_ctss_bed_path, $chunk_UMI_CB_ctss_bed_path, $chunk_collapse_ctss_bed_path, $chunk_num, $chunk_ung_collapse_ctss_bed_path
#	output: 
#	toCall: &pileupCBDedupUMI($chunk_UMI_CB_ctss_bed_path, $chunk_CB_ctss_bed_path, $chunk_collapse_ctss_bed_path, $chunk_ung_collapse_ctss_bed_path, $chunk_num);
#	calledInLine: 1293
#....................................................................................................................................................#
	my ($chunk_UMI_CB_ctss_bed_path, $chunk_CB_ctss_bed_path, $chunk_collapse_ctss_bed_path, $chunk_ung_collapse_ctss_bed_path, $chunk_num) = @_;

	#&reportAndLogStatus("deduplicating umi at ctss", 10, "\n");#->1381
	my $num_proc = 0;
	my $tmp_CTSS_hsh_ref = {};
	my $last_chrom = 'initial';
	my $last_start = 'initial';
	my $last_strand = 'initial';
	open INCTSS, "<", $chunk_UMI_CB_ctss_bed_path;
	open OUTCTSS, ">", $chunk_CB_ctss_bed_path;
	open OUTCBCOLLAPSECTSS, ">", $chunk_collapse_ctss_bed_path;
	open UNGOUTCBCOLLAPSECTSS, ">", $chunk_ung_collapse_ctss_bed_path;
	while (<INCTSS>) {
		chomp;
		my ($chrom, $start, $end, $ID, $num_unencoded_G, $strand) = split /\t/;
		{
			my ($CB, $UMI) = split /_/, $ID;
			$tmp_CTSS_hsh_ref->{$chrom}{$start}{$strand}{$CB}{'all'}{$UMI}++;
			$tmp_CTSS_hsh_ref->{$chrom}{$start}{$strand}{$CB}{'ung'}{$UMI}++ if $num_unencoded_G > 0;
		}
	
		if ($last_chrom eq 'initial') {
			$last_chrom = $chrom;
			$last_start = $start;
			$last_strand = $strand;
		}
		if (($chrom ne $last_chrom or $start ne $last_start or $strand ne $last_strand)) {
			my $last_end = $last_start + 1;
			my $CB_collapse_num_umi = 0;
			my $num_CB = 0;

			my $ung_CB_collapse_num_umi = 0;
			my $ung_num_CB = 0;

			foreach my $CB (sort keys %{$tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand}}) {
				my $num_umi = keys %{$tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand}{$CB}{'all'}};
				$CB_collapse_num_umi += $num_umi;
				$num_CB++;
				print OUTCTSS join "", (join "\t", ($last_chrom, $last_start, $last_end, $CB, $num_umi, $last_strand)), "\n";

				if (exists $tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand}{$CB}{'ung'}) {
					my $ung_num_umi = keys %{$tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand}{$CB}{'ung'}};
					$ung_CB_collapse_num_umi += $ung_num_umi;
					$ung_num_CB++;
				}
			}
			print OUTCBCOLLAPSECTSS join "", (join "\t", ($last_chrom, $last_start, $last_end, $num_CB, $CB_collapse_num_umi, $last_strand)), "\n";
			
			if ($ung_CB_collapse_num_umi > 0) {
				print UNGOUTCBCOLLAPSECTSS join "", (join "\t", ($last_chrom, $last_start, $last_end, $ung_num_CB, $ung_CB_collapse_num_umi, $last_strand)), "\n";
			}
			
			delete $tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand};
			$last_chrom = $chrom;
			$last_start = $start;
			$last_strand = $strand;
			$num_proc++;
			if ($num_proc%10000 == 0) {
				&reportAndLogStatus("$num_proc CTSS deduplicated for chunk $chunk_num", 10, "\n");#->1381
			}
		}
	
		if (eof(INCTSS)) {
			foreach my $chrom (keys %{$tmp_CTSS_hsh_ref}) {
				foreach my $start (keys %{$tmp_CTSS_hsh_ref->{$chrom}}) {
					my $end = $start + 1;
					foreach my $strand (keys %{$tmp_CTSS_hsh_ref->{$chrom}{$start}}) {
						my $CB_collapse_num_umi = 0;
						my $num_CB = 0;

						my $ung_CB_collapse_num_umi = 0;
						my $ung_num_CB = 0;

						foreach my $CB (sort keys  %{$tmp_CTSS_hsh_ref->{$chrom}{$start}{$strand}}) {
							my $num_umi = keys %{$tmp_CTSS_hsh_ref->{$chrom}{$start}{$strand}{$CB}{'all'}};
							$CB_collapse_num_umi += $num_umi;
							$num_CB++;
							print OUTCTSS join "", (join "\t", ($chrom, $start, $end, $CB, $num_umi, $strand)), "\n";

							if (exists $tmp_CTSS_hsh_ref->{$chrom}{$start}{$strand}{$CB}{'ung'}) {
								my $ung_num_umi = keys %{$tmp_CTSS_hsh_ref->{$last_chrom}{$last_start}{$last_strand}{$CB}{'ung'}};
								$ung_CB_collapse_num_umi += $ung_num_umi;
								$ung_num_CB++;
							}

						}
						print OUTCBCOLLAPSECTSS join "", (join "\t", ($chrom, $start, $end, "$num_CB", $CB_collapse_num_umi, $strand)), "\n";

						if ($ung_CB_collapse_num_umi > 0) {
							print UNGOUTCBCOLLAPSECTSS join "", (join "\t", ($chrom, $start, $end, "$ung_num_CB", $ung_CB_collapse_num_umi, $strand)), "\n";
						}
					}
				}
			}
		}
	}
	close INCTSS;
	close OUTCTSS;
	close OUTCBCOLLAPSECTSS;
	close UNGOUTCBCOLLAPSECTSS;

	return ();
}
sub poolChunkResults {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: checkChunkResults|265, reportAndLogStatus|1381
#	appearInSub: >none
#	primaryAppearInSection: 3_convert|154
#	secondaryAppearInSection: >none
#	input: $chunk_info_hsh_ref, $paramTag, $result_bed_dir, $result_log_dir, $result_tmp_dir, $rm_tmp_file
#	output: 
#	toCall: &poolChunkResults($chunk_info_hsh_ref, $result_bed_dir, $result_log_dir, $paramTag, $result_tmp_dir, $rm_tmp_file);
#	calledInLine: 161
#....................................................................................................................................................#
	my ($chunk_info_hsh_ref, $result_bed_dir, $result_log_dir, $paramTag, $result_tmp_dir, $rm_tmp_file) = @_;
	
	my $CB_ctss_bed_path = "$result_bed_dir/$paramTag.CB.ctss.bed";
	my $ung_collapse_ctss_bed_path = "$result_bed_dir/$paramTag.unencoded_G.collapse.ctss.bed";
	my $collapse_ctss_bed_path = "$result_bed_dir/$paramTag.collapse.ctss.bed";
	my $UMI_CB_ctss_bed_path = "$result_bed_dir/$paramTag.UMI_CB.ctss.bed";
	my $log_path = "$result_log_dir/$paramTag.read_count.txt";
	my $sanity_check_path = "$result_tmp_dir/$paramTag.unencoded_G.sanity_check.txt";
	
	open SANITYCHECK, ">", $sanity_check_path;
	print SANITYCHECK join "", (join "\t", ('out_chrom', 'bedStart', 'bedEnd', 'strand', 'rd_seq', 'check_read_seq', 'check_genome_seq', 'cigar', 'softclip_length', 'match_length', 'check_read_pos', 'trim_length', 'num_unencoded_G', 'non_G_mismatch')), "\n";

	my $total_read_num = 0;
	my $passed_read_num = 0;
	my $num_sanity_print = 1000;
	
	open UMICBCTSS, ">$UMI_CB_ctss_bed_path";
	open CBCTSS, ">$CB_ctss_bed_path";
	open COLLAPSECTSS, ">$collapse_ctss_bed_path";
	open UNGCOLLAPSECTSS, ">$ung_collapse_ctss_bed_path";
	
	foreach my $chunk_num (sort {$a <=> $b} keys %{$chunk_info_hsh_ref}) {
		my $file_check_ary_ref = [qw/chunk_UMI_CB_ctss_bed_path chunk_CB_ctss_bed_path chunk_collapse_ctss_bed_path/];
		my ($valid) = &checkChunkResults($chunk_info_hsh_ref, $chunk_num, $file_check_ary_ref);#->265

		if ($valid eq 'yes') {
			&reportAndLogStatus("results of chunk $chunk_num is found. start parsing.", 10, "\n");#->1381
			my $chunk_UMI_CB_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_UMI_CB_ctss_bed_path'};
			my $chunk_CB_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_CB_ctss_bed_path'};
			my $chunk_collapse_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_collapse_ctss_bed_path'};
			my $chunk_ung_collapse_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_ung_collapse_ctss_bed_path'};
			my $chunk_log_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_log_path'};
			my $chunk_sanity_check_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_sanity_check_path'};
			my $chunk_fasta_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_fasta_path'};
			
			my $num_sanity_check = 0;
			open (CHUNKSANITYCHECK, "<", $chunk_sanity_check_path);
			<CHUNKSANITYCHECK>;
			while (<CHUNKSANITYCHECK>) {
				print SANITYCHECK $_;
				$num_sanity_check++;
				last if $num_sanity_check >= $num_sanity_print;
			}
			close CHUNKSANITYCHECK;

			open (CHUNKUMICB, "<", $chunk_UMI_CB_ctss_bed_path);
			while (<CHUNKUMICB>) {
				print UMICBCTSS $_;
			}
			close CHUNKUMICB;

			open (CHUNKCB, "<", $chunk_CB_ctss_bed_path);
			while (<CHUNKCB>) {
				print CBCTSS $_;
			}
			close CHUNKCB;

			open (UNGCHUNKCOLLAPSE, "<", $chunk_ung_collapse_ctss_bed_path);
			while (<UNGCHUNKCOLLAPSE>) {
				print UNGCOLLAPSECTSS $_;
			}
			close UNGCHUNKCOLLAPSE;

			open (CHUNKCOLLAPSE, "<", $chunk_collapse_ctss_bed_path);
			while (<CHUNKCOLLAPSE>) {
				print COLLAPSECTSS $_;
			}
			close CHUNKCOLLAPSE;
		
			open (CHUNKLOG, "<", $chunk_log_path);
			while (<CHUNKLOG>) {
				chomp;
				my ($chunk_passed_read_num, $chunk_total_read_num) = split /\t/;
				$total_read_num += $chunk_total_read_num;
				$passed_read_num += $chunk_passed_read_num;
			}
			close CHUNKLOG;

			if ($rm_tmp_file eq 'yes') {
				system ("rm $chunk_UMI_CB_ctss_bed_path");
				system ("rm $chunk_CB_ctss_bed_path");
				system ("rm $chunk_collapse_ctss_bed_path");
				system ("rm $chunk_ung_collapse_ctss_bed_path");
				system ("rm $chunk_log_path");
				system ("rm $chunk_fasta_path");
				system ("rm $chunk_sanity_check_path");
			}
			
		} else {
			die "results of chunk $chunk_num is not found. quitting\n";
		}
	}

	&reportAndLogStatus("Compressing UMI_CB_ctss_bed_path.", 10, "\n");#->1381
	system "gzip -f $UMI_CB_ctss_bed_path";
	&reportAndLogStatus("Compressing CB_ctss_bed_path.", 10, "\n");#->1381
	system "gzip -f $CB_ctss_bed_path";
	&reportAndLogStatus("Compressing collapse_ctss_bed_path.", 10, "\n");#->1381
	system "gzip -f $collapse_ctss_bed_path";
	&reportAndLogStatus("Compressing ung_collapse_ctss_bed_path.", 10, "\n");#->1381
	system "gzip -f $ung_collapse_ctss_bed_path";

	open ALLLOG, ">", $log_path;
	print ALLLOG join "", (join "\t", ('total_read_num', 'passed_read_num')), "\n";
	print ALLLOG join "", (join "\t", ($total_read_num, $passed_read_num)), "\n";
	close ALLLOG;
	close SANITYCHECK;
	close COLLAPSECTSS;
	close UNGCOLLAPSECTSS;
	close CBCTSS;
	close UMICBCTSS;
	
	return ();
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_finishingTasks|166
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 169
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort {$a cmp $b} keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			my $headerColLen = max(@colLenCountHsh)+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}

	my $fileDir_colLen = max(@{$filelistLenCountHsh{'dir'}})+2;
	my $fileName_colLen = max(@{$filelistLenCountHsh{'name'}})+2;
	my $fileDescription_colLen = max(@{$filelistLenCountHsh{'description'}})+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|428
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|132, 4_finishingTasks|166
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 146, 170
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->428
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->428
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->428
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->428
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub processPerChunk {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: checkChunkResults|265, convertBamToCTSS|318, getChunkFasta|780, pileupCBDedupUMI|843, reportAndLogStatus|1381
#	appearInSub: >none
#	primaryAppearInSection: 3_convert|154
#	secondaryAppearInSection: >none
#	input: $TS_oligo_check_tail_length, $TS_oligo_seq, $bamPath, $bedtools_bin, $chrom_name_size_hsh_ref, $chunk_info_hsh_ref, $exclude_flag, $genome_fasta_path, $include_flag, $max_mismatch, $max_non_G_mismatch, $max_thread, $min_MAPQ, $min_match_length, $out_chrom_size_hsh_ref, $regex_match_margin, $samtools_bin, $sanity_check_toggle, $softclip_margin
#	output: 
#	toCall: &processPerChunk($bamPath, $bedtools_bin, $samtools_bin, $max_thread, $chunk_info_hsh_ref, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $min_MAPQ, $TS_oligo_seq, $genome_fasta_path, $out_chrom_size_hsh_ref, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch);
#	calledInLine: 160
#....................................................................................................................................................#
	my ($bamPath, $bedtools_bin, $samtools_bin, $max_thread, $chunk_info_hsh_ref, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $min_MAPQ, $TS_oligo_seq, $genome_fasta_path, $out_chrom_size_hsh_ref, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch) = @_;

	my %itemForThrHsh = ();
	my $threadID = 1;
	my $chrom_info_hsh_ref = {};
	my $total_num_chunk = keys %{$chunk_info_hsh_ref};
	foreach my $chunk_num (keys %{$chunk_info_hsh_ref}) {
		$threadID = 1 if $threadID > $max_thread;
		$itemForThrHsh{$threadID}{$chunk_num}++;
		$threadID++;
	}
	my $num_proc : shared = 0;

	my %threadHsh =();
	foreach my $threadID (sort {$a <=> $b} keys %itemForThrHsh) {
		my $itemForThrHsh_ref = $itemForThrHsh{$threadID};
		($threadHsh{$threadID}) = threads->new(#---refer to http://www.perlmonks.org/?node_id=966781, the 
	
			sub {
				
				my ($itemForThrHsh_ref) = @_;
				my $total_chunk = keys %{$itemForThrHsh_ref};
				
				&reportAndLogStatus("$total_chunk chunks spawned to thread $threadID.", 10, "\n");#->1381
				foreach my $chunk_num (keys %{$itemForThrHsh_ref}) {
					
					my $file_check_ary_ref = [qw/chunk_UMI_CB_ctss_bed_path chunk_CB_ctss_bed_path chunk_collapse_ctss_bed_path/];
					my ($valid) = &checkChunkResults($chunk_info_hsh_ref, $chunk_num, $file_check_ary_ref);#->265

					if ($valid eq 'yes') {
						&reportAndLogStatus("results of chunk $chunk_num is found. skipping", 10, "\n");#->1381

					} else {
						&reportAndLogStatus("start processing chunk $chunk_num in thread $threadID.", 10, "\n");#->1381
						my $region_str = $chunk_info_hsh_ref->{$chunk_num}{'region_str'};
						my $chunk_unsort_UMI_CB_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_unsort_UMI_CB_ctss_bed_path'};
						my $chunk_UMI_CB_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_UMI_CB_ctss_bed_path'};
						my $chunk_CB_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_CB_ctss_bed_path'};
						my $chunk_collapse_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_collapse_ctss_bed_path'};
						my $chunk_ung_collapse_ctss_bed_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_ung_collapse_ctss_bed_path'};
						my $chunk_log_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_log_path'};
						my $chunk_sanity_check_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_sanity_check_path'};
						my $chunk_fasta_path = $chunk_info_hsh_ref->{$chunk_num}{'chunk_fasta_path'};
						my ($chunk_chrom, $chunk_startPos, $chunk_endPos) = @{$chunk_info_hsh_ref->{$chunk_num}{'loc'}};
						my $out_chrom = $chrom_name_size_hsh_ref->{$chunk_chrom}{'out_chrom'};
						my $size = $out_chrom_size_hsh_ref->{$out_chrom};
						
						my ($chunk_seq_str, $chunk_fasta_offset_pos) = &getChunkFasta($chunk_fasta_path, $out_chrom, $chunk_startPos, $chunk_endPos, $genome_fasta_path, $size, $samtools_bin);#->780
						&convertBamToCTSS($bamPath, $chrom_name_size_hsh_ref, $exclude_flag, $include_flag, $bedtools_bin, $samtools_bin, $min_MAPQ, $chunk_UMI_CB_ctss_bed_path, $chunk_unsort_UMI_CB_ctss_bed_path, $region_str, $chunk_log_path, $chunk_startPos, $chunk_endPos, $TS_oligo_seq, $chunk_fasta_path, $chunk_seq_str, $chunk_fasta_offset_pos, $chunk_sanity_check_path, $sanity_check_toggle, $TS_oligo_check_tail_length, $max_mismatch, $regex_match_margin, $softclip_margin, $min_match_length, $max_non_G_mismatch);#->318
						&pileupCBDedupUMI($chunk_UMI_CB_ctss_bed_path, $chunk_CB_ctss_bed_path, $chunk_collapse_ctss_bed_path, $chunk_ung_collapse_ctss_bed_path, $chunk_num);#->843
					}
					$num_proc++;
					&reportAndLogStatus("$num_proc of $total_num_chunk chunks are finised.", 10, "\n");#->1381
				}
				return ();
			}
			,($itemForThrHsh_ref)
		);
	}
	
	while (keys %threadHsh) {

		my @threads = threads->list();
		my $thread_count = threads->list();
		my @running = threads->list(threads::running);
		my @joinable = threads->list(threads::joinable);
		my $running_count = @running;
		my $joinable_count = @joinable;

		&reportAndLogStatus("$thread_count threads exists. $running_count running and $joinable_count joinable", 10, "\n");#->1381

		foreach my $threadID (keys %threadHsh) {
			if (not $threadHsh{$threadID}->is_running() or $threadHsh{$threadID}->is_joinable() or $threadHsh{$threadID}->is_detached()) {
				&reportAndLogStatus("thread $threadID is finishing.", 10, "\n");#->1381
				$threadHsh{$threadID}->join();
				delete $threadHsh{$threadID};
			}
		}
		sleep 1;
	}

	return ();
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|106
#	secondaryAppearInSection: >none
#	input: none
#	output: $TS_oligo_seq, $bamPath, $exclude_flag, $genome, $include_flag, $max_thread, $min_MAPQ, $outDir, $outputPrefix, $overwrite
#	toCall: my ($bamPath, $exclude_flag, $include_flag, $min_MAPQ, $max_thread, $TS_oligo_seq, $genome, $outputPrefix, $outDir, $overwrite) = &readParameters();
#	calledInLine: 109
#....................................................................................................................................................#
	
	my ($bamPath, $exclude_flag, $include_flag, $min_MAPQ, $max_thread, $TS_oligo_seq, $genome, $outputPrefix, $outDir, $overwrite);
	
	$min_MAPQ = 0;
	$exclude_flag = '128,256,4';
	$max_thread = 5;
	$TS_oligo_seq = 'TTTCTTATATGGG';
	$overwrite = 'no';

	GetOptions 	(
		"bamPath=s"				=>	\$bamPath,
		"include_flag=s"		=>	\$include_flag,
		"min_MAPQ:i"			=>	\$min_MAPQ,
		"exclude_flag:s"		=>	\$exclude_flag,
		"max_thread:i"			=>	\$max_thread,
		"TS_oligo_seq:s"		=>	\$TS_oligo_seq,
		"genome=s"				=>	\$genome,
		"outputPrefix=s"		=>	\$outputPrefix,
		"outDir:s"				=>	\$outDir,
		"overwrite:s"			=>	\$overwrite,
		'help'					=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $bamPath;
	
	#---check file
	my $file_check_hsh_ref = {
		'bamPath' => $bamPath,
	};
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}
	
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
	
	return($bamPath, $exclude_flag, $include_flag, $min_MAPQ, $max_thread, $TS_oligo_seq, $genome, $outputPrefix, $outDir, $overwrite);

}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|428
#	appearInSub: checkBedtoolsVersion|210, checkChunkResults|265, checkSamtoolsVersion|288, convertBamToCTSS|318, generateChromNameConversionHsh|446, generateChunkInfoHsh|516, getCTSS|647, getChunkFasta|780, pileupCBDedupUMI|843, poolChunkResults|958, processPerChunk|1233
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|132, 3_convert|154
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 228, 232, 281, 305, 309, 332, 393, 422, 461, 471, 498, 540, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 793, 856, 912, 995, 1062, 1064, 1066, 1068, 1267, 1274, 1277, 1296, 1313, 1317
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->428
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->428
	
	return ();
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 94
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































