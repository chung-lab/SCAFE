#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use List::Util qw (sum shuffle min max);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use threads;
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                                ---> scafe.tool.cm.prep_genome <---
                  <--- tool, common mode, prepare custom reference genome --->

 Description:
   This tool prepares a reference genome assembly and its gene models for others tools in scafe.

 Usage:
   scafe.tool.cm.prep_genome [options] --gtf_path --fasta_path --chrom_list_path --mask_bed_path --outputPrefix --outDir
   
   --gtf_path         <required> [string] gtf of the gene models
   --fasta_path       <required> [string] fasta of the genome assembly
   --chrom_list_path  <required> [string] list of <chromosome name><\t><alternative chromosome name> 
                                          e.g. <chr1><\t><1>
                                          chromosome name and alternative chromosome name could be the same
                                          alternative chromosome name is necessary if the cellranger bam
                                          file uses alternative chromosome name that is different from those
                                          in $fasta_path
   --mask_bed_path    <required> [string] a bed file specific the CRE regions. For human or mouse, consider 
                                          using ENCODE CREs. for other species, consider using merged ATAC-seq
                                          from multiple tissues. If ATAC is not available, use the +/- 500nt of 
                                          gene model 5'end.
   --outputPrefix     <required> [string] prefix for the output files (should be name of the genome reference)
   --outDir           <required> [string] directory for the output files (should be resource dir in scafe dir)
   --overwrite        (optional) [yes/no] erase outDir/outputPrefix before running (default=no)

 Dependencies:
   bedtools
   samtools

 For demo, cd to SCAFE dir and run,
   scafe.tool.cm.prep_genome \
   --overwrite=yes \
   --gtf_path=./demo/input/genome/TAIR10.AtRTDv2.gtf.gz \
   --fasta_path=./demo/input/genome/TAIR10.genome.fa.gz \
   --chrom_list_path=./demo/input/genome/TAIR10.chrom_list.txt \
   --mask_bed_path=./demo/input/genome/TAIR10.ATAC.bed.gz \
   --outputPrefix=TAIR10.AtRTDv2 \
   --outDir=./demo/output/genome/

=head1 VERSION

v0.9.0-beta [March 20, 2021]
	-Initial pre-release

v1.0.0 [June 6, 2022]
	-No update

v1.0.1 [June 26, 2022]
	-No update

=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->1143
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->363
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($gtf_path, $fasta_path, $chrom_list_path, $mask_bed_path, $outputPrefix, $outDir, $overwrite) = &readParameters();#->1043
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $flankSize_ary_ref = [500, 250, 100, 50, 25, 10, 0];
my $paramTag = "$outputPrefix";
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineOutDirPath
#
#<section ID="defineOutDirPath" num="2">
my @mkDirAry;
my $result_dir = "$outDir/$paramTag/"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $result_bed_dir = "$result_dir/bed/"; push @mkDirAry, $result_bed_dir;
my $result_tmp_dir = "$result_dir/tmp/"; push @mkDirAry, $result_tmp_dir;
my $result_tsv_dir = "$result_dir/tsv/"; push @mkDirAry, $result_tsv_dir;
my $result_fasta_dir = "$result_dir/fasta/"; push @mkDirAry, $result_fasta_dir;
my $result_gtf_dir = "$result_dir/gtf/"; push @mkDirAry, $result_gtf_dir;
my $result_script_dir = "$result_dir/script/"; push @mkDirAry, $result_script_dir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 755 $dir");}
open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&printStartOrFinishMessage("startMessage");#->725
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->456
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_processInputData
#
#<section ID="processInputData" num="3">
my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();#->212
my ($out_fasta_path, $out_fai_path, $out_gtf_path, $out_mask_bed_path) = &copySourceFile($gtf_path, $fasta_path, $samtools_bin, $mask_bed_path, $result_bed_dir, $result_fasta_dir, $result_gtf_dir);#->312
my ($chromSizeHsh_ref) = &readChromSize($out_fai_path, $chrom_list_path, $result_tsv_dir);#->834
my ($geneInfoHsh_ref) = &readGTF($gtf_path, $chromSizeHsh_ref);#->886
my ($annoRegHsh_ref) = &generateAnnotationRegion($geneInfoHsh_ref, $flankSize_ary_ref, $chromSizeHsh_ref, $result_bed_dir);#->381
my ($subtract_bed_hsh_ref, $region_bed_hsh_ref) = &printRegionBed($annoRegHsh_ref, $outputPrefix, $result_bed_dir, $bedtools_bin);#->665
&subtractMask($region_bed_hsh_ref, $mask_bed_path, $bedtools_bin, $result_bed_dir, $subtract_bed_hsh_ref);#->1113
&printTranscriptBed($geneInfoHsh_ref, $outputPrefix, $result_bed_dir);#->759
&printGeneInfo($geneInfoHsh_ref, $outputPrefix, $result_tsv_dir);#->481
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_finishingTasks
#
#<section ID="finishingTasks" num="4">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->545
&printStartOrFinishMessage("finishMessage");#->725
close $tmplog_fh;
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	GFF [n=1]:
#		readGTF
#
#	general [n=5]:
#		currentTime, logCalledCMDAndScript, printStartOrFinishMessage
#		readParameters, timeStamp
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	specific [n=3]:
#		printGeneInfo, printRegionBed, printTranscriptBed
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=5]:
#		checkAllExecutable, copySourceFile, generateAnnotationRegion
#		readChromSize, subtractMask
#
#====================================================================================================================================================#

sub checkAllExecutable {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1091
#	appearInSub: >none
#	primaryAppearInSection: 3_processInputData|154
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedGraphToBigWig_bin, $bedtools_bin, $bgzip_bin, $bigWigAverageOverBed_bin, $cut_sh_path, $paraclu_bin, $samtools_bin, $tabix_bin
#	toCall: my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();
#	calledInLine: 157
#....................................................................................................................................................#
	
	my $dirPath = dirname(rel2abs($0));

	my $tabix_bin = "$dirPath/../resources/bin/tabix/tabix";
	my $bgzip_bin = "$dirPath/../resources/bin/bgzip/bgzip";
	my $bedtools_bin = "$dirPath/../resources/bin/bedtools/bedtools";
	my $samtools_bin = "$dirPath/../resources/bin/samtools/samtools";
	my $paraclu_bin = "$dirPath/../resources/bin/paraclu/paraclu";
	my $cut_sh_path = "$dirPath/../resources/bin/paraclu/paraclu-cut.sh";
	my $bedGraphToBigWig_bin = "$dirPath/../resources/bin/bedGraphToBigWig/bedGraphToBigWig";
	my $bigWigAverageOverBed_bin = "$dirPath/../resources/bin/bigWigAverageOverBed/bigWigAverageOverBed";
	
	&reportAndLogStatus("Checking all SCAFE executables", 10, "\n");#->1091
	
	{
		my $stdOut = `$tabix_bin  --version 2>&1`;
		if ($stdOut =~ m/tabix \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: tabix version: $1", 0, "\n");#->1091
		} else {
			die "tabix is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bgzip_bin --version 2>&1`;
		if ($stdOut =~ m/bgzip \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: bgzip version: $1", 0, "\n");#->1091
		} else {
			die "bgzip is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedtools_bin --version 2>&1`;
		if ($stdOut =~ m/bedtools v(\S+)/) {
			&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->1091
		} else {
			die "bedtools is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$samtools_bin 2>&1`;
		if ($stdOut =~ m/\s+(Version: \S+)\s+/) {
			&reportAndLogStatus("Checking: samtools version: $1", 0, "\n");#->1091
		} else {
			die "samtools is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$paraclu_bin 2>&1`;
		if ($stdOut =~ m/paraclu: I need a minValue and a fileName/) {
			&reportAndLogStatus("Checking: paraclu found.", 0, "\n");#->1091
		} else {
			die "paraclu is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$cut_sh_path 55C7128A 2>&1`;
		if ($stdOut =~ m/awk:/) {
			&reportAndLogStatus("Checking: paraclu-cut found.", 0, "\n");#->1091
		} else {
			die "paraclu-cut is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedGraphToBigWig_bin 2>&1`;
		if ($stdOut =~ m/bedGraphToBigWig v (\S+)/) {
			&reportAndLogStatus("Checking: bedGraphToBigWig version: $1", 0, "\n");#->1091
		} else {
			die "bedGraphToBigWig not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bigWigAverageOverBed_bin 2>&1`;
		if ($stdOut =~ m/bigWigAverageOverBed v(\S+)/) {
			&reportAndLogStatus("Checking: bigWigAverageOverBed version: $1", 0, "\n");#->1091
		} else {
			die "bigWigAverageOverBed is not installed properly. Quitting.\n";
		}
	}

	return ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin);
}
sub copySourceFile {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1091
#	appearInSub: >none
#	primaryAppearInSection: 3_processInputData|154
#	secondaryAppearInSection: >none
#	input: $fasta_path, $gtf_path, $mask_bed_path, $result_bed_dir, $result_fasta_dir, $result_gtf_dir, $samtools_bin
#	output: $out_fai_path, $out_fasta_path, $out_gtf_path, $out_mask_bed_path
#	toCall: my ($out_fasta_path, $out_fai_path, $out_gtf_path, $out_mask_bed_path) = &copySourceFile($gtf_path, $fasta_path, $samtools_bin, $mask_bed_path, $result_bed_dir, $result_fasta_dir, $result_gtf_dir);
#	calledInLine: 158
#....................................................................................................................................................#
	my ($gtf_path, $fasta_path, $samtools_bin, $mask_bed_path, $result_bed_dir, $result_fasta_dir, $result_gtf_dir) = @_;
	
	my $out_fasta_path = "$result_fasta_dir/genome.fa";
	my $out_fai_path = "$out_fasta_path.fai";
	my $out_gtf_path = "$result_gtf_dir/gene.gtf.gz";
	my $out_mask_bed_path = "$result_bed_dir/mask.bed.gz";

	&reportAndLogStatus("copying fasta", 10, "\n");#->1091
	if ($fasta_path =~ m/\.fasta\.gz$/ or $fasta_path =~ m/\.fa\.gz$/ or $fasta_path =~ m/\.fas\.gz$/) {
		system ("gzip -dc $fasta_path >$out_fasta_path");
	} elsif ($fasta_path =~ m/\.fasta$/ or $fasta_path =~ m/\.fa$/ or $fasta_path =~ m/\.fas$/) {
		system ("cp $fasta_path $out_fasta_path");
	} else {
		die "fasta_path must end with .fas, .fa, .fasta, .fas.gz, .fa.gz, .fasta.gz";
	}
	
	&reportAndLogStatus("indexing fasta", 10, "\n");#->1091
	system "$samtools_bin faidx $out_fasta_path";

	&reportAndLogStatus("copying gtf", 10, "\n");#->1091
	if ($gtf_path =~ m/\.gtf\.gz$/) {
		system ("cp $gtf_path $out_gtf_path");
	} elsif ($gtf_path =~ m/\.gtf$/) {
		system ("gzip -c $gtf_path >$out_gtf_path");
	} else {
		die "gtf_path must end with .gtf or .gtf.gz";
	}

	&reportAndLogStatus("copying mask bed", 10, "\n");#->1091
	if ($mask_bed_path =~ m/\.bed\.gz$/) {
		system ("gzip -dc $mask_bed_path | sort -k1,1 -k2,2n | gzip -c >$out_mask_bed_path");
	} elsif ($mask_bed_path =~ m/\.bed$/) {
		system ("sort -k1,1 -k2,2n $mask_bed_path | gzip -c >$out_mask_bed_path");
	} else {
		die "mask_bed_path must end with .bed or .bed.gz";
	}
	
	return ($out_fasta_path, $out_fai_path, $out_gtf_path, $out_mask_bed_path);
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|725, reportAndLogStatus|1091
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|134, 4_finishingTasks|170
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 106, 741, 745, 750, 754, 1107, 1108
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub generateAnnotationRegion {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1091
#	appearInSub: >none
#	primaryAppearInSection: 3_processInputData|154
#	secondaryAppearInSection: >none
#	input: $chromSizeHsh_ref, $flankSize_ary_ref, $geneInfoHsh_ref, $result_bed_dir
#	output: $annoRegHsh_ref
#	toCall: my ($annoRegHsh_ref) = &generateAnnotationRegion($geneInfoHsh_ref, $flankSize_ary_ref, $chromSizeHsh_ref, $result_bed_dir);
#	calledInLine: 161
#....................................................................................................................................................#
	my ($geneInfoHsh_ref, $flankSize_ary_ref, $chromSizeHsh_ref, $result_bed_dir) = @_;
	
	my $annoRegHsh_ref = {};
	
	&reportAndLogStatus("generating annotation regions", 10, "\n");#->1091
	my $num_proc = 0;
	
	foreach my $geneID (keys %{$geneInfoHsh_ref}) {	
		$num_proc++;
		&reportAndLogStatus("$num_proc genes processed", 10, "\n") if $num_proc%100==0;#->1091
		my $g_strnd = $geneInfoHsh_ref->{$geneID}{'strand'};
		my $chrom = $geneInfoHsh_ref->{$geneID}{'chrom'};
		my $chromSize = $chromSizeHsh_ref->{$chrom};
		my ($geneStart, $genetEnd) = @{$geneInfoHsh_ref->{$geneID}{'geneRng'}};
		foreach my $trnscptID (keys %{$geneInfoHsh_ref->{$geneID}{'trnscpt'}}) {	
			my ($trnscptStart, $trnscptEnd) = @{$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'trnscptRng'}};
			my $t_strnd = $geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'strand'};
			my $TSSPos = $trnscptStart;
			$TSSPos = $trnscptEnd if ($t_strnd eq '-');
			
			foreach my $flankSize (@{$flankSize_ary_ref}) {
				my $TSSFlnkStart = $TSSPos - $flankSize;
				my $TSSFlnkEnd = $TSSPos + $flankSize;

				my $annoType = "TSS_flank_$flankSize";
				my $annoStart = $TSSFlnkStart;
				my $annoEnd = $TSSFlnkEnd;

				$annoStart = 1 if $annoStart <= 1;
				$annoEnd = $chromSize if $annoEnd > $chromSize;
				$annoRegHsh_ref->{$annoType}{$geneID}{$chrom}{$annoStart}{$annoEnd}{$t_strnd}{$trnscptID}++;
			}	
			
			my @rngAry = sort {$a <=> $b} @{$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'exonRng'}};
			my $num_exon = @rngAry;
			for (my $i=0; $i < $#rngAry; $i += 2) {
				my ($start, $end) = ($rngAry[$i], $rngAry[$i+1]);
				my $annoType = "exon";
				my $annoStart = $start-1;
				my $annoEnd = $end;
				
				$annoStart = 1 if $annoStart <= 1;
				$annoEnd = $chromSize if $annoEnd > $chromSize;
				$annoRegHsh_ref->{$annoType}{$geneID}{$chrom}{$annoStart}{$annoEnd}{$t_strnd}{$trnscptID}++;
			}
			
			for (my $i=1; $i < ($#rngAry-1); $i += 2) {
				my ($start, $end) = ($rngAry[$i], $rngAry[$i+1]);

				my $annoType = "intron";
				my $annoStart = $start;
				my $annoEnd = $end-1;
			
				$annoStart = 1 if $annoStart <= 1;
				$annoEnd = $chromSize if $annoEnd > $chromSize;
				$annoRegHsh_ref->{$annoType}{$geneID}{$chrom}{$annoStart}{$annoEnd}{$t_strnd}{$trnscptID}++;
			}
		}
	}
	&reportAndLogStatus("$num_proc genes processed", 10, "\n");#->1091
	
	return ($annoRegHsh_ref);
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|134
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 149
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub printGeneInfo {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: reportAndLogStatus|1091
#	appearInSub: >none
#	primaryAppearInSection: 3_processInputData|154
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref, $outputPrefix, $result_tsv_dir
#	output: 
#	toCall: &printGeneInfo($geneInfoHsh_ref, $outputPrefix, $result_tsv_dir);
#	calledInLine: 165
#....................................................................................................................................................#
	my ($geneInfoHsh_ref, $outputPrefix, $result_tsv_dir) = @_;
	
	#---[6/12/14 21:40] based on ftp://ftp.sanger.ac.uk/pub/gencode/_README_stats.txt
	my %typeToCodingStatusHsh = (
		'protein_coding' => 'coding',
		'processed_transcript' => 'nonCoding',
		'lincRNA' => 'nonCoding',
		'3prime_overlapping_ncrna' => 'nonCoding',
		'antisense' => 'nonCoding',
		'non_coding' => 'nonCoding',
		'sense_intronic' => 'nonCoding',
		'sense_overlapping' => 'nonCoding',
	);

	open GENEBASEDINFO, ">", "$result_tsv_dir/gene.info.tsv";
	open TRNSCPTBASEDINFO, ">", "$result_tsv_dir/transcript.info.tsv";
	print GENEBASEDINFO join "", (join "\t", ('geneID', 'geneLocation', 'geneName', 'geneType', 'gene_codingStatus', 'numTrnscpt', 'chrom', 'strand', 'geneStart', 'geneEnd')), "\n";
	print TRNSCPTBASEDINFO join "", (join "\t", ('trnscptID', 'geneID', 'trnscptLocation', 'geneType', 'gene_codingStatus', 'geneName', 'chrom', 'strand', 'trnscptStart', 'trnscptEnd', 'exonStr')), "\n";
	&reportAndLogStatus("Printing gene and transcript info", 0, "\n");#->1091
	foreach my $geneID (sort keys %{$geneInfoHsh_ref}) {
		my $strand = $geneInfoHsh_ref->{$geneID}{'strand'};
		my $chrom = $geneInfoHsh_ref->{$geneID}{'chrom'};
		my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
		my $geneType = $geneInfoHsh_ref->{$geneID}{'geneType'};

		my ($geneStart, $geneEnd) = @{$geneInfoHsh_ref->{$geneID}{'geneRng'}};
		my $gene_codingStatus = "unspecified";
		$gene_codingStatus = $typeToCodingStatusHsh{$geneType} if exists $typeToCodingStatusHsh{$geneType};
		my $numTrnscpt = keys %{$geneInfoHsh_ref->{$geneID}{'trnscpt'}};
		my $geneLocation = $chrom.":".$geneStart."-".$geneEnd;
		
		print GENEBASEDINFO join "", (join "\t", ($geneID, $geneLocation, $geneName, $geneType, $gene_codingStatus, $numTrnscpt, $chrom, $strand, $geneStart, $geneEnd)), "\n";
		
		foreach my $trnscptID (sort keys %{$geneInfoHsh_ref->{$geneID}{'trnscpt'}}) {

			my ($trnscptStart, $trnscptEnd) = @{$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'trnscptRng'}};
			my $trnscptLocation = $chrom.":".$trnscptStart."-".$trnscptEnd;
			my @exonRngAry = sort {$a <=> $b} @{$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'exonRng'}};
			my @exonStrAry = ();
			for (my $i = 0; $i < $#exonRngAry; $i += 2) {
				my ($exonStart, $exonEnd) = ($exonRngAry[$i], $exonRngAry[$i+1]);
				push @exonStrAry, $exonStart."..".$exonEnd;
			}
			my $exonStr = join ";", @exonStrAry;
			print TRNSCPTBASEDINFO join "", (join "\t", ($trnscptID, $geneID, $trnscptLocation, $geneType, $gene_codingStatus, $geneName, $chrom, $strand, $trnscptStart, $trnscptEnd, $exonStr)), "\n";
		}
	}
	close GENEBASEDINFO;
	close TRNSCPTBASEDINFO;
	
	return ();
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_finishingTasks|170
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 173
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			@colLenCountHsh = sort {$b <=> $a} @colLenCountHsh;
			my $headerColLen = $colLenCountHsh[0]+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}
	
	@{$filelistLenCountHsh{'dir'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'dir'}};
	@{$filelistLenCountHsh{'name'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'name'}};
	@{$filelistLenCountHsh{'description'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'description'}};

	my $fileDir_colLen = $filelistLenCountHsh{'dir'}[0]+2;
	my $fileName_colLen = $filelistLenCountHsh{'name'}[0]+2;
	my $fileDescription_colLen = $filelistLenCountHsh{'description'}[0]+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printRegionBed {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: reportAndLogStatus|1091
#	appearInSub: >none
#	primaryAppearInSection: 3_processInputData|154
#	secondaryAppearInSection: >none
#	input: $annoRegHsh_ref, $bedtools_bin, $outputPrefix, $result_bed_dir
#	output: $region_bed_hsh_ref, $subtract_bed_hsh_ref
#	toCall: my ($subtract_bed_hsh_ref, $region_bed_hsh_ref) = &printRegionBed($annoRegHsh_ref, $outputPrefix, $result_bed_dir, $bedtools_bin);
#	calledInLine: 162
#....................................................................................................................................................#
	my ($annoRegHsh_ref, $outputPrefix, $result_bed_dir, $bedtools_bin) = @_;
	my $subtract_bed_hsh_ref = {};
	my $region_bed_hsh_ref = {};
	
	foreach my $annoType (keys %{$annoRegHsh_ref}) {
		&reportAndLogStatus("Printing $annoType bed", 0, "\n");#->1091
		my $nrd_bedID = "$annoType";
		my $trn_bedID = "$annoType.trnscpt_based";
		my $nrd_bed_path = "$result_bed_dir/$nrd_bedID.bed.gz";
		my $trn_bed_path = "$result_bed_dir/$trn_bedID.bed.gz";

		$region_bed_hsh_ref->{$nrd_bedID} = $nrd_bed_path;
		$region_bed_hsh_ref->{$trn_bedID} = $trn_bed_path;
		open NRDBED, "| sort -k1,1 -k2,2n | gzip -c >$nrd_bed_path";
		open TRNBED, "| sort -k1,1 -k2,2n | gzip -c >$trn_bed_path";

		foreach my $geneID (sort keys %{$annoRegHsh_ref->{$annoType}}) {
			my $num = 0;
			foreach my $chrom (sort keys %{$annoRegHsh_ref->{$annoType}{$geneID}}) {
				foreach my $annoStart (sort keys %{$annoRegHsh_ref->{$annoType}{$geneID}{$chrom}}) {
					foreach my $annoEnd (sort keys %{$annoRegHsh_ref->{$annoType}{$geneID}{$chrom}{$annoStart}}) {
						foreach my $strand (sort keys %{$annoRegHsh_ref->{$annoType}{$geneID}{$chrom}{$annoStart}{$annoEnd}}) {
							$num++;
							print NRDBED join "", (join "\t", ($chrom, $annoStart, $annoEnd, $geneID, 1, $strand)), "\n";
							my $trnscptID_str = join ";", keys %{$annoRegHsh_ref->{$annoType}{$geneID}{$chrom}{$annoStart}{$annoEnd}{$strand}};
							print TRNBED join "", (join "\t", ($chrom, $annoStart, $annoEnd, "$geneID|$trnscptID_str", 1, $strand)), "\n";
						}
					}
				}
			}
		}
		close NRDBED;
		close TRNBED;

		my $merged_bedID = "$annoType.merged";
		my $merged_bed_path = "$result_bed_dir/$merged_bedID.bed.gz";
		$region_bed_hsh_ref->{$merged_bedID} = $merged_bed_path;
		if ($annoType =~ m/TSS_flank_(\d+)/) {
			if ($1 > 0) {
				$subtract_bed_hsh_ref->{$annoType} = $merged_bed_path;
			}
		}
		
		system ("$bedtools_bin merge -delim ';' -s -c 4,5,6 -o distinct,count,distinct -i $nrd_bed_path | gzip -c >$merged_bed_path");
	}
	
	return ($subtract_bed_hsh_ref, $region_bed_hsh_ref);
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|363
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|134, 4_finishingTasks|170
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 148, 174
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->363
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->363
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->363
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->363
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub printTranscriptBed {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: reportAndLogStatus|1091
#	appearInSub: >none
#	primaryAppearInSection: 3_processInputData|154
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref, $outputPrefix, $result_bed_dir
#	output: 
#	toCall: &printTranscriptBed($geneInfoHsh_ref, $outputPrefix, $result_bed_dir);
#	calledInLine: 164
#....................................................................................................................................................#
	my ($geneInfoHsh_ref, $outputPrefix, $result_bed_dir) = @_;
	
	my %BEDtrnscptLineHsh = ();
	my %uniqueIDTypeHsh = ();
	my %typeInfoHsh = ();

	my %strandToRGBHsh = (
		'-' => '.',
		'+' => '.',
	);

	&reportAndLogStatus("Printing trancript and gene BED files", 10, "\n");#->1091

	open (ALLTRNSCPTANNO, "| sort -k1,1 -k2,2n  | gzip -c >$result_bed_dir/transcript.bed.gz");
	open (ALLGENEANNO, "| sort -k1,1 -k2,2n  | gzip -c >$result_bed_dir/gene.bed.gz");

	foreach my $geneID (keys %{$geneInfoHsh_ref}) {
		my $geneType = $geneInfoHsh_ref->{$geneID}{'geneType'};
		my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
		my $chrom = $geneInfoHsh_ref->{$geneID}{'chrom'};
		my $strand = $geneInfoHsh_ref->{$geneID}{'strand'};
		my $itemRgb = $strandToRGBHsh{$strand};
		{#---[5/29/14 12:50] get the geneLine
			my ($geneStart, $geneEnd) = @{$geneInfoHsh_ref->{$geneID}{'geneRng'}};
			my $chromStart = $geneStart - 1;
			my $chromEnd = $geneEnd;
			my $score = 1000;
			my $thickStart = $chromStart;
			my $thickEnd = $chromEnd;
			my $blockCount = 1;
			my $blockSizes = $chromEnd - $chromStart + 1;
			my $blockStarts = 0;
			print ALLGENEANNO join "", (join "\t", ($chrom, $chromStart, $chromEnd, $geneID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts)), "\n";
			
		}

		#---[5/29/14 12:50] get the trnscptLine
		foreach my $trnscptID (keys %{$geneInfoHsh_ref->{$geneID}{'trnscpt'}}) {
			my ($trnscptStart, $trnscptEnd) = @{$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'trnscptRng'}};
			my $chromStart = $trnscptStart - 1;
			my $chromEnd = $trnscptEnd;
			my $score = 1000;
			my $thickStart = $chromStart;
			my $thickEnd = $chromEnd;
			my @rngAry = sort {$a <=> $b} @{$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'exonRng'}};
			my $blockCount = 0;
			my @blockSizesAry = ();
			my @blockStartsAry = ();
			for (my $i=0; $i < $#rngAry; $i += 2) {
				$blockCount++;
				my ($start, $end) = ($rngAry[$i], $rngAry[$i+1]);
				my $blockSize = $end - $start + 1;
				my $blockStart = $start - $chromStart - 1;
				push @blockSizesAry, $blockSize;
				push @blockStartsAry, $blockStart;
			}
			my $blockSizes = join ",", @blockSizesAry;
			my $blockStarts = join ",", @blockStartsAry;
			print ALLTRNSCPTANNO join "", (join "\t", ($chrom, $chromStart, $chromEnd, $trnscptID, $score, $strand, $thickStart, $thickEnd, $itemRgb, $blockCount, $blockSizes, $blockStarts)), "\n";
		}
	}
	return ();
}
sub readChromSize {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_processInputData|154
#	secondaryAppearInSection: >none
#	input: $chrom_list_path, $out_fai_path, $result_tsv_dir
#	output: $chromSizeHsh_ref
#	toCall: my ($chromSizeHsh_ref) = &readChromSize($out_fai_path, $chrom_list_path, $result_tsv_dir);
#	calledInLine: 159
#....................................................................................................................................................#
	my ($out_fai_path, $chrom_list_path, $result_tsv_dir) = @_;
	
	my $chromSizeHsh_ref = {};
	
	open (FILEIN, "<", $chrom_list_path);
	while (<FILEIN>) {
		next if $_ =~ m/^#/;
		chomp;
		my ($chrom, $bam_chrom_name) = split /\t/;
		$chromSizeHsh_ref->{$chrom}{'bam_chrom_name'} = $bam_chrom_name;
	}
	close FILEIN;

	open (FILEIN, "<", $out_fai_path);
	while (<FILEIN>) {
		next if $_ =~ m/^#/;
		chomp;
		my ($chrom, $size) = split /\t/;
		if (exists $chromSizeHsh_ref->{$chrom}) {
			$chromSizeHsh_ref->{$chrom}{'size'} = $size;
		}
	}
	close FILEIN;

	my $out_chrom_size_path = "$result_tsv_dir/chrom.sizes.tsv";
	my $out_chrom_name_path = "$result_tsv_dir/chrom.bam_name.tsv";
	
	open CHROMSIZE, ">", $out_chrom_size_path;
	open CHROMBAMNAME, ">", $out_chrom_name_path;
	foreach my $chrom (sort keys %{$chromSizeHsh_ref}) {
		my $size = $chromSizeHsh_ref->{$chrom}{'size'};
		my $bam_chrom_name = $chromSizeHsh_ref->{$chrom}{'bam_chrom_name'};
		print CHROMSIZE join "", (join "\t", ($chrom, $size)), "\n";
		print CHROMBAMNAME join "", (join "\t", ($chrom, $bam_chrom_name)), "\n";
	}
	close CHROMBAMNAME;
	close CHROMSIZE;

	return ($chromSizeHsh_ref);
}
sub readGTF {
#....................................................................................................................................................#
#	subroutineCategory: GFF
#	dependOnSub: reportAndLogStatus|1091
#	appearInSub: >none
#	primaryAppearInSection: 3_processInputData|154
#	secondaryAppearInSection: >none
#	input: $chromSizeHsh_ref, $gtfPath
#	output: $geneInfoHsh_ref
#	toCall: my ($geneInfoHsh_ref) = &readGTF($gtfPath, $chromSizeHsh_ref);
#	calledInLine: 160
#....................................................................................................................................................#

	my ($gtfPath, $chromSizeHsh_ref) = @_;

	my $geneInfoHsh_ref = {};
	
	if ($gtfPath =~ m/\.gtf$/) {
		open (GTF, "<", $gtfPath);
	} elsif ($gtfPath =~ m/\.gtf\.gz$/) {
		open (GTF, " gzip -dc  $gtfPath|");
	} else {
		die;
	}
	
	&reportAndLogStatus("Reading GTF", 10, "\n");#->1091

	#from http://asia.ensembl.org/info/website/upload/gff.html
	#seqname - name of the chromosome or scaffold; chromosome names can be given with or without the 'chr' prefix.
	#source - name of the program that generated this feature, or the data source (database or project name)
	#feature - feature type name, e.g. Gene, Variation, Similarity
	#start - Start position of the feature, with sequence numbering starting at 1.
	#end - End position of the feature, with sequence numbering starting at 1.
	#score - A floating point value.
	#strand - defined as + (forward) or - (reverse).
	#frame - One of '0', '1' or '2'. '0' indicates that the first base of the feature is the first base of a codon, '1' that the second base is the first base of a codon, and so on..
	#attribute - A semicolon-separated list of tag-value pairs, providing additional information about each feature.		
	
	my $lineProc = 0;
	my $lineSkip = 0;
	while (<GTF>) {
		chomp;
		$lineProc++;
		&reportAndLogStatus("$lineProc lines processed and $lineSkip lines skipped", 10, "\n") if $lineProc % 10000 == 0;	#->1091
		next if $_ =~ m/^#/;
		last if $_ =~ m/^##FASTA/;
		
		my ($seqname, $source, $lineType, $start, $end, $score, $strand, $frame, $attributeStr) = split /\t/;
		
		#chr1	mitranscriptome	transcript	38817620	38822140	1000.0	-	.	tcat "lncrna"; gene_id "G001796"; tss_id "TSS003710"; uce "FALSE"; transcript_id "T008413"; tstatus "unannotated"; tgenic "intergenic"; func_name_final "NA";
		foreach my $value ($seqname, $lineType, $start, $end, $strand) {
			if (not defined $value) {
				&reportAndLogStatus("############################", 10, "\n");#->1091
				&reportAndLogStatus("$_", 10, "\n");#->1091
				&reportAndLogStatus("############################", 10, "\n");#->1091
				die "miss value in GTF\n";
			}
		}
		
		if (not exists $chromSizeHsh_ref->{$seqname}) {
			$lineSkip++;
			next;
		}
		
		if ($lineType eq "gene") {
			#chr1	FANTOM	gene	47082703	47083645	.	+	.	gene_id "CATG00000000004.1"; geneSuperClass "all_lncRNA";  geneClass "CATG00000000004.1";  geneSubClass "divergent_promoters"; geneType "__na"; gene_name "CATG00000000004.1"; coding_status "nonCoding"; cumulative_support "ENCODE"; geneCategory "p_lncRNA_divergent"; DHS_type "DHS_promoter";
			if ($attributeStr =~ m/gene_id "([^\"\ \;]+)"/) {
				my $geneID = $1;
				$geneInfoHsh_ref->{$geneID}{'strand'} = $strand;
				$geneInfoHsh_ref->{$geneID}{'chrom'} = $seqname;

				foreach my $geneInfo (qw/gene_type gene_name/) {
					my $val = '__na';
					$val = $1 if ($attributeStr =~ m/$geneInfo "?([^\"\ \;]+)"? ?;/);
					if ($geneInfo eq 'gene_type') {
						$geneInfoHsh_ref->{$geneID}{'geneType'} = $val;
					} elsif ($geneInfo eq 'gene_name') {
						$geneInfoHsh_ref->{$geneID}{'geneName'} = $val;
					}
				}

			} else {
				die "undefined gene_id in gene line: gtf format error\n";
			}
		}

		if ($lineType eq "exon") {
			my $geneID = undef;
			my $trnscptID = undef;
			$geneID = $1 if ($attributeStr =~ m/gene_id "([^\"\ \;]+)"/);
			$trnscptID = $1 if ($attributeStr =~ m/transcript_id "([^\"\ \;]+)"/);
			if (not defined $geneID or not defined $trnscptID) {
				print "geneID=$geneID\n";
				print "trnscptID=$trnscptID\n";
				print "$_\n";
				die "undefined gene_id and transcript_id: gtf format error\n";
			}

			if (not exists $geneInfoHsh_ref->{$geneID}) {
				$geneInfoHsh_ref->{$geneID}{'strand'} = $strand;
				$geneInfoHsh_ref->{$geneID}{'chrom'} = $seqname;

				foreach my $geneInfo (qw/gene_type gene_name/) {
					my $val = '__na';
					$val = $1 if ($attributeStr =~ m/$geneInfo "?([^\"\ \;]+)"? ?;/);
					if ($geneInfo eq 'gene_type') {
						$geneInfoHsh_ref->{$geneID}{'geneType'} = $val;
					} elsif ($geneInfo eq 'gene_name') {
						$geneInfoHsh_ref->{$geneID}{'geneName'} = $val;
					}
				}
			}
	
			push @{$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'exonRng'}}, ($start, $end);
			$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'exonNum'}++;
			$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'strand'} = $strand;

		}
	}#---end of while (my $theLine = <INFILE>)
	close GTF;
	
	my $numGene = 0;
	my $numTrnscpt = 0;
	my $numGene_valid = 0;
	my $numTrnscpt_valid = 0;
	foreach my $geneID (keys %{$geneInfoHsh_ref}) {
		$numGene++;
		$numGene_valid++ if $geneInfoHsh_ref->{$geneID}{'strand'} ne '.';
		my @allRngAry = ();
		foreach my $trnscptID (keys %{$geneInfoHsh_ref->{$geneID}{'trnscpt'}}) {
			$numTrnscpt++;
			$numTrnscpt_valid++ if $geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'strand'} ne '.';
			my @rngAry = sort {$a <=> $b} @{$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'exonRng'}};
			my $exonLen = 0;
			my $trnscptStart = $rngAry[0];
			my $trnscptEnd = $rngAry[-1];
			push @allRngAry, ($trnscptStart, $trnscptEnd);
			for (my $i=0; $i < $#rngAry; $i += 2) {
				my ($start, $end) = ($rngAry[$i], $rngAry[$i+1]);
				my $blockSize = $end - $start + 1;
				$exonLen += $blockSize;
			}
			$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'exonLen'} = $exonLen;
			@{$geneInfoHsh_ref->{$geneID}{'trnscpt'}{$trnscptID}{'trnscptRng'}} = ($trnscptStart, $trnscptEnd);
		}
		@allRngAry = sort {$a <=> $b} @allRngAry;
		my $geneStart = $allRngAry[0];
		my $genetEnd = $allRngAry[-1];
		
		$geneInfoHsh_ref->{$geneID}{'geneRng'} = [$geneStart, $genetEnd];
	}
	
	&reportAndLogStatus("$numGene gene read. $numGene_valid are stranded.", 10, "\n"); #->1091
	&reportAndLogStatus("$numTrnscpt trnscpt read. $numTrnscpt_valid are stranded.", 10, "\n"); #->1091

	return ($geneInfoHsh_ref);
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|117
#	secondaryAppearInSection: >none
#	input: none
#	output: $chrom_list_path, $fasta_path, $gtf_path, $mask_bed_path, $outDir, $outputPrefix, $overwrite
#	toCall: my ($gtf_path, $fasta_path, $chrom_list_path, $mask_bed_path, $outputPrefix, $outDir, $overwrite) = &readParameters();
#	calledInLine: 120
#....................................................................................................................................................#
	
	my ($gtf_path, $fasta_path, $chrom_list_path, $mask_bed_path, $outputPrefix, $outDir, $overwrite);

	$overwrite = 'no';

	GetOptions 	(
		"gtf_path=s"			=>	\$gtf_path,
		"fasta_path=s"			=>	\$fasta_path,
		"chrom_list_path=s"	=>	\$chrom_list_path,
		"mask_bed_path=s"		=>	\$mask_bed_path,
		"outputPrefix=s"		=>	\$outputPrefix,
		"outDir:s"				=>	\$outDir,
		"overwrite:s"			=>	\$overwrite,
		'help'					=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $gtf_path;
	
	#---check file
	my $file_check_hsh_ref = {
		'gtf_path' => $gtf_path,
		'fasta_path' => $fasta_path,
		'chrom_list_path' => $chrom_list_path,
		'mask_bed_path' => $mask_bed_path,
	};
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}
	
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
	
	return($gtf_path, $fasta_path, $chrom_list_path, $mask_bed_path, $outputPrefix, $outDir, $overwrite);
}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|363
#	appearInSub: checkAllExecutable|212, copySourceFile|312, generateAnnotationRegion|381, printGeneInfo|481, printRegionBed|665, printTranscriptBed|759, readGTF|886, subtractMask|1113
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_processInputData|154
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 235, 240, 249, 258, 267, 276, 285, 294, 303, 330, 339, 342, 351, 396, 401, 451, 510, 681, 781, 910, 928, 937, 938, 939, 1037, 1038, 1131
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->363
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->363
	
	return ();
}
sub subtractMask {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|1091
#	appearInSub: >none
#	primaryAppearInSection: 3_processInputData|154
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $mask_bed_path, $region_bed_hsh_ref, $result_bed_dir, $subtract_bed_hsh_ref
#	output: 
#	toCall: &subtractMask($region_bed_hsh_ref, $mask_bed_path, $bedtools_bin, $result_bed_dir, $subtract_bed_hsh_ref);
#	calledInLine: 163
#....................................................................................................................................................#
	my ($region_bed_hsh_ref, $mask_bed_path, $bedtools_bin, $result_bed_dir, $subtract_bed_hsh_ref) = @_;

	$subtract_bed_hsh_ref->{'mask'} = $mask_bed_path;

	foreach my $bedID (keys %{$region_bed_hsh_ref}) {
		if ($bedID =~ m/exon/ or $bedID =~ m/intron/) {
			my $region_bed_path = $region_bed_hsh_ref->{$bedID};
			&reportAndLogStatus("masking $bedID", 10, "\n");#->1091
			foreach my $subtract_annotype (keys %{$subtract_bed_hsh_ref}) {
				my $subtract_annotype_bed_path = $subtract_bed_hsh_ref->{$subtract_annotype};
				my $subtracted_region_bed_path = "$result_bed_dir/$bedID.subtract_$subtract_annotype.bed.gz";
				system "$bedtools_bin subtract -a $region_bed_path -b $subtract_annotype_bed_path | sort -k1,1 -k2,2n | gzip -c >$subtracted_region_bed_path";
			}
		}
	}

	return ();
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 105
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































