#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use List::Util qw (sum shuffle min max);
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                                 ---> scafe.tool.cm.annotate <---
                     <--- tool, common mode, define and annotate tCRE --->

 Description:
   This tool defines tCRE from TSS clusters and annotates them based their overlap with gene models.

 Usage:
   scafe.tool.cm.annotate [options] --tssCluster_bed_path --tssCluster_info_path --genome --outputPrefix --outDir
   
   --tssCluster_bed_path       <required> [string]   bed file contains the ranges of filtered TSS clusters,
                                                     *.tssCluster.*.filtered.bed.gz from scafe.tool.cm.filter.pl
   --tssCluster_info_path      <required> [string]   tsv file contains the information of all TSS clusters,
                                                     *.tssCluster.log.tsv from scafe.tool.cm.filter.pl
   --genome                    <required> [string]   name of genome reference, e.g. hg19.gencode_v32lift37
   --outputPrefix              <required> [string]   prefix for the output files
   --outDir                    <required> [string]   directory for the output files
   --up_end5Rng                (optional) [integer]  TSS clusters will be classified as gene TSS, exonic, intron 
                                                     and intergenic. $up_end5Rng determines the range upstream of 
                                                     annotated gene TSS to be used for gene TSS assignment 
                                                     (default = 500)
   --dn_end5Rng                (optional) [integer]  TSS clusters will be classified as gene TSS, exonic, intron 
                                                     and intergenic. $dn_end5Rng determines the range downstream of 
                                                     annotated gene TSS to be used for gene TSS assignment 
                                                     (default = 500)
   --exon_slop_rng             (optional) [integer]  TSS clusters will be classified as gene TSS, exonic, intron 
                                                     and intergenic. $exon_slop_rng determines the range to be extended
                                                     (i.e. slopped) from exon for assignment of exonic class. 
                                                     Used -1 to NOT to extend (default = -1)
   --merge_dist                (optional) [integer]  TSS clusters outside annotated gene promoters are grouped
                                                     as "dummy genes" (for operational uniformity) by merging closely 
                                                     located TSS clusters.  $merge_dist determines the maximum distances 
                                                     between TSS clusters to be merged (default = 500)
   --addon_length              (optional) [integer]  see $merge_dist. add-on "dummy transcrips" will assigned to TSS cluster of 
                                                     "dummy genes" (for operational uniformity).$addon_length determines 
                                                     the length of these add-on "dummy transcrips" (default = 500).
   --proximity_slop_rng        (optional) [integer]  TSS clusters will be assigned to annotated gene TSS are "proximal"
                                                     TSS clusters. $proximity_slop_rng determines the range to be extended
                                                     (i.e. slopped) from gene TSS for assignment of proximal TSS clusters. 
                                                     (default = 500)
   --merge_strandness          (optional) [string]   see $merge_dist. $merge_strandness decides the merge to be 
                                                     strand-aware ("stranded") or strand-agnostic "strandless".
                                                     (default = strandless)
   --proximal_strandness       (optional) [string]   closely located proximal TSS clusters are merged  
                                                     tCREs. $proximal_strandness decides the merge to be 
                                                     strand-aware ("stranded") or strand-agnostic "strandless".
                                                     (default = stranded)
   --CRE_extend_size           (optional) [integer]  tCREs were defined by merging the extended ranges of TSS clusters.
                                                     $CRE_extend_size determine the size of this range (both sides of 
                                                     summit) (default = 500)
   --CRE_extend_upstrm_ratio   (optional) [float]    see $CRE_extend_size. $CRE_extend_upstrm_ratio determines the ratio 
                                                     (X:1) of flanking sizes on the upstream and downstream of summit. 
                                                     e.g. $CRE_extend_upstrm_ratio=4, upstream and downstream size will be 
                                                     taken as 4:1 ratio. $CRE_extend_size=500 and $CRE_extend_upstrm_ratio=4,
                                                     upstream and downstream will be 400 and 100 respectively 
                                                     (default = 4)
   --stitch_distance           (optional) [integer]  distance (nt) for stitching distal tCRE for defining hyperactive distal loci.
                                                     aka superenhancer candidates. If undefined, an optimized value will be 
                                                     determined based on the tangent to rank-distance plot. As a note, the original 
                                                     distance for stitching enhancer in 
                                                     ROSE (http://younglab.wi.mit.edu/super_enhancer_code.html) is 12,500.
                                                     (default = undefined)
   --min_total_exp_frac        (optional) [fraction] minimum fraction of the expression amount (read/UMI) within a gene for an annotated 
                                                     tCRE to be regarded as an unannotated promoter of the gene. The total expression amount 
                                                     of a gene is defined as the total number of UMI/read of all its annotated promoters.
                                                     (default = 0.1)
   --min_gene_strand_read_frac (optional) [fraction] minimum fraction of the expression amount (read/UMI) on the gene strand (in total number 
                                                     of UMI/read both strand) of a tCRE to be regarded as an unannotated promoter of the gene.
                                                     (default = 0.8)
   --min_spreadness            (optional) [fraction] minimum spreadness of the distal CRE to be considered as hyperactive distal loci.
                                                     Spreadness is defined as "num-of-CRE/top-fraction". Top-fraction is defined as the expression 
                                                     amount (read/UMI) on the highest expressed distal CRE in the expression amount of all distal CRE 
                                                     within the locus. Num-of-CRE refers to the number of CRE within the distal CRE locus 
                                                     (default = 4, equivalent to Num-of-CRE=3 and Top-fraction = 0.75, i.e. 3/0.75 = 4)
   --Rscript_bin               (optional) [string]   path to the Rscript bin, aim to allow users to supply an R version other the 
                                                     system wide R version. Package Caret must be installed. (default = Rscript)
   --overwrite                 (optional) [yes/no]   erase outDir/outputPrefix before running (default=no)
 
 Dependencies:
   bedtools,
   R packages: 'ggplot2'

 For demo, cd to SCAFE dir and run,
   scafe.tool.cm.annotate \
   --overwrite=yes \
   --tssCluster_bed_path=./demo/output/sc.solo/filter/demo/bed/demo.tssCluster.default.filtered.bed.gz \
   --tssCluster_info_path=./demo/output/sc.solo/filter/demo/log/demo.tssCluster.log.tsv \
   --genome=hg19.gencode_v32lift37 \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.solo/annotate/

=head1 VERSION

v0.9.0-beta [March 20, 2021]
   -Initial pre-release

v1.0.0 [June 6, 2022]
   -Added hyperactive distal tCRE locus definition with uniformity restritions (using --min_spreadness)
   -Annotate potential alternative promoters

=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->3161
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->695
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($exon_slop_rng, $addon_length, $merge_dist, $up_end5Rng, $dn_end5Rng, $tssCluster_bed_path, $tssCluster_info_path, $merge_strandness, $proximity_slop_rng, $CRE_extend_size, $CRE_extend_upstrm_ratio, $genome, $proximal_strandness, $stitch_distance, $min_total_exp_frac, $min_gene_strand_read_frac, $min_spreadness, $Rscript_bin, $outputPrefix, $outDir, $overwrite) = &readParameters();#->2676
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $mask_class_hsh_ref = {
	'Mt_rRNA' => 1,
	'Mt_tRNA' => 1,
	'rRNA' => 1,
	'snRNA' => 1,
	'snoRNA' => 1,
	'structural_RNA' => 1,
	'small_RNA' => 1,
	'miRNA' => 1,
};
my $max_dist_rank = 100000; #---[2021/08/04 22:13] maximum distance to be used for optimize tangent for optimize distal tCRE stitching
my $paramTag = "$outputPrefix";
#$chrom_size_path, $gene_info_path, $transcript_bed_path, $transcript_info_path,
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineOutDirPath
#
#<section ID="defineOutDirPath" num="2">
my @mkDirAry;
my $result_dir = "$outDir/$paramTag/"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $result_bed_dir = "$result_dir/bed/"; push @mkDirAry, $result_bed_dir;
my $result_gtf_dir = "$result_dir/gtf/"; push @mkDirAry, $result_gtf_dir;
my $tmp_bed_dir = "$result_dir/bed/tmp/"; push @mkDirAry, $tmp_bed_dir;
my $result_log_dir = "$result_dir/log/"; push @mkDirAry, $result_log_dir;
my $result_plot_dir = "$result_dir/plot/"; push @mkDirAry, $result_plot_dir;
my $result_script_dir = "$result_dir/script/"; push @mkDirAry, $result_script_dir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 755 $dir");}

open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->1407
&printStartOrFinishMessage("startMessage");#->1760
my ($bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();#->553
my ($chrom_size_path, $gene_info_path, $transcript_info_path, $transcript_bed_path) = &checkTranscriptInfoBedChromSizeGeneInfoPath($genome);#->666
my ($optimize_tangent_R) = &checkRScriptVersion($Rscript_bin);#->633
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_readInfo
#
#<section ID="readInfo" num="3">
my ($chrom_size_hsh_ref) = &readChromSize($chrom_size_path);#->2454
my ($trnscptInfoHsh_ref, $transcript_in_scope_bed_path) = &readTranscriptBed($transcript_bed_path, $chrom_size_hsh_ref, $tmp_bed_dir, $outDir);#->2751
my ($geneInfoHsh_ref) = &readTranscriptInfo($transcript_info_path, $trnscptInfoHsh_ref);#->2830
&readGeneInfo($gene_info_path, $geneInfoHsh_ref);#->2604
my ($coding_class_hsh_ref) = &defineCodingClasses();#->787
my ($end5_rng_bed_path, $end5_point_bed_path) = &printEnd5Bed($trnscptInfoHsh_ref, $up_end5Rng, $dn_end5Rng, $tmp_bed_dir);#->1514
my ($clusterInfoHsh_ref) = &readClusterBed($tssCluster_bed_path);#->2479
&readClusterInfo($tssCluster_info_path, $clusterInfoHsh_ref);#->2543
my ($extended_tssCluster_bed_path) = &generateExtendedCluster($clusterInfoHsh_ref, $tmp_bed_dir, $CRE_extend_size, $CRE_extend_upstrm_ratio);#->1198
&intersectCluster($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_rng_bed_path, $chrom_size_path, $exon_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin);#->1346
&filterUnannotatedCluster($clusterInfoHsh_ref);#->1119
my ($superClusterHsh_ref) = &getSuperCluster($tmp_bed_dir, $clusterInfoHsh_ref, $merge_dist, $merge_strandness, $bedtools_bin);#->1291
&addonTranscript($superClusterHsh_ref, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $addon_length, $chrom_size_hsh_ref);#->348
&summerizeGeneInfo($geneInfoHsh_ref, $trnscptInfoHsh_ref);#->3103
&addGeneMask($geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $mask_class_hsh_ref);#->313
&assignClusterProximity($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_point_bed_path, $chrom_size_path, $proximity_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin);#->445
&rankClusterWithinGene($clusterInfoHsh_ref, $geneInfoHsh_ref);#->2396
my ($CREInfoHsh_ref) = &defineCRE($CRE_extend_size, $CRE_extend_upstrm_ratio, $clusterInfoHsh_ref, $tmp_bed_dir, $chrom_size_path, $bedtools_bin, $proximal_strandness, $extended_tssCluster_bed_path);#->713
&summerizeCREInfo($clusterInfoHsh_ref, $CREInfoHsh_ref, $geneInfoHsh_ref);#->3025
&rankCREWithinGene($CREInfoHsh_ref, $geneInfoHsh_ref);#->2338
&removeUnsupportedGene($geneInfoHsh_ref, $trnscptInfoHsh_ref);#->2911
my ($gene_promoter_CRE_pair_hsh_ref) = &defineUnannoPromoter($CREInfoHsh_ref, $geneInfoHsh_ref, $min_total_exp_frac, $min_gene_strand_read_frac, $clusterInfoHsh_ref);#->1002
my ($distal_CRE_locus_info_hsh_ref) = &defineHyperactiveDistalLoci($CREInfoHsh_ref, $tmp_bed_dir, $bedtools_bin, $optimize_tangent_R, $max_dist_rank, $Rscript_bin, $stitch_distance, $min_spreadness, $result_plot_dir);#->861
my ($gene_promoter_info_hsh_ref) = &generateGenePromoterInfoHsh($CREInfoHsh_ref);#->1264
&printAllBed($result_bed_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $distal_CRE_locus_info_hsh_ref, $gene_promoter_info_hsh_ref, $outputPrefix);#->1432
&printTableClusterInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);#->1930
&printTableGeneInfo($result_log_dir, $geneInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);#->2099
&printTableIDMappingInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);#->2161
&printTableTranscriptInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);#->2221
&printTableCREInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);#->1794
&printTrnscptGtf($result_gtf_dir, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $outputPrefix);#->2278
&printTableDistalCRELocusInfo($result_log_dir, $distal_CRE_locus_info_hsh_ref, $outputPrefix);#->2045
&printGenePromoterInfo($result_log_dir, $gene_promoter_CRE_pair_hsh_ref, $geneInfoHsh_ref, $CREInfoHsh_ref, $outputPrefix);#->1595
&removeTmpBedDir($tmp_bed_dir);#->2892
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_finishingTasks
#
#<section ID="finishingTasks" num="4">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->1640
&printStartOrFinishMessage("finishMessage");#->1760
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	checkTools [n=1]:
#		checkRScriptVersion
#
#	general [n=6]:
#		checkRScriptVersion, currentTime, logCalledCMDAndScript
#		printStartOrFinishMessage, readParameters, timeStamp
#
#	getTextInfo [n=1]:
#		readGeneInfo
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	specific [n=1]:
#		printTrnscptGtf
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=37]:
#		addGeneMask, addonTranscript, assignClusterProximity
#		checkAllExecutable, checkTranscriptInfoBedChromSizeGeneInfoPath, defineCRE
#		defineCodingClasses, defineHyperactiveDistalLoci, defineUnannoPromoter
#		exonRngToGtf, filterUnannotatedCluster, generateAddonGene
#		generateExtendedCluster, generateGenePromoterInfoHsh, getSuperCluster
#		intersectCluster, printAllBed, printEnd5Bed
#		printGenePromoterInfo, printTableCREInfo, printTableClusterInfo
#		printTableDistalCRELocusInfo, printTableGeneInfo, printTableIDMappingInfo
#		printTableTranscriptInfo, rankCREWithinGene, rankClusterWithinGene
#		readChromSize, readClusterBed, readClusterInfo
#		readTranscriptBed, readTranscriptInfo, removeTmpBedDir
#		removeUnsupportedGene, storeCREInfoFromBed, summerizeCREInfo
#		summerizeGeneInfo
#
#====================================================================================================================================================#

sub addGeneMask {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref, $geneInfoHsh_ref, $mask_class_hsh_ref, $trnscptInfoHsh_ref
#	output: 
#	toCall: &addGeneMask($geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $mask_class_hsh_ref);
#	calledInLine: 234
#....................................................................................................................................................#
	my ($geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $mask_class_hsh_ref) = @_;
	
	foreach my $geneID (keys %{$geneInfoHsh_ref}) {
		my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
		my $mask = 'no';
		$mask = 'yes' if exists $mask_class_hsh_ref->{$geneClass};
		$geneInfoHsh_ref->{$geneID}{'mask'} = $mask;
		foreach my $trnscptID (keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}}) {
			#die "$trnscptID\n" if not exists $trnscptInfoHsh_ref->{$trnscptID}{'bedLine'};
			$trnscptInfoHsh_ref->{$trnscptID}{'mask'} = $mask;
		}
	}
	
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		my $mask = 'yes';
		foreach my $geneID (keys %{$clusterInfoHsh_ref->{$clusterID}{'geneID'}}) {
			$mask = 'no' if $geneInfoHsh_ref->{$geneID}{'mask'} eq 'no';
		}
		$clusterInfoHsh_ref->{$clusterID}{'mask'} = $mask;
	}
	
	return ();
}
sub addonTranscript {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: generateAddonGene|1150, reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $addon_length, $chrom_size_hsh_ref, $clusterInfoHsh_ref, $geneInfoHsh_ref, $superClusterHsh_ref, $trnscptInfoHsh_ref
#	output: none
#	toCall: &addonTranscript($superClusterHsh_ref, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $addon_length, $chrom_size_hsh_ref);
#	calledInLine: 232
#....................................................................................................................................................#
	
	my ($superClusterHsh_ref, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $addon_length, $chrom_size_hsh_ref) = @_;

	my $trnscptIDHsh_ref = {};

	&reportAndLogStatus("creating addon transcripts", 10, "\n");#->2953
	foreach my $superclusterID (keys %{$superClusterHsh_ref}) {
		
		my ($geneID, $addon_chrom) = &generateAddonGene($superClusterHsh_ref, $clusterInfoHsh_ref, $superclusterID);#->1150

		$geneInfoHsh_ref->{$geneID}{'geneName'} = $geneID;
		$geneInfoHsh_ref->{$geneID}{'geneClass'} = 'unanno_tss';
		
		foreach my $clusterID (@{$superClusterHsh_ref->{$superclusterID}}) {

			my $strand = $clusterInfoHsh_ref->{$clusterID}{'strand'};
			my $chrom = $clusterInfoHsh_ref->{$clusterID}{'chrom'};
			
			my $start = $clusterInfoHsh_ref->{$clusterID}{'start'};
			my $end = $clusterInfoHsh_ref->{$clusterID}{'end'};
			my $peakPos = $clusterInfoHsh_ref->{$clusterID}{'peakPos'};
			my @t_strandAry = ();

			if ($strand eq '.') {
				push @t_strandAry, '+';
				push @t_strandAry, '-';
			} else {
				push @t_strandAry, $strand;
			}

			foreach my $t_strand (@t_strandAry) {
				my $t_start;
				my $t_end;
				my $addon_t_strand;
				
				if ($t_strand eq '+') {
					$t_start = $peakPos;
					$t_end = $t_start + $addon_length;
					$addon_t_strand = 'F';
				} else {
					$t_start = $peakPos - $addon_length;
					$t_end = $peakPos;
					$addon_t_strand = 'R';
				}
				
				$t_start = 1 if $t_start < 1;
				$t_end = $chrom_size_hsh_ref->{$chrom}-1 if $t_end >= $chrom_size_hsh_ref->{$chrom};
				
				my $addon_t_start = sprintf "%.9d", $t_start;

				my $trnscptID = "ADDT".$addon_chrom.$addon_t_start.'.'.$addon_t_strand;

				if (exists $trnscptInfoHsh_ref->{$trnscptID}) {
					$trnscptIDHsh_ref->{$trnscptID}++;
					$trnscptID = "ADDT".$addon_chrom.$addon_t_start.'.'.$addon_t_strand.$trnscptIDHsh_ref->{$trnscptID};
				}
				
				$trnscptIDHsh_ref->{$trnscptID}++;
				$trnscptInfoHsh_ref->{$trnscptID}{'chrom'} = $chrom;
				$trnscptInfoHsh_ref->{$trnscptID}{'strand'} = $t_strand;
				@{$trnscptInfoHsh_ref->{$trnscptID}{'exonRng'}} = ($t_start, $t_end);

				$clusterInfoHsh_ref->{$clusterID}{'trnscptID'}{$trnscptID} = 'addon';
				$clusterInfoHsh_ref->{$clusterID}{'geneID'}{$geneID}++;

				$trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID} = 'addon';
				$trnscptInfoHsh_ref->{$trnscptID}{'geneID'} = $geneID;

				$geneInfoHsh_ref->{$geneID}{'clusterID'}{$clusterID} = 'addon';
				$geneInfoHsh_ref->{$geneID}{'trnscptID'}{$trnscptID}++;

				my $chromStart = $t_start - 1;
				my $chromEnd = $t_end;
				my $thickStart = $chromStart;
				my $thickEnd = $chromEnd;
				my $blockSizes = $chromEnd - $chromStart;
				my $blockCount = 1;
				my $blockStarts = 0;
	
				$trnscptInfoHsh_ref->{$trnscptID}{'bedLine'} = [$chrom, $chromStart, $chromEnd, $trnscptID, '0', $t_strand, $thickStart, $thickEnd, ".", $blockCount, $blockSizes, $blockStarts];

			}
		}
	}	
}
sub assignClusterProximity {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $chrom_size_path, $clusterInfoHsh_ref, $end5_point_bed_path, $geneInfoHsh_ref, $proximity_slop_rng, $transcript_in_scope_bed_path, $trnscptInfoHsh_ref, $tssCluster_bed_path
#	output: none
#	toCall: &assignClusterProximity($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_point_bed_path, $chrom_size_path, $proximity_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin);
#	calledInLine: 235
#....................................................................................................................................................#
	
	my ($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_point_bed_path, $chrom_size_path, $proximity_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin) = @_;

	&reportAndLogStatus("assigning region to cluster", 10, "\n");#->2953
	
	my $region_cmd_hsh_ref = {
		'end5' => {
			'in_bed6_cmd' => "cut -f 1-6 $end5_point_bed_path",
			'slop_rng' => $proximity_slop_rng,
		},
		'exon' => {
			'in_bed6_cmd' => "$bedtools_bin bed12tobed6 -i $transcript_in_scope_bed_path",
			'slop_rng' => 0,
		},
		'intron' => {
			'in_bed6_cmd' => "cut -f 1-6 $transcript_in_scope_bed_path",
			'slop_rng' => 0,
		},
	};
	
	foreach my $regionType (qw/end5 exon intron/) {
		foreach my $oritentation (qw/ss as/) {
		
			&reportAndLogStatus("Getting cluster at $regionType $oritentation", 10, "\n");#->2953

			my $in_bed6_cmd = $region_cmd_hsh_ref->{$regionType}{'in_bed6_cmd'};
			my $slop_rng = $region_cmd_hsh_ref->{$regionType}{'slop_rng'};
			
			open BEDTOOLS, "$in_bed6_cmd | $bedtools_bin slop -b $slop_rng -i stdin -g $chrom_size_path | $bedtools_bin intersect -wo -a stdin -b $tssCluster_bed_path |" ;

			while (<BEDTOOLS>) {
				#chr10	13141663	13142302	ENST00000482140.5_1	1	+	chr10	13142075	13142193	p1@OPTN	247174	+	13142162	13142163	255,0,0	118
				my (@splt) = split /\t/;
				my $clusterID = $splt[9];
				next if exists $clusterInfoHsh_ref->{$clusterID}{'regionType'};

				my $cluster_strand = $splt[11];
				my $trnscpt_strand = $splt[5];
				my $trnscptID = $splt[3];
				
				my $oritentation_matched = 'no';
				my $assigned_orientation;

				if ($cluster_strand eq '.') {
					$oritentation_matched = 'yes';
					$assigned_orientation = 'ns';
					
				} elsif ($cluster_strand eq $trnscpt_strand and $oritentation eq 'ss') {
					$oritentation_matched = 'yes';
					$assigned_orientation = 'ss';
					
				
				} elsif ($cluster_strand ne $trnscpt_strand and $oritentation eq 'as') {
					$oritentation_matched = 'yes';
					$assigned_orientation = 'as';
				}
				
				if ($oritentation_matched eq 'yes') {

					die "$trnscptID does not exists in trnscptInfoHsh_ref\n" if not exists $trnscptInfoHsh_ref->{$trnscptID};
					die "$clusterID does not exists in clusterInfoHsh_ref\n" if not exists $clusterInfoHsh_ref->{$clusterID};

					my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
					
					$clusterInfoHsh_ref->{$clusterID}{'regionGeneID'} = $geneID;
					$clusterInfoHsh_ref->{$clusterID}{'regionType'} = $regionType;
					$clusterInfoHsh_ref->{$clusterID}{'regionOritentation'} = $oritentation;
				}
			}
			close BEDTOOLS;
		}
	}
	
	&reportAndLogStatus("Adding intergenic region type", 10, "\n");#->2953
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		if (not exists $clusterInfoHsh_ref->{$clusterID}{'regionType'}) {
			$clusterInfoHsh_ref->{$clusterID}{'regionGeneID'} = '__na';
			$clusterInfoHsh_ref->{$clusterID}{'regionType'} = 'intergenic';
			$clusterInfoHsh_ref->{$clusterID}{'regionOritentation'} = 'ns';
		}
	}

	&reportAndLogStatus("Adding proximity", 10, "\n");#->2953
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		if ($clusterInfoHsh_ref->{$clusterID}{'regionType'} eq 'end5') {
			$clusterInfoHsh_ref->{$clusterID}{'proximity'} = 'proximal';

		#} elsif ($clusterInfoHsh_ref->{$clusterID}{'regionType'} eq 'exon') {
			#$clusterInfoHsh_ref->{$clusterID}{'proximity'} = 'exonic';
		
		} else {
			$clusterInfoHsh_ref->{$clusterID}{'proximity'} = 'distal';
		}
	}

}
sub checkAllExecutable {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|193
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedGraphToBigWig_bin, $bedtools_bin, $bigWigAverageOverBed_bin, $cut_sh_path, $paraclu_bin, $samtools_bin
#	toCall: my ($bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();
#	calledInLine: 210
#....................................................................................................................................................#
	
	my $dirPath = dirname(rel2abs($0));

	my $bedtools_bin = "$dirPath/../resources/bin/bedtools/bedtools";
	my $samtools_bin = "$dirPath/../resources/bin/samtools/samtools";
	my $paraclu_bin = "$dirPath/../resources/bin/paraclu/paraclu";
	my $cut_sh_path = "$dirPath/../resources/bin/paraclu/paraclu-cut.sh";
	my $bedGraphToBigWig_bin = "$dirPath/../resources/bin/bedGraphToBigWig/bedGraphToBigWig";
	my $bigWigAverageOverBed_bin = "$dirPath/../resources/bin/bigWigAverageOverBed/bigWigAverageOverBed";
	
	&reportAndLogStatus("Checking all SCAFE executables", 10, "\n");#->2953
	
	{
		my $stdOut = `$bedtools_bin --version 2>&1`;
		if ($stdOut =~ m/bedtools v(\S+)/) {
			&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->2953
		} else {
			die "bedtools is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$samtools_bin 2>&1`;
		if ($stdOut =~ m/\s+(Version: \S+)\s+/) {
			&reportAndLogStatus("Checking: samtools version: $1", 0, "\n");#->2953
		} else {
			die "samtools is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$paraclu_bin 2>&1`;
		if ($stdOut =~ m/paraclu: I need a minValue and a fileName/) {
			&reportAndLogStatus("Checking: paraclu found.", 0, "\n");#->2953
		} else {
			die "paraclu is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$cut_sh_path 55C7128A 2>&1`;
		if ($stdOut =~ m/awk:/) {
			&reportAndLogStatus("Checking: paraclu-cut found.", 0, "\n");#->2953
		} else {
			die "paraclu-cut is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedGraphToBigWig_bin 2>&1`;
		if ($stdOut =~ m/bedGraphToBigWig v (\S+)/) {
			&reportAndLogStatus("Checking: bedGraphToBigWig version: $1", 0, "\n");#->2953
		} else {
			die "bedGraphToBigWig not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bigWigAverageOverBed_bin 2>&1`;
		if ($stdOut =~ m/bigWigAverageOverBed v(\S+)/) {
			&reportAndLogStatus("Checking: bigWigAverageOverBed version: $1", 0, "\n");#->2953
		} else {
			die "bigWigAverageOverBed is not installed properly. Quitting.\n";
		}
	}

	return ($bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin);
}
sub checkRScriptVersion {
#....................................................................................................................................................#
#	subroutineCategory: general, checkTools
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|193
#	secondaryAppearInSection: >none
#	input: $Rscript_bin
#	output: $optimize_tangent_R
#	toCall: my ($optimize_tangent_R) = &checkRScriptVersion($Rscript_bin);
#	calledInLine: 212
#....................................................................................................................................................#
	
	my ($Rscript_bin) = @_;
	
	my $dirPath = dirname(rel2abs($0));
	my $optimize_tangent_R = "$dirPath/../resources/R/optimize_tangent.R";

	#my $stdOut = `$Rscript_bin --version 2>&1`;
	#if ($stdOut =~ m/R scripting front-end version (\S+)/) {
	#	&reportAndLogStatus("Checking: Rscript version: $1", 0, "\n");#->2953
	#} else {
	#	die "Rscript is not installed properly at $Rscript_bin. Quitting.\n";
	#}
	
	if (-s $optimize_tangent_R) {
		&reportAndLogStatus("optimize_tangent_R found.", 0, "\n");#->2953
	} else {
		die "Rscript optimize_tangent_R is not found. Quitting.\n";
	}

	return($optimize_tangent_R);
}
sub checkTranscriptInfoBedChromSizeGeneInfoPath {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|193
#	secondaryAppearInSection: >none
#	input: $genome
#	output: $chrom_size_path, $gene_info_path, $transcript_bed_path, $transcript_info_path
#	toCall: my ($chrom_size_path, $gene_info_path, $transcript_info_path, $transcript_bed_path) = &checkTranscriptInfoBedChromSizeGeneInfoPath($genome);
#	calledInLine: 211
#....................................................................................................................................................#
	my ($genome) = @_;

	#$chrom_size_path, $gene_info_path, $transcript_bed_path, $transcript_info_path,

	my $dirPath = dirname(rel2abs($0));
	my $chrom_size_path = "$dirPath/../resources/genome/$genome/tsv/chrom.sizes.tsv";
	my $gene_info_path = "$dirPath/../resources/genome/$genome/tsv/gene.info.tsv";
	my $transcript_info_path = "$dirPath/../resources/genome/$genome/tsv/transcript.info.tsv";
	my $transcript_bed_path = "$dirPath/../resources/genome/$genome/bed/transcript.bed.gz";

	die "genome $genome does not have chrom_size_path. Please rerun prep_genome step\n" if not -s $chrom_size_path;
	die "genome $genome does not have gene_info_path. Please rerun prep_genome step\n" if not -s $gene_info_path;
	die "genome $genome does not have transcript_info_path. Please rerun prep_genome step\n" if not -s $transcript_info_path;
	die "genome $genome does not have transcript_bed_path. Please rerun prep_genome step\n" if not -s $transcript_bed_path;

	return ($chrom_size_path, $gene_info_path, $transcript_info_path, $transcript_bed_path);
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|1760, reportAndLogStatus|2953
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|193, 4_finishingTasks|258
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 154, 1776, 1780, 1785, 1789, 2969, 2970
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub defineCRE {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953, storeCREInfoFromBed|2975
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $CRE_extend_size, $CRE_extend_upstrm_ratio, $bedtools_bin, $chrom_size_path, $clusterInfoHsh_ref, $extended_tssCluster_bed_path, $proximal_strandness, $tmp_bed_dir
#	output: $CREInfoHsh_ref
#	toCall: my ($CREInfoHsh_ref) = &defineCRE($CRE_extend_size, $CRE_extend_upstrm_ratio, $clusterInfoHsh_ref, $tmp_bed_dir, $chrom_size_path, $bedtools_bin, $proximal_strandness, $extended_tssCluster_bed_path);
#	calledInLine: 237
#....................................................................................................................................................#
	my ($CRE_extend_size, $CRE_extend_upstrm_ratio, $clusterInfoHsh_ref, $tmp_bed_dir, $chrom_size_path, $bedtools_bin, $proximal_strandness, $extended_tssCluster_bed_path) = @_;
	
	my $CREInfoHsh_ref = {};

	{	
		&reportAndLogStatus("defining proximal CRE", 10, "\n");#->2953
		my $proximity = 'proximal';
		my $strand_opt = '-s';
		$strand_opt = '' if $proximal_strandness eq 'strandless';
	
		my $tmp_merged_CRE_bed = "$tmp_bed_dir/cluster_merged_CRE.$proximity.bed";
		my $tmp_indiv_CRE_bed = "$tmp_bed_dir/cluster_indiv_CRE.$proximity.bed";
		my $tmp_indiv_CRE_plus_bed = "$tmp_bed_dir/cluster_indiv_CRE.$proximity.plus_edge_distal.bed";
	
		open INDIVCRE, "| sort -k1,1 -k2,2n >$tmp_indiv_CRE_bed";
		foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
			if ($clusterInfoHsh_ref->{$clusterID}{'proximity'} eq $proximity) {
				my $extendedStart = $clusterInfoHsh_ref->{$clusterID}{'extendedStart'};
				my $extendedEnd = $clusterInfoHsh_ref->{$clusterID}{'extendedEnd'};
				my $chrom = $clusterInfoHsh_ref->{$clusterID}{'chrom'};
				my $score = $clusterInfoHsh_ref->{$clusterID}{'score'};
				my $strand = $clusterInfoHsh_ref->{$clusterID}{'strand'};
				print INDIVCRE join "", (join "\t", ($chrom, $extendedStart, $extendedEnd, $clusterID, $score, $strand)), "\n";
			}
		}
		close INDIVCRE;
		
		#---[2021/01/13 1:13] get the distal clusters at the edge of the proximal clusters
		system  "$bedtools_bin intersect $strand_opt -wa -a $extended_tssCluster_bed_path -b $tmp_indiv_CRE_bed >$tmp_indiv_CRE_plus_bed";

		system  "$bedtools_bin merge $strand_opt -c 4,5,6 -o distinct,sum,distinct -delim \";\" -i $tmp_indiv_CRE_plus_bed >$tmp_merged_CRE_bed";
		&storeCREInfoFromBed($tmp_merged_CRE_bed, $proximity, $CREInfoHsh_ref, $clusterInfoHsh_ref);#->2975
	}

	{
		&reportAndLogStatus("defining distal CRE", 10, "\n");#->2953
		my $proximity = 'distal';
		my $strand_opt = '';
	
		my $tmp_merged_CRE_bed = "$tmp_bed_dir/cluster_merged_CRE.$proximity.bed";
		my $tmp_indiv_CRE_bed = "$tmp_bed_dir/cluster_indiv_CRE.$proximity.bed";
	
		open INDIVCRE, "| sort -k1,1 -k2,2n >$tmp_indiv_CRE_bed";
		foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
			#---[2021/01/13 1:21] get the unassigned CREID
			if (not exists $clusterInfoHsh_ref->{$clusterID}{'CREID'}) {
				my $extendedStart = $clusterInfoHsh_ref->{$clusterID}{'extendedStart'};
				my $extendedEnd = $clusterInfoHsh_ref->{$clusterID}{'extendedEnd'};
				my $chrom = $clusterInfoHsh_ref->{$clusterID}{'chrom'};
				my $score = $clusterInfoHsh_ref->{$clusterID}{'score'};
				my $strand = $clusterInfoHsh_ref->{$clusterID}{'strand'};
				print INDIVCRE join "", (join "\t", ($chrom, $extendedStart, $extendedEnd, $clusterID, $score, $strand)), "\n";
			}
		}
		close INDIVCRE;
		
		system  "$bedtools_bin merge $strand_opt -c 4,5,6 -o distinct,sum,distinct -delim \";\" -i $tmp_indiv_CRE_bed >$tmp_merged_CRE_bed";
		&storeCREInfoFromBed($tmp_merged_CRE_bed, $proximity, $CREInfoHsh_ref, $clusterInfoHsh_ref);#->2975
	}

	return ($CREInfoHsh_ref);
}
sub defineCodingClasses {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: none
#	output: $coding_class_hsh_ref
#	toCall: my ($coding_class_hsh_ref) = &defineCodingClasses();
#	calledInLine: 224
#....................................................................................................................................................#
	
	my $coding_class_hsh_ref = {
		"antisense" => "noncoding",
		"IG_C_gene" => "coding",
		"IG_C_pseudogene" => "pseudogene",
		"IG_D_gene" => "coding",
		"IG_J_gene" => "coding",
		"IG_J_pseudogene" => "pseudogene",
		"IG_pseudogene" => "pseudogene",
		"IG_V_gene" => "coding",
		"IG_V_pseudogene" => "pseudogene",
		"lincRNA" => "noncoding",
		"lncRNA" => "noncoding",
		"miRNA" => "others",
		"misc_RNA" => "others",
		"Mt_rRNA" => "others",
		"Mt_tRNA" => "others",
		"polymorphic_pseudogene" => "pseudogene",
		"processed_pseudogene" => "pseudogene",
		"processed_transcript" => "others",
		"protein_coding" => "coding",
		"pseudogene" => "pseudogene",
		"rRNA" => "others",
		"rRNA_pseudogene" => "others",
		"scRNA" => "others",
		"sense_intronic" => "noncoding",
		"sense_overlapping" => "noncoding",
		"snoRNA" => "others",
		"snRNA" => "others",
		"TEC" => "noncoding",
		"transcribed_processed_pseudogene" => "pseudogene",
		"transcribed_unitary_pseudogene" => "pseudogene",
		"transcribed_unprocessed_pseudogene" => "pseudogene",
		"translated_processed_pseudogene" => "pseudogene",
		"translated_unprocessed_pseudogene" => "pseudogene",
		"TR_C_gene" => "coding",
		"TR_D_gene" => "coding",
		"TR_J_gene" => "coding",
		"TR_J_pseudogene" => "pseudogene",
		"TR_V_gene" => "coding",
		"TR_V_pseudogene" => "pseudogene",
		"unitary_pseudogene" => "pseudogene",
		"unprocessed_pseudogene" => "pseudogene",
		"vaultRNA" => "others",
		
		"coding_mRNA" => "coding",
		"lncRNA_antisense" => "noncoding",
		"lncRNA_divergent" => "noncoding",
		"lncRNA_intergenic" => "noncoding",
		"lncRNA_sense_intronic" => "noncoding",
		"pseudogene" => "pseudogene",
		"sense_overlap_RNA" => "noncoding",
		"short_ncRNA" => "noncoding",
		"small_RNA" => "others",
		"structural_RNA" => "others",
		"uncertain_coding" => "others",

		#"unanno_tss" => "others",
	};

	return ($coding_class_hsh_ref);
}
sub defineHyperactiveDistalLoci {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref, $Rscript_bin, $bedtools_bin, $max_dist_rank, $min_spreadness, $optimize_tangent_R, $result_plot_dir, $stitch_distance, $tmp_bed_dir
#	output: $distal_CRE_locus_info_hsh_ref
#	toCall: my ($distal_CRE_locus_info_hsh_ref) = &defineHyperactiveDistalLoci($CREInfoHsh_ref, $tmp_bed_dir, $bedtools_bin, $optimize_tangent_R, $max_dist_rank, $Rscript_bin, $stitch_distance, $min_spreadness, $result_plot_dir);
#	calledInLine: 242
#....................................................................................................................................................#
	my ($CREInfoHsh_ref, $tmp_bed_dir, $bedtools_bin, $optimize_tangent_R, $max_dist_rank, $Rscript_bin, $stitch_distance, $min_spreadness, $result_plot_dir) = @_;
	
	#time perl /osc-fs_home/hon-chun/analysis/tenX_single_cell/scafe/dev/scripts/1.2/scafe.tool.cm.annotate.pl --overwrite=yes --tssCluster_bed_path=/osc-fs_home/hon-chun/analysis/tenX_single_cell/paper_run/cellranger_unified_proc/pooled_celltype/scafe_run/PBMC/filter/PBMC/bed/PBMC.tssCluster.default.filtered.bed.gz --tssCluster_info_path=/osc-fs_home/hon-chun/analysis/tenX_single_cell/paper_run/cellranger_unified_proc/pooled_celltype/scafe_run/PBMC/filter/PBMC/log/PBMC.tssCluster.log.tsv --genome=hg19.gencode_v32lift37 --outputPrefix=demo --outDir=/osc-fs_home/hon-chun/analysis/tenX_single_cell/scafe/dev/test_run/annotate_super_enhancer/

	&reportAndLogStatus("defining hyperactive distal loci", 10, "\n");#->2953
	my $distal_CRE_bed = "$tmp_bed_dir/distal_CRE.bed";
	open OUTBED, "| sort -k1,1 -k2,2n >$distal_CRE_bed";
	foreach my $CREID (keys %{$CREInfoHsh_ref}) {
		my $proximity = $CREInfoHsh_ref->{$CREID}{'proximity'};
		my $gene_promoter = $CREInfoHsh_ref->{$CREID}{'gene_promoter'};
		if ($proximity eq 'distal' and $gene_promoter eq 'none') {
			my $sumClusterRead = $CREInfoHsh_ref->{$CREID}{'sumClusterRead'};
			my ($chrom, $chromStart, $chromEnd) = @{$CREInfoHsh_ref->{$CREID}{'bedLine'}};
			print OUTBED join "", (join "\t", ($chrom, $chromStart, $chromEnd, $CREID, $sumClusterRead)), "\n";
		}
	}
	close OUTBED;

	if ($stitch_distance eq 'undefined') {
		my $distal_CRE_dist_rank = "$tmp_bed_dir/distal_CRE_dist_rank.txt";
		open DIST, ">", $distal_CRE_dist_rank;
		open BEDTOOLSCLOSEST, "$bedtools_bin closest -io -d -a $distal_CRE_bed -b $distal_CRE_bed |";
		while (<BEDTOOLSCLOSEST>) {
			chomp;
			my @bedtools_ary = split /\t/;
			my $dist = $bedtools_ary[-1];
			print DIST "$dist\n" if $dist < $max_dist_rank;
		}
		close DIST;
		close BEDTOOLSCLOSEST;
		&reportAndLogStatus("getting optimized stitch distance", 10, "\n");#->2953
		my $stitch_dist_plot_path = "$result_plot_dir/optimize.stitch_distance.pdf";
		$globalReadmeHsh_ref->{$stitch_dist_plot_path}{'description'} = "Plot of the closest distance of a distal CRE to another, ranked in ascending order, a tangent line is used to define the cutoff for stitching within a distal CRE locus";
		chomp ($stitch_distance = `$Rscript_bin $optimize_tangent_R $distal_CRE_dist_rank $stitch_dist_plot_path optimize_stitch_distance CRE_rank_by_distance distance`);
		&reportAndLogStatus("optimized stitch_distance = $stitch_distance", 10, "\n");#->2953
	} else {
		&reportAndLogStatus("stitch_distance is user-defined at $stitch_distance", 10, "\n");#->2953
	}
	
	&reportAndLogStatus("stitching distal CREs", 10, "\n");#->2953
	my $tmp_distal_CRE_locus_hsh_ref = {};
	open BEDTOOLSCLOSEST, "$bedtools_bin cluster -d $stitch_distance -i $distal_CRE_bed |";
	while (<BEDTOOLSCLOSEST>) {
		chomp;
		my ($chrom, $start, $end, $CREID, $count, $distal_CRE_locus_num) = split /\t/;
		push @{$tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'count'}}, $count;
		push @{$tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'CREID'}}, $CREID;
		push @{$tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'start'}}, $start;
		push @{$tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'end'}}, $end;
		$tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'chrom'} = $chrom;
	}
	close BEDTOOLSCLOSEST;
	
	my @count_ary = ();
	my $distal_CRE_locus_info_hsh_ref = {};
	foreach my $distal_CRE_locus_num (keys %{$tmp_distal_CRE_locus_hsh_ref}) {
		my $start = min(@{$tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'start'}});
		my $end = max(@{$tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'end'}});
		my $size = $end - $start;
		my $chrom = $tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'chrom'};
		my $total_count = sum(@{$tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'count'}});
		my $top_count = max(@{$tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'count'}});
		my $top_frac = $top_count/$total_count;
		my $num_CRE = @{$tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'CREID'}};
		my $spreadness = $num_CRE/$top_frac;
		my $distal_CRE_locus_ID = join "_", ($chrom, $start, $end);
		@{$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'CREID'}} = @{$tmp_distal_CRE_locus_hsh_ref->{$distal_CRE_locus_num}{'CREID'}};
		$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'loc'} = [$chrom, $start, $end];
		$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'total_count'} = $total_count;
		$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'top_count'} = $top_count;
		$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'top_frac'} = $top_frac;
		$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'spreadness'} = $spreadness;
		$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'size'} = $size;
		push @count_ary, $total_count;
	}
	my $num_loci = @count_ary;
	@count_ary = sort {$a <=> $b} @count_ary;
	my $max_index = $#count_ary - int($num_loci*0.001);
	my $distal_CRE_locus_count_rank = "$tmp_bed_dir/distal_CRE_locus_count_rank.txt";
	open COUNT, ">", $distal_CRE_locus_count_rank;
	foreach my $i (0..$max_index) {
		print COUNT join "", (join "\t", ($count_ary[$i])), "\n";
	}
	close COUNT;
	
	&reportAndLogStatus("getting hyperactive locus cutoff", 10, "\n");#->2953
	my $hyperactive_count_plot_path = "$result_plot_dir/optimize.hyperactive_count.pdf";
	$globalReadmeHsh_ref->{$hyperactive_count_plot_path}{'description'} = "Plot of UMI/read counts for all distal CRE loci ranked in ascending order, a tangent line is used to define the cutoff a hyperactive";

	chomp (my $hyperactive_cutoff = `$Rscript_bin $optimize_tangent_R $distal_CRE_locus_count_rank $hyperactive_count_plot_path optimize_hyperactive_count locus_rank_by_count count`);
	&reportAndLogStatus("hyperactive_cutoff=$hyperactive_cutoff", 10, "\n");#->2953
	
	foreach my $CREID (keys %{$CREInfoHsh_ref}) {
		$CREInfoHsh_ref->{$CREID}{'distal_CRE_locus_ID'} = '__na';
		$CREInfoHsh_ref->{$CREID}{'distal_CRE_locus_count'} = '__na';
		$CREInfoHsh_ref->{$CREID}{'distal_CRE_locus_hyperactive'} = '__na';
	}
	
	my $num_hyperactive = 0;
	foreach my $distal_CRE_locus_ID (keys %{$distal_CRE_locus_info_hsh_ref}) {
		my $total_count = $distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'total_count'};
		my $spreadness = $distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'spreadness'};
		my $hyperactive = 'no';
		my $rgbItem = '55,126,184';
		if ($total_count >= $hyperactive_cutoff and $spreadness >= $min_spreadness) {
			$hyperactive = 'yes';
			$num_hyperactive++;
			$rgbItem = '228,26,28';
		}
		$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'hyperactive'} = $hyperactive;
		foreach my $CREID (@{$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'CREID'}}) {
			$CREInfoHsh_ref->{$CREID}{'distal_CRE_locus_ID'} = $distal_CRE_locus_ID;
			$CREInfoHsh_ref->{$CREID}{'distal_CRE_locus_count'} = $total_count;
			$CREInfoHsh_ref->{$CREID}{'distal_CRE_locus_hyperactive'} = $hyperactive;
		}

		my ($chrom, $start, $end) = @{$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'loc'}};
		my $score = $distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'total_count'};
		my $strand = '.';
		my $thickStart = $start;
		my $thickEnd = $end;
		my $blockCount = 1;
		my $blockSizes = $distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'size'};
		my $blockStarts = 0;
		$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'rgbItem'} = $rgbItem;
		$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'bedLine'} = [$chrom, $start, $end, $distal_CRE_locus_ID, $score, $strand, $thickStart, $thickEnd, $rgbItem, $blockCount, $blockSizes, $blockStarts];
	}

	&reportAndLogStatus("num_hyperactive = $num_hyperactive", 10, "\n");#->2953
	
	return ($distal_CRE_locus_info_hsh_ref);
}
sub defineUnannoPromoter {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref, $clusterInfoHsh_ref, $geneInfoHsh_ref, $min_gene_strand_read_frac, $min_total_exp_frac
#	output: $gene_promoter_CRE_pair_hsh_ref
#	toCall: my ($gene_promoter_CRE_pair_hsh_ref) = &defineUnannoPromoter($CREInfoHsh_ref, $geneInfoHsh_ref, $min_total_exp_frac, $min_gene_strand_read_frac, $clusterInfoHsh_ref);
#	calledInLine: 241
#....................................................................................................................................................#
	my ($CREInfoHsh_ref, $geneInfoHsh_ref, $min_total_exp_frac, $min_gene_strand_read_frac, $clusterInfoHsh_ref) = @_;

	&reportAndLogStatus("defining unannotated promoters", 10, "\n");#->2953

	my $gene_promoter_CRE_pair_hsh_ref = {};
	my $tmp_unanno_tCRE_hsh_ref = {};
	my $num_unanno_alt_promt = 0;
	
	foreach my $CREID (sort keys %{$CREInfoHsh_ref}) {
		my $sumClusterRead = $CREInfoHsh_ref->{$CREID}{'sumClusterRead'};
		my $regionGeneID = $CREInfoHsh_ref->{$CREID}{'regionGeneID'};
		my $regionType = $CREInfoHsh_ref->{$CREID}{'regionType'};
		my $regionOritentation = $CREInfoHsh_ref->{$CREID}{'regionOritentation'};
		my $proximity = $CREInfoHsh_ref->{$CREID}{'proximity'};
		if (exists $geneInfoHsh_ref->{$regionGeneID}) {
			my $geneClass = $geneInfoHsh_ref->{$regionGeneID}{'geneClass'};
			if ($geneClass ne 'unanno_tss' and $proximity eq 'distal' and $regionOritentation eq 'ss' and ($regionType eq 'exon' or $regionType eq 'intron')) {
				$tmp_unanno_tCRE_hsh_ref->{$regionGeneID}{$CREID}++;
			}
		}
		$CREInfoHsh_ref->{$CREID}{'gene_promoter'} = 'none';
	}

	foreach my $geneID (sort keys %{$geneInfoHsh_ref}) {
		my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
		my $strand = $geneInfoHsh_ref->{$geneID}{'strand'};
		next if ($geneClass eq 'unanno_tss');
		my $total_read_within_gene = 0;
		my $promoter_CRE_hsh_ref = {};
		foreach my $CREID (keys %{$geneInfoHsh_ref->{$geneID}{'CREID'}}) {
			my $gene_tss = 'no';
			foreach my $clusterID (sort keys %{$CREInfoHsh_ref->{$CREID}{'clusterID'}}) {
				my $type = $clusterInfoHsh_ref->{$clusterID}{'type'};
				$gene_tss = 'yes' if $type eq 'gene_tss';
			}
			if ($gene_tss eq 'yes') {
				my $sumClusterRead = $CREInfoHsh_ref->{$CREID}{'sumClusterRead'};
				$promoter_CRE_hsh_ref->{$CREID}++;
				$total_read_within_gene += $sumClusterRead;
			}
		}
		
		foreach my $CREID (keys %{$promoter_CRE_hsh_ref}) {
			my $sumClusterRead = $CREInfoHsh_ref->{$CREID}{'sumClusterRead'};
			my $plusClusterRead = $CREInfoHsh_ref->{$CREID}{'plusClusterRead'};
			my $minusClusterRead = $CREInfoHsh_ref->{$CREID}{'minusClusterRead'};
			my $gene_strand_read_frac = $plusClusterRead/$sumClusterRead;
			$gene_strand_read_frac = $minusClusterRead/$sumClusterRead if $strand eq '-';
			my $total_exp_frac = 1;
			$total_exp_frac = $sumClusterRead/$total_read_within_gene if $total_read_within_gene > 0;
			
			my $status = 'annotated';
			$gene_promoter_CRE_pair_hsh_ref->{$geneID}{$CREID} = [$status, $total_exp_frac, $gene_strand_read_frac, $sumClusterRead];
			$CREInfoHsh_ref->{$CREID}{'gene_promoter'} = $status;
			$CREInfoHsh_ref->{$CREID}{'gene_promoter_geneID'}{$geneID}++;
		}

		if (exists $tmp_unanno_tCRE_hsh_ref->{$geneID}) {
			foreach my $CREID (keys %{$tmp_unanno_tCRE_hsh_ref->{$geneID}}) {
				my $sumClusterRead = $CREInfoHsh_ref->{$CREID}{'sumClusterRead'};
				my $plusClusterRead = $CREInfoHsh_ref->{$CREID}{'plusClusterRead'};
				my $minusClusterRead = $CREInfoHsh_ref->{$CREID}{'minusClusterRead'};
				my $gene_strand_read_frac = $plusClusterRead/$sumClusterRead;
				$gene_strand_read_frac = $minusClusterRead/$sumClusterRead if $strand eq '-';
				my $total_exp_frac = 1;
				$total_exp_frac = $sumClusterRead/$total_read_within_gene if $total_read_within_gene > 0;
				if ($total_exp_frac >= $min_total_exp_frac and $gene_strand_read_frac >= $min_gene_strand_read_frac) {
					my $status = 'unannotated';
					$gene_promoter_CRE_pair_hsh_ref->{$geneID}{$CREID} = [$status, $total_exp_frac, $gene_strand_read_frac, $sumClusterRead];
					$CREInfoHsh_ref->{$CREID}{'gene_promoter'} = $status;
					$CREInfoHsh_ref->{$CREID}{'gene_promoter_geneID'}{$geneID}++;
					$num_unanno_alt_promt++;
				}
			}
		}
	}

	&reportAndLogStatus("$num_unanno_alt_promt CRE is defined as unannotated alternative promoter", 10, "\n");#->2953
	
	return ($gene_promoter_CRE_pair_hsh_ref);
}
sub exonRngToGtf {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: printTrnscptGtf|2278
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_readInfo|217
#	input: $chrom, $exonRngAry_ref, $geneID, $sourceTag, $strand, $trnscptID
#	output: $gtf_ary_ref
#	toCall: my ($gtf_ary_ref) = &exonRngToGtf($exonRngAry_ref, $chrom, $strand, $trnscptID, $geneID, $sourceTag);
#	calledInLine: 2323
#....................................................................................................................................................#
	my ($exonRngAry_ref, $chrom, $strand, $trnscptID, $geneID, $sourceTag) = @_;
	
	my $gtf_ary_ref = [];
	
	my @rngAry = sort {$a <=> $b} @{$exonRngAry_ref};
	for (my $i=0; $i < $#rngAry; $i += 2) {
		my ($exonStart, $exonEnd) = ($rngAry[$i], $rngAry[$i+1]);
		push @{$gtf_ary_ref}, [$chrom, $sourceTag, 'exon', $exonStart, $exonEnd, '.', $strand, '.', "gene_id \"$geneID\"; transcript_id \"$trnscptID\";"];
	}
	
	return ($gtf_ary_ref);
}
sub filterUnannotatedCluster {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref
#	output: 
#	toCall: &filterUnannotatedCluster($clusterInfoHsh_ref);
#	calledInLine: 230
#....................................................................................................................................................#
	my ($clusterInfoHsh_ref) = @_;
	
	&reportAndLogStatus("removing unanno cluster within filter region", 10, "\n");#->2953
	my $num_rm = 0;
	my $num_unanno = 0;
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		if (not exists $clusterInfoHsh_ref->{$clusterID}{'trnscptID'}) {
			$num_unanno++;
			if ($clusterInfoHsh_ref->{$clusterID}{'filter'} eq 'yes') {
				delete $clusterInfoHsh_ref->{$clusterID};
				$num_rm++;
			}
		}
	}

	&reportAndLogStatus("$num_rm of $num_unanno unannotated clusters filtered out.", 10, "\n");#->2953
	
	return ();
}
sub generateAddonGene {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: addonTranscript|348
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_readInfo|217
#	input: $clusterInfoHsh_ref, $superClusterHsh_ref, $superclusterID
#	output: $addon_chrom, $geneID
#	toCall: my ($geneID, $addon_chrom) = &generateAddonGene($superClusterHsh_ref, $clusterInfoHsh_ref, $superclusterID);
#	calledInLine: 367
#....................................................................................................................................................#
	
	my ($superClusterHsh_ref, $clusterInfoHsh_ref, $superclusterID) = @_;
	
	my $chrom;
	my $g_start = 0;
	my $strand_hsh_ref = {};
	
	foreach my $clusterID (@{$superClusterHsh_ref->{$superclusterID}}) {
		$chrom = $clusterInfoHsh_ref->{$clusterID}{'chrom'};
		$g_start = $clusterInfoHsh_ref->{$clusterID}{'start'} if $g_start < $clusterInfoHsh_ref->{$clusterID}{'start'};
		my $strand = $clusterInfoHsh_ref->{$clusterID}{'strand'};
		$strand_hsh_ref->{$strand}++;
	}
	my $addon_g_strand;
	
	if ((exists $strand_hsh_ref->{'+'} and exists $strand_hsh_ref->{'-'}) or (exists $strand_hsh_ref->{'.'})) {
		$addon_g_strand = 'B';

	} elsif (exists $strand_hsh_ref->{'-'} and not exists $strand_hsh_ref->{'+'}) {
		$addon_g_strand = 'R';
		
	} elsif (exists $strand_hsh_ref->{'+'} and not exists $strand_hsh_ref->{'-'}) {
		$addon_g_strand = 'F';

	} else {
		die "strand conflicts\n";
	}
	
	my $addon_chrom = $chrom;
	$addon_chrom =~ s/^chr//;
	$addon_chrom = '0'.$addon_chrom if length($addon_chrom) == 1;
	my $addon_g_start = sprintf "%.9d", $g_start;
	my $geneID = "ADDG".$addon_chrom.$addon_g_start.'.'.$addon_g_strand;
	
	return ($geneID, $addon_chrom);
}
sub generateExtendedCluster {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $CRE_extend_size, $CRE_extend_upstrm_ratio, $clusterInfoHsh_ref, $tmp_bed_dir
#	output: $extended_tssCluster_bed_path
#	toCall: my ($extended_tssCluster_bed_path) = &generateExtendedCluster($clusterInfoHsh_ref, $tmp_bed_dir, $CRE_extend_size, $CRE_extend_upstrm_ratio);
#	calledInLine: 228
#....................................................................................................................................................#
	my ($clusterInfoHsh_ref, $tmp_bed_dir, $CRE_extend_size, $CRE_extend_upstrm_ratio) = @_;
	
	my $extended_tssCluster_bed_path = "$tmp_bed_dir/extended_cluster.bed";
	&reportAndLogStatus("generating extended cluster", 10, "\n");#->2953
	open (EXTENDBED, "| sort -k1,1 -k2,2n >$extended_tssCluster_bed_path");
	
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
	
		my ($chrom, $cluster_chromStart, $cluster_chromEnd, undef, $score, $strand, $thickStart, $thickEnd, $rgbItem, $blockCount, $blockSizes, $blockStarts) = @{$clusterInfoHsh_ref->{$clusterID}{'bedLine'}};
		my $extendedStart;
		my $extendedEnd;
		
		if ($CRE_extend_size > 0 and $CRE_extend_upstrm_ratio > 0) {
			my $left_ratio;
			my $right_ratio;

			if ($strand eq '+') {
				$left_ratio = $CRE_extend_upstrm_ratio;
				$right_ratio = 1;

			} elsif ($strand eq '-') {
				$left_ratio = 1;
				$right_ratio = $CRE_extend_upstrm_ratio;

			} else {
				$left_ratio = 1;
				$right_ratio = 1;
			}
		
			my $left_size = int($CRE_extend_size*($left_ratio/($left_ratio+$right_ratio)));
			my $right_size = int($CRE_extend_size*($right_ratio/($left_ratio+$right_ratio)));
		
			my $peakPos = $thickEnd;
			$extendedStart = $peakPos - $left_size - 1;
			$extendedEnd = $peakPos + $right_size;
		
			$extendedStart = 0 if $extendedStart < 0;

		} else {

			$extendedStart = $cluster_chromStart;
			$extendedEnd = $cluster_chromEnd;
		}
		
		$clusterInfoHsh_ref->{$clusterID}{'extendedStart'} = $extendedStart;
		$clusterInfoHsh_ref->{$clusterID}{'extendedEnd'} = $extendedEnd;
		
		print EXTENDBED join "", (join "\t", ($chrom, $extendedStart, $extendedEnd, $clusterID, $score, $strand, $thickStart, $thickEnd, $rgbItem, $blockCount, $blockSizes, $blockStarts)), "\n";
		
	}
	close EXTENDBED;
	
	return ($extended_tssCluster_bed_path);
}
sub generateGenePromoterInfoHsh {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref
#	output: $gene_promoter_info_hsh_ref
#	toCall: my ($gene_promoter_info_hsh_ref) = &generateGenePromoterInfoHsh($CREInfoHsh_ref);
#	calledInLine: 243
#....................................................................................................................................................#
	my ($CREInfoHsh_ref) = @_;
	
	my $gene_promoter_info_hsh_ref = {};

	foreach my $CREID (keys %{$CREInfoHsh_ref}) {
		my $gene_promoter = $CREInfoHsh_ref->{$CREID}{'gene_promoter'};
		next if $gene_promoter eq 'none';
		my $rgbItem = '77,175,74'; #---[2022/06/09 17:33] green
		$rgbItem = '153,153,153' if $gene_promoter eq 'unannotated'; #---[2022/06/09 17:33] grey
		$gene_promoter_info_hsh_ref->{$CREID}{'bedLine'} = $CREInfoHsh_ref->{$CREID}{'bedLine'};
		$gene_promoter_info_hsh_ref->{$CREID}{'rgbItem'} = $rgbItem;
	}

	return ($gene_promoter_info_hsh_ref);
}
sub getSuperCluster {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $clusterInfoHsh_ref, $merge_dist, $merge_strandness, $tmp_bed_dir
#	output: $superClusterHsh_ref
#	toCall: my ($superClusterHsh_ref) = &getSuperCluster($tmp_bed_dir, $clusterInfoHsh_ref, $merge_dist, $merge_strandness, $bedtools_bin);
#	calledInLine: 231
#....................................................................................................................................................#
	
	my ($tmp_bed_dir, $clusterInfoHsh_ref, $merge_dist, $merge_strandness, $bedtools_bin) = @_;
	
	my $superClusterHsh_ref = {};
	
	my $unanno_tssCluster_bed_path = "$tmp_bed_dir/unanno_cluster.bed";
	&reportAndLogStatus("getting unanno supercluster", 10, "\n");#->2953
	open (UNANNOBED, "| sort -k1,1 -k2,2n >$unanno_tssCluster_bed_path");
	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		if (not exists $clusterInfoHsh_ref->{$clusterID}{'trnscptID'}) {
			my $strand = $clusterInfoHsh_ref->{$clusterID}{'strand'};
			my $chrom = $clusterInfoHsh_ref->{$clusterID}{'chrom'};
			my $start = $clusterInfoHsh_ref->{$clusterID}{'start'};
			my $end = $clusterInfoHsh_ref->{$clusterID}{'end'};
			print UNANNOBED join "", (join "\t", ($chrom, $start, $end, $clusterID, '1', $strand)), "\n";
		}
	}
	close UNANNOBED;
	
	if ($merge_strandness eq 'stranded') {
		open (SUPERCLUSTER, "$bedtools_bin cluster -s -d $merge_dist -i $unanno_tssCluster_bed_path |");
	} elsif ($merge_strandness eq 'strandless') {
		open (SUPERCLUSTER, "$bedtools_bin cluster -d $merge_dist -i $unanno_tssCluster_bed_path |");
	} else {
		die "merge_strandness $merge_strandness is not valid\n";
	}

	while (<SUPERCLUSTER>) {
		chomp;
		my @splt = split /\t/;
		my $clusterID = $splt[3];
		my $superclusterID = $splt[-1];
		push @{$superClusterHsh_ref->{$superclusterID}}, $clusterID;
	}	
	close SUPERCLUSTER;
	
	my $num_superclusters = keys %{$superClusterHsh_ref};
	&reportAndLogStatus("$num_superclusters super clusters defined", 10, "\n");#->2953
	
	die "supercluster definition problem\n" if $num_superclusters == 0;
	
	return ($superClusterHsh_ref);
}
sub intersectCluster {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $chrom_size_path, $clusterInfoHsh_ref, $end5_rng_bed_path, $exon_slop_rng, $geneInfoHsh_ref, $transcript_in_scope_bed_path, $trnscptInfoHsh_ref, $tssCluster_bed_path
#	output: none
#	toCall: &intersectCluster($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_rng_bed_path, $chrom_size_path, $exon_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin);
#	calledInLine: 229
#....................................................................................................................................................#
	
	my ($transcript_in_scope_bed_path, $tssCluster_bed_path, $end5_rng_bed_path, $chrom_size_path, $exon_slop_rng, $clusterInfoHsh_ref, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $bedtools_bin) = @_;
	
	foreach my $end5_exon (qw/end5 exon/) {
		
		&reportAndLogStatus("Intersecting cluster and transcript $end5_exon", 10, "\n");#->2953
		
		if ($end5_exon eq 'end5') {
			open BEDTOOLS, "$bedtools_bin intersect -wo -a $end5_rng_bed_path -b $tssCluster_bed_path |" ;
		} elsif ($end5_exon eq 'exon') {
			
			#---[4/18/17 12:13] skip if exon_slop_rng == 1
			if ($exon_slop_rng == -1) {
				&reportAndLogStatus("exon_slop_rng==-1. Skipping exon intersect.", 10, "\n");#->2953
				next;
			}
			
			open BEDTOOLS, "$bedtools_bin bed12tobed6 -i $transcript_in_scope_bed_path | $bedtools_bin slop -b $exon_slop_rng -i stdin -g $chrom_size_path | $bedtools_bin intersect -s -wo -a stdin -b $tssCluster_bed_path |" ;
		}

		while (<BEDTOOLS>) {
			#chr10	13141663	13142302	ENST00000482140.5_1	1	+	chr10	13142075	13142193	p1@OPTN	247174	+	13142162	13142163	255,0,0	118
			my (@splt) = split /\t/;
			my $clusterID = $splt[9];
			my $cluster_strand = $splt[11];
			my $trnscptIDStr = $splt[3];
			my $trnscpt_strand = $splt[5];
			my @trnscptIDStrAry = split /\|/, $trnscptIDStr;
			my $trnscptID = $trnscptIDStrAry[-1];
			
			if ($cluster_strand eq '.' or $cluster_strand eq $trnscpt_strand) {
				#---[4/16/17 0:01] skip end5
				next if exists $trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID};

				die "$trnscptID does not exists in trnscptInfoHsh_ref\n" if not exists $trnscptInfoHsh_ref->{$trnscptID};
				die "$clusterID does not exists in clusterInfoHsh_ref\n" if not exists $clusterInfoHsh_ref->{$clusterID};
				my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
		
				$trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID} = $end5_exon;
				$clusterInfoHsh_ref->{$clusterID}{'trnscptID'}{$trnscptID} = $end5_exon;
				$clusterInfoHsh_ref->{$clusterID}{'geneID'}{$geneID} = $end5_exon;
				$geneInfoHsh_ref->{$geneID}{'clusterID'}{$clusterID} = $end5_exon;

				$clusterInfoHsh_ref->{$clusterID}{'type'} = 'gene_tss';
			}
		}
		close BEDTOOLS;
	}
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|193
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 208
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub printAllBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref, $clusterInfoHsh_ref, $distal_CRE_locus_info_hsh_ref, $geneInfoHsh_ref, $gene_promoter_info_hsh_ref, $outputPrefix, $result_bed_dir, $trnscptInfoHsh_ref
#	output: none
#	toCall: &printAllBed($result_bed_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $distal_CRE_locus_info_hsh_ref, $gene_promoter_info_hsh_ref, $outputPrefix);
#	calledInLine: 244
#....................................................................................................................................................#

	my ($result_bed_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $distal_CRE_locus_info_hsh_ref, $gene_promoter_info_hsh_ref, $outputPrefix) = @_;
	
	my %itemHsh = (
		'gene' => $geneInfoHsh_ref,
		'transcript' => $trnscptInfoHsh_ref,
		'cluster' => $clusterInfoHsh_ref,
		'CRE' => $CREInfoHsh_ref,
		'distal_CRE_locus' => $distal_CRE_locus_info_hsh_ref,
		'gene_promoter' => $gene_promoter_info_hsh_ref,
	);

	my $strand_color_hsh_ref = {
		'+' => '228,26,28',
		'-' => '55,126,184',
		'.' => '77,175,74',
	};
	
	foreach my $item_type (keys %itemHsh) {
		&reportAndLogStatus("printing $item_type bed", 10, "\n");#->2953
		my $hsh_ref = $itemHsh{$item_type};
		my $filePath;
		
		$filePath = "$result_bed_dir/$outputPrefix.$item_type.coord.bed.gz";
		$globalReadmeHsh_ref->{$filePath}{'description'} = "It contains ranges of all $item_type, with $item_type ID at 4th column";

		open OUTBED, "| sort -k1,1 -k2,2n | gzip -c >$filePath";
	
		foreach my $itemID (keys %{$hsh_ref}) {
			my $strand = $hsh_ref->{$itemID}{'bedLine'}[5];
			if (not exists $hsh_ref->{$itemID}{'rgbItem'}) {
				$hsh_ref->{$itemID}{'bedLine'}[8] = $strand_color_hsh_ref->{$strand};
			} else {
				$hsh_ref->{$itemID}{'bedLine'}[8] = $hsh_ref->{$itemID}{'rgbItem'};
			}
			print OUTBED join "", (join "\t", (@{$hsh_ref->{$itemID}{'bedLine'}})), "\n";
		}
		close OUTBED;
	};

	{
		my $filePath = "$result_bed_dir/$outputPrefix.cluster.annot.bed.gz";
		$globalReadmeHsh_ref->{$filePath}{'description'} = "It contains ranges of all cluster, with cluster name (i.e. gene annotation) at 4th column";
		open OUTBED, "| sort -k1,1 -k2,2n | gzip -c >$filePath";
	
		foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
			my $strand = $clusterInfoHsh_ref->{$clusterID}{'bedLine'}[5];
			my @bedAry = @{$clusterInfoHsh_ref->{$clusterID}{'bedLine'}};
			$bedAry[8] = $strand_color_hsh_ref->{$strand};
			$bedAry[3] = $clusterInfoHsh_ref->{$clusterID}{'clusterName'};
			print OUTBED join "", (join "\t", (@bedAry)), "\n";
		}
		close OUTBED;
	}

	{
		my $filePath = "$result_bed_dir/$outputPrefix.CRE.annot.bed.gz";
		$globalReadmeHsh_ref->{$filePath}{'description'} = "It contains ranges of all CRE, with CRE name (i.e. gene annotation) at 4th column";
		open OUTBED, "| sort -k1,1 -k2,2n | gzip -c >$filePath";
	
		foreach my $CREID (keys %{$CREInfoHsh_ref}) {
			my @bedAry = @{$CREInfoHsh_ref->{$CREID}{'bedLine'}};
			$bedAry[8] = $CREInfoHsh_ref->{$CREID}{'rgbItem'};
			$bedAry[3] = $CREInfoHsh_ref->{$CREID}{'CREName'};
			print OUTBED join "", (join "\t", (@bedAry)), "\n";
		}
		close OUTBED;
	}

}
sub printEnd5Bed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $dn_end5Rng, $tmp_bed_dir, $trnscptInfoHsh_ref, $up_end5Rng
#	output: $end5_point_bed_path, $end5_rng_bed_path
#	toCall: my ($end5_rng_bed_path, $end5_point_bed_path) = &printEnd5Bed($trnscptInfoHsh_ref, $up_end5Rng, $dn_end5Rng, $tmp_bed_dir);
#	calledInLine: 225
#....................................................................................................................................................#

	my ($trnscptInfoHsh_ref, $up_end5Rng, $dn_end5Rng, $tmp_bed_dir) = @_;

	&reportAndLogStatus("Printing transcript end5 bed", 10, "\n");#->2953

	my $end5_rng_bed_path = "$tmp_bed_dir/end5_rng.bed";
	my $end5_point_bed_path = "$tmp_bed_dir/end5_point.bed";
	open (END5RNGBED, "| sort -k1,1 -k2,2n >$end5_rng_bed_path");
	open (END5POINTBED, "| sort -k1,1 -k2,2n >$end5_point_bed_path");
	
	foreach my $trnscptID (sort keys %{$trnscptInfoHsh_ref}) {
		my $chrom = $trnscptInfoHsh_ref->{$trnscptID}{'chrom'};
		my $strand = $trnscptInfoHsh_ref->{$trnscptID}{'strand'};
		my @exonRngAry = sort {$a <=> $b} @{$trnscptInfoHsh_ref->{$trnscptID}{'exonRng'}};

		my ($end5Start, $end5End, $exon1stLength, $exon1stStart, $exon1stEnd);
		my $tssPoint;
		
		if ($strand eq '+') {
			($exon1stStart, $exon1stEnd) = ($exonRngAry[0], $exonRngAry[1]);
			$exon1stLength = $exon1stEnd - $exon1stStart + 1;
			$end5Start = $exon1stStart - $up_end5Rng;
			
			$tssPoint = $exon1stStart;
			
			if ($exon1stLength < $dn_end5Rng) {
				$end5End = $exon1stEnd;
			} else {
				$end5End = $exon1stStart + $dn_end5Rng;
			}
			
		} elsif ($strand eq '-') {

			($exon1stStart, $exon1stEnd) = ($exonRngAry[-2], $exonRngAry[-1]);
			$exon1stLength = $exon1stEnd - $exon1stStart + 1;
			$end5End = $exon1stEnd + $up_end5Rng;

			$tssPoint = $exon1stEnd+1;

			if ($exon1stLength < $dn_end5Rng) {
				$end5Start = $exon1stStart;
			} else {
				$end5Start = $exon1stEnd - $dn_end5Rng;
			}
			
		} else {
			die "strand $strand is invalid\n";
		}
		
		$end5Start = 2 if $end5Start <= 1;
		$exon1stEnd = 2 if $exon1stEnd <= 1;
		$end5End = 2 if $end5End <= 1;
		
		@{$trnscptInfoHsh_ref->{$trnscptID}{'exon1stRng'}} = ($exon1stStart, $exon1stEnd);
		@{$trnscptInfoHsh_ref->{$trnscptID}{'end5Rng'}} = ($end5Start, $end5End);
		my $end5RegionLength = $end5End - $end5Start + 1;
		$trnscptInfoHsh_ref->{$trnscptID}{'exon1stLength'} = $exon1stLength;
		$trnscptInfoHsh_ref->{$trnscptID}{'end5RegionLength'} = $end5RegionLength;
		
		my $tssEnd = $tssPoint;
		my $tssStart = $tssEnd-1;
		print END5POINTBED join "", (join "\t", ($chrom, $tssStart, $tssEnd, $trnscptID, '1', $strand)), "\n";
		print END5RNGBED join "", (join "\t", ($chrom, $end5Start, $end5End, $trnscptID, '1', $strand)), "\n";
	}
	close END5POINTBED;
	close END5RNGBED;

	return ($end5_rng_bed_path, $end5_point_bed_path);
}
sub printGenePromoterInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref, $geneInfoHsh_ref, $gene_promoter_CRE_pair_hsh_ref, $outputPrefix, $result_log_dir
#	output: none
#	toCall: &printGenePromoterInfo($result_log_dir, $gene_promoter_CRE_pair_hsh_ref, $geneInfoHsh_ref, $CREInfoHsh_ref, $outputPrefix);
#	calledInLine: 252
#....................................................................................................................................................#

	my ($result_log_dir, $gene_promoter_CRE_pair_hsh_ref, $geneInfoHsh_ref, $CREInfoHsh_ref, $outputPrefix) = @_;
	
	my $filePath = "$result_log_dir/$outputPrefix.gene_promoter.info.tsv.gz";
	open ALTPROMLOG, "| gzip -c >$filePath";
	my @headerAry = ('CREID', 'geneID', 'geneName', 'total_exp_frac', 'gene_strand_read_frac', 'sumClusterRead', 'status', 'loc');
	print ALTPROMLOG join "", (join "\t", @headerAry), "\n";
	&reportAndLogStatus("Printing gene promoter info", 0, "\n");#->2953

	$globalReadmeHsh_ref->{$filePath}{'description'} = "list of annotated and unannotated gene promoters as pairs of CREID and geneID";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'CREID'} = '[unique ID] Identifier of the CRE.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneID'} = '[unique ID] ID of the gene which the CRE is defined as its alternative promoter';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneName'} = '[string] gene symbol';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'total_exp_frac'} = '[fraction] the fraction of expression amount (UMI in single cell/read in bulk) of this CRE in the total expression amount of annotated alternative promoters';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'gene_strand_read_frac'} = '[fraction] the fraction of expression amount (UMI in single cell/read in bulk) of this CRE on the gene strand in the total expression amount of both strands';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'sumClusterRead'} = '[integer] sum of read within its member cluster';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'status'} = '[annotated or unannotated] annotated, CRE that is assigned to annotated transcripts (in reference annotation) of the gene, or unannotated otherwise';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'loc'} = '[string] locus, in format of chromosome:start-end';

	foreach my $geneID (sort keys %{$gene_promoter_CRE_pair_hsh_ref}) {
		foreach my $CREID (sort keys %{$gene_promoter_CRE_pair_hsh_ref->{$geneID}}) {
			my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
			my ($chrom, $start, $end) = @{$CREInfoHsh_ref->{$CREID}{'bedLine'}};
			my $loc = "$chrom:$start-$end";
			my ($status, $total_exp_frac, $gene_strand_read_frac, $sumClusterRead) = @{$gene_promoter_CRE_pair_hsh_ref->{$geneID}{$CREID}};
			print ALTPROMLOG join "", (join "\t", ($CREID, $geneID, $geneName, $total_exp_frac, $gene_strand_read_frac, $sumClusterRead, $status, $loc)), "\n";
		}
	}
	close ALTPROMLOG;
	
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_finishingTasks|258
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 261
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			@colLenCountHsh = sort {$b <=> $a} @colLenCountHsh;
			my $headerColLen = $colLenCountHsh[0]+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}
	
	@{$filelistLenCountHsh{'dir'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'dir'}};
	@{$filelistLenCountHsh{'name'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'name'}};
	@{$filelistLenCountHsh{'description'}} = sort {$b <=> $a} @{$filelistLenCountHsh{'description'}};

	my $fileDir_colLen = $filelistLenCountHsh{'dir'}[0]+2;
	my $fileName_colLen = $filelistLenCountHsh{'name'}[0]+2;
	my $fileDescription_colLen = $filelistLenCountHsh{'description'}[0]+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|695
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|193, 4_finishingTasks|258
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 209, 262
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->695
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->695
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->695
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->695
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub printTableCREInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $geneInfoHsh_ref, $outputPrefix, $result_log_dir, $trnscptInfoHsh_ref
#	output: none
#	toCall: &printTableCREInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);
#	calledInLine: 249
#....................................................................................................................................................#

	my ($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $CREInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix) = @_;
	
	my $filePath = "$result_log_dir/$outputPrefix.CRE.info.tsv.gz";
	open CRELOG, "| gzip -c >$filePath";
	my @headerAry = ('CREID', 'CREName', 'typeStr', 'mask', 'score', 'geneNum', 'clusterIDStr', 'trnscptIDStr', 'geneIDStr', 'geneNameStr', 'geneClassStr', 'codingClassStr', 'proximity', 'regionType', 'regionOritentation', 'regionGeneID', 'class', 'best_prob', 'best_clusterID', 'sumClusterRead', 'gene_promoter', 'gene_promoter_geneID');
	print CRELOG join "", (join "\t", @headerAry), "\n";
	&reportAndLogStatus("Printing CRE info", 0, "\n");#->2953

	$globalReadmeHsh_ref->{$filePath}{'description'} = "cis-regulatory element CRE annotation, one-row-per CRE, with infomation of its associated genes and clusters";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'CREID'} = '[unique ID] Identifier of the CRE.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'CREName'} = '[string] Name of the CRE, in format of [r][rank]@[geneNameX],[r][rank]@[geneNameY]';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'mask'} = '[yes or no] its cluster is masked, or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'typeStr'} = '[string] the type of its cluster, annotated as gene tss or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneNum'} = '[string] number of gene associated with the CRE';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneIDStr'} = '[string] Identifier of gene associated with its cluster, ";" delimited. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated TSS clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneNameStr'} = '[string] Name of gene associated with its cluster, ";" delimited. Mainly inherited from the "gene name" field in GENCODE, , plus "addon" genes from unannotated TSS clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneClassStr'} = '[string] Class of gene associated with its cluster, ";" delimited. if anno was from genecode, it refers to the biotype of the genes from genecode. if anno was from FANTOM CAT, it refers to the gene classes of the genes in FANTOM CAT.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscptIDStr'} = '[string] ID of transcripts associated with its cluster, ";" delimited.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'score'} = '[integer] score in the input cluster bed file. #UMI for single cell and #read for bulk';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'codingClassStr'} = '[string] Assigned based on predefined coding status of geneClass';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionType'} = '[end5 exon intron or intergenic] within or in the proximity of the end5, exon or intron, or else intergenic';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionOritentation'} = '[ns ss or as] oritentation relative to the region in regionType, sense strand, antisense strand, or non-stranded';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionGeneID'} = '[unique ID] ID of the gene which contributes to the annotation of the regionType';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'proximity'} = '[proxmial or distal] proximity or distal to genes tss';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'class'} = '[coding, noncoding, distal and other] CRE of coding gene tss, CRE of noncoding genes tss or CRE that is distant from gene tss, or others (including CRE that is close to gene tss but not on the same strand as the gene of mixed of multiple genetypes)';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'best_clusterID'} = '[unique ID] ClusterID with best prob';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'best_prob'} = '[float] lowest prob among all ClusterID';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'sumClusterRead'} = '[integer] sum of read within its member cluster';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'gene_promoter'} = '[annotated, unannotated or none] is defined as a gene promoter, with annotated transcript (annotated), or without annotated transcripts (unannotated), or otherwise (none)';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'gene_promoter_geneID'} = '[string] is defined as the promoter of genes with these geneIDs, ";" delimited.';

	my $count_hsh_ref = {};
	foreach my $CREID (sort keys %{$CREInfoHsh_ref}) {
		my $CREName = $CREInfoHsh_ref->{$CREID}{'CREName'};
		my $score = $CREInfoHsh_ref->{$CREID}{'score'};
		my $mask = $CREInfoHsh_ref->{$CREID}{'mask'};
		my $gene_promoter = $CREInfoHsh_ref->{$CREID}{'gene_promoter'};
		my $gene_promoter_geneID = 'none';
		$gene_promoter_geneID = join ";", (sort keys %{$CREInfoHsh_ref->{$CREID}{'gene_promoter_geneID'}}) if exists $CREInfoHsh_ref->{$CREID}{'gene_promoter_geneID'};
		my %IDHsh = ();
		my $best_clusterID;
		my $best_prob = 0;
		
		foreach my $clusterID (sort keys %{$CREInfoHsh_ref->{$CREID}{'clusterID'}}) {
			my $prob = $clusterInfoHsh_ref->{$clusterID}{'prob'};
			if ($prob > $best_prob) {
				$best_clusterID = $clusterID;
				$best_prob = $prob;
			}
			
			my $type = $clusterInfoHsh_ref->{$clusterID}{'type'};
			foreach my $trnscptID (sort keys %{$clusterInfoHsh_ref->{$clusterID}{'trnscptID'}}) {
				my $hit = $clusterInfoHsh_ref->{$clusterID}{'trnscptID'}{$trnscptID};
				my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
				my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
				my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
				my $codingClass = 'unknown';
				$codingClass = $coding_class_hsh_ref->{$geneClass} if (exists $coding_class_hsh_ref->{$geneClass});

				$IDHsh{'type'}{$type}++;
				$IDHsh{'clusterID'}{$clusterID}++;
				$IDHsh{'geneID'}{$geneID}++;
				$IDHsh{'trnscptID'}{$trnscptID}++;
				$IDHsh{'geneName'}{$geneName}++;
				$IDHsh{'geneClass'}{$geneClass}++;
				$IDHsh{'codingClass'}{$codingClass}++;
			}
		}

		my $typeStr = join ";", (sort keys %{$IDHsh{'type'}});
		my $clusterIDStr = join ";", (sort keys %{$IDHsh{'clusterID'}});
		my $trnscptIDStr = join ";", (sort keys %{$IDHsh{'trnscptID'}});
		my $geneIDStr = join ";", (sort keys %{$IDHsh{'geneID'}});
		my $geneNameStr = join ";", (sort keys %{$IDHsh{'geneName'}});
		my $geneClassStr = join ";", (sort keys %{$IDHsh{'geneClass'}});
		my $codingClassStr = join ";", (sort keys %{$IDHsh{'codingClass'}});
		my $geneNum = keys %{$IDHsh{'geneID'}};

		my $sumClusterRead = $CREInfoHsh_ref->{$CREID}{'sumClusterRead'};
		my $regionGeneID = $CREInfoHsh_ref->{$CREID}{'regionGeneID'};
		my $regionType = $CREInfoHsh_ref->{$CREID}{'regionType'};
		my $regionOritentation = $CREInfoHsh_ref->{$CREID}{'regionOritentation'};
		my $proximity = $CREInfoHsh_ref->{$CREID}{'proximity'};

		my $class = 'other';
		
		if ($proximity eq 'proximal' and exists $IDHsh{'codingClass'}{'coding'}) {
			$class = 'coding';
			
		} elsif ($proximity eq 'proximal' and exists $IDHsh{'codingClass'}{'noncoding'}) {
			$class = 'noncoding';
			
		} elsif ($proximity eq 'distal') {
			$class = 'distal';
		}
		
		$count_hsh_ref->{'class'}{'count'}{$class}++;
		$count_hsh_ref->{'proximity'}{'count'}{$proximity}++;
		$count_hsh_ref->{'codingClassStr'}{'count'}{$codingClassStr}++;
		$count_hsh_ref->{'regionType'}{'count'}{$regionType}++;
		$count_hsh_ref->{'class'}{'total'}++;
		$count_hsh_ref->{'proximity'}{'total'}++;
		$count_hsh_ref->{'codingClassStr'}{'total'}++;
		$count_hsh_ref->{'regionType'}{'total'}++;
		
		print CRELOG join "", (join "\t", ($CREID, $CREName, $typeStr, $mask, $score, $geneNum, $clusterIDStr, $trnscptIDStr, $geneIDStr, $geneNameStr, $geneClassStr, $codingClassStr, $proximity, $regionType, $regionOritentation, $regionGeneID, $class, $best_prob, $best_clusterID, $sumClusterRead, $gene_promoter, $gene_promoter_geneID)), "\n";

	}
	close CRELOG;
	
	foreach my $anno_type (sort keys %{$count_hsh_ref}) {
		&reportAndLogStatus("--- CRE $anno_type count statistics ---", 10, "\n");#->2953
		my $total = $count_hsh_ref->{$anno_type}{'total'};
		foreach my $anno_ID (sort {$count_hsh_ref->{$anno_type}{'count'}{$b} <=> $count_hsh_ref->{$anno_type}{'count'}{$a}} keys %{$count_hsh_ref->{$anno_type}{'count'}}) {
			my $count = $count_hsh_ref->{$anno_type}{'count'}{$anno_ID};
			my $pct = sprintf "%.3f", 100*$count/$total;
			&reportAndLogStatus("CRE $anno_type: $anno_ID = $count [$pct%]", 10, "\n");#->2953

		}
	}
}
sub printTableClusterInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref, $coding_class_hsh_ref, $geneInfoHsh_ref, $outputPrefix, $result_log_dir, $trnscptInfoHsh_ref
#	output: none
#	toCall: &printTableClusterInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);
#	calledInLine: 245
#....................................................................................................................................................#

	my ($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix) = @_;
	
	my $filePath = "$result_log_dir/$outputPrefix.cluster.info.tsv.gz";
	open CLUSTERLOG, "| gzip -c >$filePath";
	my @headerAry = ('clusterID', 'clusterName', 'type', 'mask', 'score', 'geneNum', 'trnscptIDStr', 'geneIDStr', 'geneNameStr', 'geneClassStr', 'codingClassStr', 'proximity', 'regionType', 'regionOritentation', 'regionGeneID', 'class', 'CREID', 'prob');
	print CLUSTERLOG join "", (join "\t", @headerAry), "\n";
	&reportAndLogStatus("Printing gene info", 0, "\n");#->2953

	$globalReadmeHsh_ref->{$filePath}{'description'} = "TSS cluster centric annotation, one-row-per TSS cluster, with infomation of its associated genes";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterID'} = '[unique ID] Identifier of the TSS cluster.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterName'} = '[string] Name of the cluster, in format of [p|e][rank]@[geneNameX],[p|e][rank]@[geneNameY]';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'mask'} = '[yes or no] the TSS cluster is masked, or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'type'} = '[gene_tss or unanno_tss] the TSS cluster is annotated as gene tss or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneNum'} = '[string] number of gene associated with the TSS cluster';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneIDStr'} = '[string] Identifier of gene associated with the TSS cluster, ";" delimited. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated TSS clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneNameStr'} = '[string] Name of gene associated with the TSS cluster, ";" delimited. Mainly inherited from the "gene name" field in GENCODE, , plus "addon" genes from unannotated TSS clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneClassStr'} = '[string] Class of gene associated with the TSS cluster, ";" delimited. if anno was from genecode, it refers to the biotype of the genes from genecode. if anno was from FANTOM CAT, it refers to the gene classes of the genes in FANTOM CAT.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscptIDStr'} = '[string] ID of transcripts associated with the TSS cluster, ";" delimited.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'score'} = '[integer] score in the input bed';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'codingClassStr'} = '[string] Assigned based on predefined coding status of geneClass';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionType'} = '[end5 exon intron or intergenic] within or in the proximity of the end5, exon or intron, or else intergenic';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionOritentation'} = '[ns ss or as] oritentation relative to the region in regionType, sense strand, antisense strand, or non-stranded';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'regionGeneID'} = '[unique ID] ID of the gene which contributes to the annotation of the regionType';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'proximity'} = '[proxmial or distal] proximity or distal to genes tss';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'class'} = '[coding, noncoding, distal and other] cluster of coding gene tss, cluster of noncoding genes tss or cluster that is distant from gene tss, or others (including cluster that is close to gene tss but not on the same strand as the gene of mixed of multiple genetypes)';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'CREID'} = '[unique ID] ID of the CRE the cluster belongs to';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'prob'} = '[float] False discovery rate of cluster on background filtering';

	my $count_hsh_ref = {};
	foreach my $clusterID (sort keys %{$clusterInfoHsh_ref}) {
		my $clusterName = $clusterInfoHsh_ref->{$clusterID}{'clusterName'};
		my $score = $clusterInfoHsh_ref->{$clusterID}{'score'};
		my $type = $clusterInfoHsh_ref->{$clusterID}{'type'};
		my $mask = $clusterInfoHsh_ref->{$clusterID}{'mask'};
		my $CREID = $clusterInfoHsh_ref->{$clusterID}{'CREID'};
		my $prob = $clusterInfoHsh_ref->{$clusterID}{'prob'};
		my %IDHsh = ();
		foreach my $trnscptID (sort keys %{$clusterInfoHsh_ref->{$clusterID}{'trnscptID'}}) {
			my $hit = $clusterInfoHsh_ref->{$clusterID}{'trnscptID'}{$trnscptID};
			my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
			my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
			my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
			my $codingClass = 'unknown';
			$codingClass = $coding_class_hsh_ref->{$geneClass} if (exists $coding_class_hsh_ref->{$geneClass});

			$IDHsh{'geneID'}{$geneID}++;
			$IDHsh{'trnscptID'}{$trnscptID}++;
			$IDHsh{'geneName'}{$geneName}++;
			$IDHsh{'geneClass'}{$geneClass}++;
			$IDHsh{'codingClass'}{$codingClass}++;
		}
		my $trnscptIDStr = join ";", (sort keys %{$IDHsh{'trnscptID'}});
		my $geneIDStr = join ";", (sort keys %{$IDHsh{'geneID'}});
		my $geneNameStr = join ";", (sort keys %{$IDHsh{'geneName'}});
		my $geneClassStr = join ";", (sort keys %{$IDHsh{'geneClass'}});
		my $codingClassStr = join ";", (sort keys %{$IDHsh{'codingClass'}});
		my $geneNum = keys %{$IDHsh{'geneID'}};

		my $regionGeneID = $clusterInfoHsh_ref->{$clusterID}{'regionGeneID'};
		my $regionType = $clusterInfoHsh_ref->{$clusterID}{'regionType'};
		my $regionOritentation = $clusterInfoHsh_ref->{$clusterID}{'regionOritentation'};
		my $proximity = $clusterInfoHsh_ref->{$clusterID}{'proximity'};

		my $class = 'other';
		
		if ($proximity eq 'proximal' and exists $IDHsh{'codingClass'}{'coding'}) {
			$class = 'coding';
			
		} elsif ($proximity eq 'proximal' and exists $IDHsh{'codingClass'}{'noncoding'}) {
			$class = 'noncoding';
			
		} elsif ($proximity eq 'distal') {
			$class = 'distal';
		}
		
		$count_hsh_ref->{'class'}{'count'}{$class}++;
		$count_hsh_ref->{'proximity'}{'count'}{$proximity}++;
		$count_hsh_ref->{'codingClassStr'}{'count'}{$codingClassStr}++;
		$count_hsh_ref->{'regionType'}{'count'}{$regionType}++;
		$count_hsh_ref->{'class'}{'total'}++;
		$count_hsh_ref->{'proximity'}{'total'}++;
		$count_hsh_ref->{'codingClassStr'}{'total'}++;
		$count_hsh_ref->{'regionType'}{'total'}++;
		
		print CLUSTERLOG join "", (join "\t", ($clusterID, $clusterName, $type, $mask, $score, $geneNum, $trnscptIDStr, $geneIDStr, $geneNameStr, $geneClassStr, $codingClassStr, $proximity, $regionType, $regionOritentation, $regionGeneID, $class, $CREID, $prob)), "\n";

	}
	close CLUSTERLOG;
	
	foreach my $anno_type (sort keys %{$count_hsh_ref}) {
		&reportAndLogStatus("--- cluster $anno_type count statistics ---", 10, "\n");#->2953
		my $total = $count_hsh_ref->{$anno_type}{'total'};
		foreach my $anno_ID (sort {$count_hsh_ref->{$anno_type}{'count'}{$b} <=> $count_hsh_ref->{$anno_type}{'count'}{$a}} keys %{$count_hsh_ref->{$anno_type}{'count'}}) {
			my $count = $count_hsh_ref->{$anno_type}{'count'}{$anno_ID};
			my $pct = sprintf "%.3f", 100*$count/$total;
			&reportAndLogStatus("cluster  $anno_type: $anno_ID = $count [$pct%]", 10, "\n");#->2953

		}
	}
}
sub printTableDistalCRELocusInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $distal_CRE_locus_info_hsh_ref, $outputPrefix, $result_log_dir
#	output: none
#	toCall: &printTableDistalCRELocusInfo($result_log_dir, $distal_CRE_locus_info_hsh_ref, $outputPrefix);
#	calledInLine: 251
#....................................................................................................................................................#

	my ($result_log_dir, $distal_CRE_locus_info_hsh_ref, $outputPrefix) = @_;
	
	my $filePath = "$result_log_dir/$outputPrefix.distal_CRE_locus.info.tsv.gz";
	open DLLOG, "| gzip -c >$filePath";
	my @headerAry = ('distal_CRE_locus_ID', 'chrom', 'start', 'end', 'size', 'CREnum', 'total_count', 'top_count', 'top_frac', 'spreadness', 'hyperactive', 'CREID_str');
	print DLLOG join "", (join "\t", @headerAry), "\n";
	&reportAndLogStatus("Printing CRE info", 0, "\n");#->2953

	$globalReadmeHsh_ref->{$filePath}{'description'} = "distal CRE locus (groups of CREs), one-row-per locus, with infomation of its CRE and activity";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'distal_CRE_locus_ID'} = '[unique ID] Identifier of the distal locus';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'chrom'} = '[string] ID of chromosome';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'start'} = '[integer] start of the locus';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'end'} = '[integer] end of the locus';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'size'} = '[integer] size of the locus in base pair';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'CREnum'} = '[string] Number of CRE associated with the locus';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'total_count'} = '[integer] Sum of read counts of all its CRE';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'top_count'} = '[integer] Read counts of the highest expressed CRE';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'top_frac'} = '[fraction] top_count / total_count';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'hyperactive'} = '[yes/no] Defined as hyperactive, or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'CREID_str'} = '[string] ID of CRE associated with the locus, ";" delimited.';

	my $count_hsh_ref = {};
	foreach my $distal_CRE_locus_ID (sort keys %{$distal_CRE_locus_info_hsh_ref}) {
		my $CREID_str = join ";", sort @{$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'CREID'}};
		my ($chrom, $start, $end) = @{$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'loc'}};
		my $total_count = $distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'total_count'};
		my $top_count = $distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'top_count'};
		my $top_frac = $distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'top_frac'};
		my $spreadness = $distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'spreadness'};
		my $size = $distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'size'};
		my $hyperactive = $distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'hyperactive'};
		my $CREnum = @{$distal_CRE_locus_info_hsh_ref->{$distal_CRE_locus_ID}{'CREID'}};

		print DLLOG join "", (join "\t", ($distal_CRE_locus_ID, $chrom, $start, $end, $size, $CREnum, $total_count, $top_count, $top_frac, $spreadness, $hyperactive, $CREID_str)), "\n";

	}
	close DLLOG;
	
}
sub printTableGeneInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $coding_class_hsh_ref, $geneInfoHsh_ref, $outputPrefix, $result_log_dir
#	output: none
#	toCall: &printTableGeneInfo($result_log_dir, $geneInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);
#	calledInLine: 246
#....................................................................................................................................................#

	my ($result_log_dir, $geneInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix) = @_;
	
	&reportAndLogStatus("Printing gene info", 0, "\n");#->2953

	my $filePath = "$result_log_dir/$outputPrefix.gene.info.tsv.gz";
	open GENELOG, "| gzip -c >$filePath";
	my @headerAry = ('geneID', 'geneClass', 'geneName', 'mask', 'trnscpt_num', 'cluster_num', 'end5_hit_num', 'exon_hit_num', 'addon_hit_num', 'trnscptIDStr', 'clusterIDStr', 'codingClass');
	print GENELOG join "", (join "\t", @headerAry), "\n";

	$globalReadmeHsh_ref->{$filePath}{'description'} = "Gene centric annotation, one-row-per gene, with its annotation and its associated TSS clusters and transcripts";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneID'} = '[unique ID] Identifier of the gene. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated TSS clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneClass'} = '[string] Class of the gene. if anno was from genecode, it refers to the biotype of the genes from genecode. if anno was from FANTOM CAT, it refers to the gene classes of the genes in FANTOM CAT.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'mask'} = '[yes or no] transcript is masked from the mask gtf, or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneName'} = '[string] Name of the gene. Mainly inherited from the "gene name" field in GENCODE, , plus "addon" genes from unannotated TSS clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscpt_num'} = '[non-zero positive integer] Num of transcripts associated with the gene.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'cluster_num'} = '[non-zero positive integer] Num of TSS clusters associated with the gene.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'end5_hit_num'} = '[integer] num of TSS cluster hit on 5\'end of its associated transcripts';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'exon_hit_num'} = '[integer] num of TSS cluster hit on exon of its associated transcripts';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'addon_hit_num'} = '[integer] num of TSS cluster addon for its associated transcripts';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscptIDStr'} = '[string] ID of transcripts associated with the gene, ";" delimited.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterIDStr'} = '[string] ID of cluster associated with the gene, ";" delimited.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'codingClass'} = '[coding, noncoding, pseudogene, others or unknown] assigned based on predefined coding status of geneClass';

	foreach my $geneID (sort keys %{$geneInfoHsh_ref}) {
		my $trnscptIDStr = join ";", (sort keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}});
		my $clusterIDStr = join ";", (sort keys %{$geneInfoHsh_ref->{$geneID}{'clusterID'}});
		my $cluster_num = keys %{$geneInfoHsh_ref->{$geneID}{'clusterID'}};
		my $trnscpt_num = keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}};
		my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
		my $mask = $geneInfoHsh_ref->{$geneID}{'mask'};
		my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
		my $codingClass = 'unknown';
		$codingClass = $coding_class_hsh_ref->{$geneClass} if (exists $coding_class_hsh_ref->{$geneClass});
		my $end5_hit_num = 0;
		my $exon_hit_num = 0;
		my $addon_hit_num = 0;
		foreach my $clusterID (keys %{$geneInfoHsh_ref->{$geneID}{'clusterID'}}) {
			$end5_hit_num++ if $geneInfoHsh_ref->{$geneID}{'clusterID'}{$clusterID} eq 'end5';
			$exon_hit_num++ if $geneInfoHsh_ref->{$geneID}{'clusterID'}{$clusterID} eq 'exon';
			$addon_hit_num++ if $geneInfoHsh_ref->{$geneID}{'clusterID'}{$clusterID} eq 'addon';
		}
	
		print GENELOG join "", (join "\t", ($geneID, $geneClass, $geneName, $mask, $trnscpt_num, $cluster_num, $end5_hit_num, $exon_hit_num, $addon_hit_num, $trnscptIDStr, $clusterIDStr, $codingClass)), "\n";
	}
	close GENELOG;

}
sub printTableIDMappingInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref, $coding_class_hsh_ref, $geneInfoHsh_ref, $outputPrefix, $result_log_dir, $trnscptInfoHsh_ref
#	output: none
#	toCall: &printTableIDMappingInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);
#	calledInLine: 247
#....................................................................................................................................................#

	my ($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $clusterInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix) = @_;
	
	&reportAndLogStatus("Printing ID mapping table log files", 10, "\n");#->2953

	my $filePath = "$result_log_dir/$outputPrefix.ID_mapping.info.tsv.gz";
	open IDLOG, "| gzip -c >$filePath";
	my @headerAry = ('clusterID', 'clusterName', 'type', 'trnscptID', 'geneID', 'geneName', 'geneClass', 'mask', 'rank', 'tag_count', 'hit', 'codingClass', 'CREID');
	print IDLOG join "", (join "\t", @headerAry), "\n";
	&reportAndLogStatus("Printing ID mapping info", 0, "\n");#->2953

	$globalReadmeHsh_ref->{$filePath}{'description'} = "1-to-1 mapping between IDs of genes, transcripts and TSS clusters";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterID'} = '[unique ID] Identifier of the TSS cluster.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterName'} = '[string] Name of the cluster, in format of [p|e][rank]@[geneNameX],[p|e][rank]@[geneNameY]';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'mask'} = '[yes or no] transcript is masked from the mask gtf, or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'type'} = '[gene_tss or unanno_tss] the TSS cluster is annotated as gene tss or not';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneID'} = '[unique ID] Identifier of the gene. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated TSS clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscptID'} = '[unique ID] Identifier of the transcripts. Mainly inherited from the "transcript ID" field in GENCODE or FANTOM CAT, plus "addon" transcripts from unannotated TSS clusters [ADDT#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneName'} = '[string] Name of the gene. Mainly inherited from the "gene name" field in GENCODE, , plus "addon" genes from unannotated TSS clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneClass'} = '[string] Class of the gene. if anno was from genecode, it refers to the biotype of the genes from genecode. if anno was from FANTOM CAT, it refers to the gene classes of the genes in FANTOM CAT.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'rank'} = '[integer] rank of the cluster within the gene';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'tag_count'} = '[integer] number of ctss tag count';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'hit'} = '[end5, exon or addon] location of clusterID "hit" on the transcript, can at 5\'end, on exon, or addon. exon hit will be turned of if exon_slop_rng==-1. addon refers to dummy transcripts added to unannotated TSS clusters';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'codingClass'} = '[coding, noncoding, pseudogene, others or unknown] assigned based on predefined coding status of geneClass';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'CREID'} = '[unique ID] ID of the CRE the clusterID belongs to';
	
	foreach my $clusterID (sort keys %{$clusterInfoHsh_ref}) {
		my $type = $clusterInfoHsh_ref->{$clusterID}{'type'};
		my $clusterName = $clusterInfoHsh_ref->{$clusterID}{'clusterName'};
		my $CREID = $clusterInfoHsh_ref->{$clusterID}{'CREID'};
		foreach my $trnscptID (sort keys %{$clusterInfoHsh_ref->{$clusterID}{'trnscptID'}}) {
			my $hit = $clusterInfoHsh_ref->{$clusterID}{'trnscptID'}{$trnscptID};
			my $mask = $trnscptInfoHsh_ref->{$trnscptID}{'mask'};
			my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
			my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
			my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
			my $rank = $clusterInfoHsh_ref->{$clusterID}{'rank'}{$geneID};
			my $tag_count = $clusterInfoHsh_ref->{$clusterID}{'score'};
			my $codingClass = 'unknown';
			$codingClass = $coding_class_hsh_ref->{$geneClass} if (exists $coding_class_hsh_ref->{$geneClass});
			print IDLOG join "", (join "\t", ($clusterID, $clusterName, $type, $trnscptID, $geneID, $geneName, $geneClass, $mask, $rank, $tag_count, $hit, $codingClass, $CREID)), "\n";
		}
	}
	close IDLOG;

}
sub printTableTranscriptInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $coding_class_hsh_ref, $geneInfoHsh_ref, $outputPrefix, $result_log_dir, $trnscptInfoHsh_ref
#	output: none
#	toCall: &printTableTranscriptInfo($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix);
#	calledInLine: 248
#....................................................................................................................................................#

	my ($result_log_dir, $geneInfoHsh_ref, $trnscptInfoHsh_ref, $coding_class_hsh_ref, $outputPrefix) = @_;
	
	my $filePath = "$result_log_dir/$outputPrefix.transcript.info.tsv.gz";
	open TRANSCRIPTLOG, "| gzip -c >$filePath";
	my @headerAry = ('trnscptID', 'geneID', 'geneClass', 'geneName', 'mask', 'cluster_num', 'end5_hit_num', 'exon_hit_num', 'addon_hit_num', 'clusterIDStr', 'codingClass');
	print TRANSCRIPTLOG join "", (join "\t", @headerAry), "\n";
	&reportAndLogStatus("Printing transcript info", 0, "\n");#->2953

	$globalReadmeHsh_ref->{$filePath}{'description'} = "transcript centric annotation, one-row-per gene, with its gene annotation and its associated TSS clusters";
	@{$globalReadmeHsh_ref->{$filePath}{'headerAry'}} = @headerAry;

	$globalReadmeHsh_ref->{$filePath}{'header'}{'trnscptID'} = '[unique ID] Identifier of the transcript. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated TSS clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneID'} = '[unique ID] Identifier of the gene. Mainly inherited from the "gene ID" field in GENCODE or FANTOM CAT, plus "addon" genes from groups of unannotated TSS clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneClass'} = '[string] Class of the gene. if anno was from genecode, it refers to the biotype of the genes from genecode. if anno was from FANTOM CAT, it refers to the gene classes of the genes in FANTOM CAT.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'geneName'} = '[string] Name of the gene. Mainly inherited from the "gene name" field in GENCODE, , plus "addon" genes from unannotated TSS clusters [ADDG#########].';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'cluster_num'} = '[non-zero positive integer] Num of TSS clusters associated with the transcript.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'end5_hit_num'} = '[integer] num of TSS cluster hit on 5\'end of it';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'exon_hit_num'} = '[integer] num of TSS cluster hit on exon of it';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'addon_hit_num'} = '[integer] num of TSS cluster addon for it';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'clusterIDStr'} = '[string] ID of cluster associated with the transcript, ";" delimited.';
	$globalReadmeHsh_ref->{$filePath}{'header'}{'mask'} = '[yes or no] transcript is masked from the mask gtf, or not';
	
	foreach my $trnscptID (sort keys %{$trnscptInfoHsh_ref}) {
		my $mask = $trnscptInfoHsh_ref->{$trnscptID}{'mask'};
		my $geneID = $trnscptInfoHsh_ref->{$trnscptID}{'geneID'};
		my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
		my $codingClass = 'unknown';
		$codingClass = $coding_class_hsh_ref->{$geneClass} if (exists $coding_class_hsh_ref->{$geneClass});
		my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
		my $clusterIDStr = join ";", (sort keys %{$trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}});
		my $cluster_num = keys %{$trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}};
		my $end5_hit_num = 0;
		my $exon_hit_num = 0;
		my $addon_hit_num = 0;
		foreach my $clusterID (keys %{$trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}}) {
			$end5_hit_num++ if $trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID} eq 'end5';
			$exon_hit_num++ if $trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID} eq 'exon';
			$addon_hit_num++ if $trnscptInfoHsh_ref->{$trnscptID}{'clusterID'}{$clusterID} eq 'addon';
		}

		print TRANSCRIPTLOG join "", (join "\t", ($trnscptID, $geneID, $geneClass, $geneName, $mask, $cluster_num, $end5_hit_num, $exon_hit_num, $addon_hit_num, $clusterIDStr, $codingClass)), "\n";
	}
	close TRANSCRIPTLOG;
}
sub printTrnscptGtf {
#....................................................................................................................................................#
#	subroutineCategory: specific
#	dependOnSub: exonRngToGtf|1095
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref, $outputPrefix, $result_gtf_dir, $trnscptInfoHsh_ref
#	output: 
#	toCall: &printTrnscptGtf($result_gtf_dir, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $outputPrefix);
#	calledInLine: 250
#....................................................................................................................................................#
	my ($result_gtf_dir, $trnscptInfoHsh_ref, $geneInfoHsh_ref, $outputPrefix) = @_;
	
	my $all_trnscpt_gtf_path = "$result_gtf_dir/$outputPrefix.gtf.gz";
	$globalReadmeHsh_ref->{$all_trnscpt_gtf_path}{'description'} = "It contains all transcripts, including the addon transcripts, without masking on structural RNA and small RNAs";

	my $mask_trnscpt_gtf_path = "$result_gtf_dir/$outputPrefix.masked.gtf.gz";
	$globalReadmeHsh_ref->{$mask_trnscpt_gtf_path}{'description'} = "It contains transcripts, including the addon transcripts, with structural RNA and small RNA masked, suitable for running cufflinks or stringtie";
	
	open (ALL, "| sort -k1,1 -k4,4n | gzip -c >$all_trnscpt_gtf_path");
	open (MASK, "| sort -k1,1 -k4,4n | gzip -c >$mask_trnscpt_gtf_path");

	foreach my $geneID (sort keys %{$geneInfoHsh_ref}) {
		my $sourceTag = 'DGT';
		my $mask = $geneInfoHsh_ref->{$geneID}{'mask'};
		my $g_chrom = $geneInfoHsh_ref->{$geneID}{'chrom'};
		my $g_strand = $geneInfoHsh_ref->{$geneID}{'strand'};
		my ($geneStart, $geneEnd) = @{$geneInfoHsh_ref->{$geneID}{'geneRng'}};
		my $geneClass = $geneInfoHsh_ref->{$geneID}{'geneClass'};
		my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
		my $gtfStart = $geneStart;
		my $gtfEnd = $geneEnd;
		
		#chr1	FANTOM	gene	47082703	47083645	.	+	.	gene_id "CATG00000000004.1"; geneSuperClass "all_lncRNA";  geneClass "CATG00000000004.1";  geneSubClass "divergent_promoters"; gene_type "__na"; gene_name "CATG00000000004.1"; coding_status "nonCoding"; cumulative_support "ENCODE"; geneCategory "p_lncRNA_divergent"; DHS_type "DHS_promoter";	
		my @gene_line_ary = ($g_chrom, $sourceTag, 'gene', $gtfStart, $gtfEnd, '.', $g_strand, '.', "gene_id \"$geneID\"; geneClass \"$geneClass\"; gene_type \"$geneClass\"; gene_name \"$geneName\"; geneAnnoPlus \"$geneClass\";");
		print ALL join "", (join "\t", (@gene_line_ary)), "\n";
		if ($mask eq 'no') {
			print MASK join "", (join "\t", (@gene_line_ary)), "\n";
		}
		
		foreach my $trnscptID (keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}}) {
			my $chrom = $trnscptInfoHsh_ref->{$trnscptID}{'chrom'};
			my $strand = $trnscptInfoHsh_ref->{$trnscptID}{'strand'};

			my $exonRngAry_ref = $trnscptInfoHsh_ref->{$trnscptID}{'exonRng'};
			my ($gtf_ary_ref) = &exonRngToGtf($exonRngAry_ref, $chrom, $strand, $trnscptID, $geneID, $sourceTag);#->1095
		
			print ALL join "", (join "\t", (@{$_})), "\n" foreach @{$gtf_ary_ref};
			if ($mask eq 'no') {
				print MASK join "", (join "\t", (@{$_})), "\n" foreach @{$gtf_ary_ref};
			}
		}
	}
	
	close ALL;
	close MASK;

	return ();
}
sub rankCREWithinGene {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref, $geneInfoHsh_ref
#	output: 
#	toCall: &rankCREWithinGene($CREInfoHsh_ref, $geneInfoHsh_ref);
#	calledInLine: 239
#....................................................................................................................................................#
	my ($CREInfoHsh_ref, $geneInfoHsh_ref) = @_;

	my $proximity_tag_hsh_ref = {
		'proximal' => "P",
		'distal' => "D",
	};
	
	foreach my $geneID (sort keys %{$geneInfoHsh_ref}) {
		my $rank_hsh_ref = {};
		foreach my $CREID (keys %{$geneInfoHsh_ref->{$geneID}{'CREID'}}) {
			my $sumClusterRead = $CREInfoHsh_ref->{$CREID}{'sumClusterRead'};
			push @{$rank_hsh_ref->{$sumClusterRead}}, $CREID;
		}

		my $rank = 1;
		foreach my $sumClusterRead (sort {$b <=> $a} keys %{$rank_hsh_ref}) {
			foreach my $CREID (sort {$a cmp $b} @{$rank_hsh_ref->{$sumClusterRead}}) {
				$CREInfoHsh_ref->{$CREID}{'rank'}{$geneID} = $rank;
				$rank++;
			}
		}
	}	
	
	foreach my $CREID (sort keys %{$CREInfoHsh_ref}) {

		my $rank_hsh_ref = {};
		foreach my $geneID (keys %{$CREInfoHsh_ref->{$CREID}{'rank'}}) {
			my $rank = $CREInfoHsh_ref->{$CREID}{'rank'}{$geneID};
			push @{$rank_hsh_ref->{$rank}}, $geneID;
		}

		my @CRENameAry = ();
		foreach my $rank (sort {$a <=> $b} keys %{$rank_hsh_ref}) {
			foreach my $geneID (sort {$a cmp $b} @{$rank_hsh_ref->{$rank}}) {
				my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
				push @CRENameAry, "r$rank\@$geneName";
			}
		}
		my $proximity = $CREInfoHsh_ref->{$CREID}{'proximity'};
		my $proximity_tag = $proximity_tag_hsh_ref->{$proximity};
		my $CREName = join ":", ($proximity_tag, (join ",", @CRENameAry));
		$CREInfoHsh_ref->{$CREID}{'CREName'} = $CREName;
	}

	return ();
}
sub rankClusterWithinGene {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref, $geneInfoHsh_ref
#	output: 
#	toCall: &rankClusterWithinGene($clusterInfoHsh_ref, $geneInfoHsh_ref);
#	calledInLine: 236
#....................................................................................................................................................#
	my ($clusterInfoHsh_ref, $geneInfoHsh_ref) = @_;

	my $proximity_tag_hsh_ref = {
		'proximal' => "P",
		'distal' => "D",
	};

	foreach my $geneID (sort keys %{$geneInfoHsh_ref}) {
		my $rank_hsh_ref = {};
		foreach my $clusterID (keys %{$geneInfoHsh_ref->{$geneID}{'clusterID'}}) {
			my $count = $clusterInfoHsh_ref->{$clusterID}{'count'};
			push @{$rank_hsh_ref->{$count}}, $clusterID;
		}

		my $rank = 1;
		foreach my $count (sort {$b <=> $a} keys %{$rank_hsh_ref}) {
			foreach my $clusterID (sort {$a cmp $b} @{$rank_hsh_ref->{$count}}) {
				$clusterInfoHsh_ref->{$clusterID}{'rank'}{$geneID} = $rank;
				$rank++;
			}
		}
	}	
	
	foreach my $clusterID (sort keys %{$clusterInfoHsh_ref}) {
		my $rank_hsh_ref = {};
		foreach my $geneID (keys %{$clusterInfoHsh_ref->{$clusterID}{'rank'}}) {
			my $rank = $clusterInfoHsh_ref->{$clusterID}{'rank'}{$geneID};
			push @{$rank_hsh_ref->{$rank}}, $geneID;
		}

		my @clusterNameAry = ();
		foreach my $rank (sort {$a <=> $b} keys %{$rank_hsh_ref}) {
			foreach my $geneID (sort {$a cmp $b} @{$rank_hsh_ref->{$rank}}) {
				my $geneName = $geneInfoHsh_ref->{$geneID}{'geneName'};
				push @clusterNameAry, "c$rank\@$geneName";
			}
		}

		my $proximity = $clusterInfoHsh_ref->{$clusterID}{'proximity'};
		my $proximity_tag = $proximity_tag_hsh_ref->{$proximity};
		my $clusterName = join ":", ($proximity_tag, (join ",", @clusterNameAry));
		$clusterInfoHsh_ref->{$clusterID}{'clusterName'} = $clusterName;
	}

	return ();
}
sub readChromSize {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $chrom_size_path
#	output: $chrom_size_hsh_ref
#	toCall: my ($chrom_size_hsh_ref) = &readChromSize($chrom_size_path);
#	calledInLine: 220
#....................................................................................................................................................#
	my ($chrom_size_path) = @_;
	
	my $chrom_size_hsh_ref = {};
	open (CHROMSIZE, "<", $chrom_size_path);
	while (<CHROMSIZE>) {
		chomp;
		my ($chrom, $size) = split /\s+/;
		$chrom_size_hsh_ref->{$chrom} = $size;
	}
	close CHROMSIZE;

	return ($chrom_size_hsh_ref);
}
sub readClusterBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $tssCluster_bed_path
#	output: $clusterInfoHsh_ref
#	toCall: my ($clusterInfoHsh_ref) = &readClusterBed($tssCluster_bed_path);
#	calledInLine: 226
#....................................................................................................................................................#

	my ($tssCluster_bed_path) = @_;

	my $clusterInfoHsh_ref = {};
	
	if ($tssCluster_bed_path =~ m/\.gz$/) {
		open (PROMOTERBED, " gzip -dc $tssCluster_bed_path|");
	} else {
		open (PROMOTERBED, "<", $tssCluster_bed_path);
	}
	
	while (<PROMOTERBED>) {
		chomp;

		my ($chrom, $start, $end, $clusterID, $score, $strand, $thickStart, $thickEnd) = split /\t/;
		
		#if ($strand ne '+' and $strand ne '-') {
		#	die "skip $clusterID: ambigous strand\n";
		#}
		
		if (not defined $thickStart or not defined $thickEnd) {
			my $mid_pt = int($start+($end-$start)/2);
			$thickEnd = $mid_pt;
			$thickStart = $mid_pt-1;
		}

		$clusterInfoHsh_ref->{$clusterID}{'strand'} = $strand;
		$clusterInfoHsh_ref->{$clusterID}{'chrom'} = $chrom;
		$clusterInfoHsh_ref->{$clusterID}{'start'} = $start;
		$clusterInfoHsh_ref->{$clusterID}{'end'} = $end;
		$clusterInfoHsh_ref->{$clusterID}{'type'} = 'unanno_tss';
		$clusterInfoHsh_ref->{$clusterID}{'peakPos'} = $thickEnd;
		$clusterInfoHsh_ref->{$clusterID}{'score'} = $score;
		$clusterInfoHsh_ref->{$clusterID}{'filter'} = 'no';

		my $chromStart = $start;
		my $chromEnd = $end;
		my $blockSizes = $chromEnd - $chromStart;
		my $blockCount = 1;
		my $blockStarts = 0;
		
		$clusterInfoHsh_ref->{$clusterID}{'bedLine'} = [$chrom, $chromStart, $chromEnd, $clusterID, $score, $strand, $thickStart, $thickEnd, ".", $blockCount, $blockSizes, $blockStarts];

	}
	close TRANSCRIPTBED;
	
	my $num_clusters = keys %{$clusterInfoHsh_ref};
	&reportAndLogStatus("$num_clusters clusters read", 10, "\n");#->2953

	return ($clusterInfoHsh_ref);

}
sub readClusterInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $clusterInfoHsh_ref, $tssCluster_info_path
#	output: 
#	toCall: &readClusterInfo($tssCluster_info_path, $clusterInfoHsh_ref);
#	calledInLine: 227
#....................................................................................................................................................#

	my ($tssCluster_info_path, $clusterInfoHsh_ref) = @_;

	&reportAndLogStatus("Reading tssCluster info", 10, "\n");#->2953

	if ($tssCluster_info_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $tssCluster_info_path|");
	} else {
		open (FILEIN, "<", $tssCluster_info_path);
	}

	chomp(my $header = <FILEIN>);
	my @headerSplt = split /\t/, $header;
	my %colIndexHsh = ();

	foreach my $headerItem (qw/prob summit max count/) {
		$colIndexHsh{$headerItem} = undef;
		foreach my $i (0..$#headerSplt) {
			$colIndexHsh{$headerItem} = $i if $headerItem eq $headerSplt[$i];
		}
		die if not defined $colIndexHsh{$headerItem};
	}

	while (<FILEIN>) {
		next if $_ =~ m/^#/;
		chomp;
		my @splt = split /\t/;
		my $clusterID = $splt[0];
		my $prob = $splt[$colIndexHsh{'prob'}];
		my $summit = $splt[$colIndexHsh{'summit'}];
		my $max = $splt[$colIndexHsh{'max'}];
		my $count = $splt[$colIndexHsh{'count'}];
		if (exists $clusterInfoHsh_ref->{$clusterID}) {
			$clusterInfoHsh_ref->{$clusterID}{'prob'} = $prob;
			$clusterInfoHsh_ref->{$clusterID}{'max'} = $max;
			$clusterInfoHsh_ref->{$clusterID}{'summit'} = $summit;
			$clusterInfoHsh_ref->{$clusterID}{'count'} = $count;
		}
	}
	close FILEIN;

	foreach my $clusterID (keys %{$clusterInfoHsh_ref}) {
		if (not exists $clusterInfoHsh_ref->{$clusterID}{'prob'}) {
			$clusterInfoHsh_ref->{$clusterID}{'prob'} = 1;
		}
	}
	
	return ();
}
sub readGeneInfo {
#....................................................................................................................................................#
#	subroutineCategory: getTextInfo
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref, $gene_info_path
#	output: 
#	toCall: &readGeneInfo($gene_info_path, $geneInfoHsh_ref);
#	calledInLine: 223
#....................................................................................................................................................#

	my ($gene_info_path, $geneInfoHsh_ref) = @_;

	&reportAndLogStatus("Reading gene info", 10, "\n");#->2953

	if ($gene_info_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $gene_info_path|");
	} else {
		open (FILEIN, "<", $gene_info_path);
	}

	chomp(my $header = <FILEIN>);

	my %geneNameHsh = ();
	my @headerSplt = split /\t/, $header;
	my %colIndexHsh = ();
	
	foreach my $headerItem (qw/geneID geneName geneClass/) {
		$colIndexHsh{$headerItem} = undef;
		foreach my $i (0..$#headerSplt) {
			$colIndexHsh{$headerItem} = $i if $headerItem eq $headerSplt[$i];
		}
		
		if (not defined $colIndexHsh{$headerItem} and $headerItem eq 'geneClass') {
			foreach my $i (0..$#headerSplt) {
				$colIndexHsh{$headerItem} = $i if $headerSplt[$i] eq 'geneType';
			}
		}
		
		die if not defined $colIndexHsh{$headerItem};
	}

	while (<FILEIN>) {
		next if $_ =~ m/^#/;
		chomp;
		my @splt = split /\t/;
		my $geneID = $splt[$colIndexHsh{'geneID'}];
		my $geneName = $splt[$colIndexHsh{'geneName'}];
		my $geneClass = $splt[$colIndexHsh{'geneClass'}];
		
		if (exists $geneInfoHsh_ref->{$geneID}) {

			#---[2020/05/14 23:41] to make sure the genes are unique
			if (exists $geneNameHsh{$geneName}) {
				$geneNameHsh{$geneName}++;
				$geneName = $geneName.".".$geneNameHsh{$geneName};
			}
		
			$geneInfoHsh_ref->{$geneID}{'geneName'} = $geneName;
			$geneInfoHsh_ref->{$geneID}{'geneClass'} = $geneClass;
			$geneNameHsh{$geneName}++;
		}
	}
	close FILEIN;
	
	my $num_gene = keys %{$geneInfoHsh_ref};
	&reportAndLogStatus("$num_gene genes reads", 10, "\n");#->2953
	
	return ();
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|165
#	secondaryAppearInSection: >none
#	input: none
#	output: $CRE_extend_size, $CRE_extend_upstrm_ratio, $Rscript_bin, $addon_length, $dn_end5Rng, $exon_slop_rng, $genome, $merge_dist, $merge_strandness, $min_gene_strand_read_frac, $min_spreadness, $min_total_exp_frac, $outDir, $outputPrefix, $overwrite, $proximal_strandness, $proximity_slop_rng, $stitch_distance, $tssCluster_bed_path, $tssCluster_info_path, $up_end5Rng
#	toCall: my ($exon_slop_rng, $addon_length, $merge_dist, $up_end5Rng, $dn_end5Rng, $tssCluster_bed_path, $tssCluster_info_path, $merge_strandness, $proximity_slop_rng, $CRE_extend_size, $CRE_extend_upstrm_ratio, $genome, $proximal_strandness, $stitch_distance, $min_total_exp_frac, $min_gene_strand_read_frac, $min_spreadness, $Rscript_bin, $outputPrefix, $outDir, $overwrite) = &readParameters();
#	calledInLine: 168
#....................................................................................................................................................#
	
	my ($exon_slop_rng, $addon_length, $merge_dist, $up_end5Rng, $dn_end5Rng, $tssCluster_bed_path, $tssCluster_info_path, $merge_strandness, $proximity_slop_rng, $CRE_extend_size, $CRE_extend_upstrm_ratio, $genome, $proximal_strandness, $stitch_distance, $min_total_exp_frac, $min_gene_strand_read_frac, $min_spreadness, $Rscript_bin, $outputPrefix, $outDir, $overwrite);
	
	$up_end5Rng = 500;
	$dn_end5Rng = 500;
	$merge_dist = 500;
	$addon_length = 500;
	$proximity_slop_rng = 500;
	$min_total_exp_frac = 0.1;
	$min_gene_strand_read_frac = 0.8;
	$min_spreadness = 4;
	$CRE_extend_size = 500;
	$exon_slop_rng = -1;
	$CRE_extend_upstrm_ratio = 4;
	$stitch_distance = 'undefined';
	$merge_strandness = 'strandless';
	$proximal_strandness = 'stranded';
	$Rscript_bin = 'Rscript';
	$overwrite = 'no';

	GetOptions 	(
		"tssCluster_bed_path=s"			=>	\$tssCluster_bed_path,
		"tssCluster_info_path=s"		=>	\$tssCluster_info_path,
		"genome=s"							=>	\$genome,
		"up_end5Rng:i"						=>	\$up_end5Rng,
		"dn_end5Rng:i"						=>	\$dn_end5Rng,
		"merge_dist:i"						=>	\$merge_dist,
		"addon_length:i"					=>	\$addon_length,
		"exon_slop_rng:i"					=>	\$exon_slop_rng,
		"proximity_slop_rng:i"			=>	\$proximity_slop_rng,
		"merge_strandness:s"				=>	\$merge_strandness,
		"proximal_strandness:s"			=>	\$proximal_strandness,
		"CRE_extend_size:i"				=>	\$CRE_extend_size,
		"CRE_extend_upstrm_ratio:f"	=>	\$CRE_extend_upstrm_ratio,
		"stitch_distance:s"				=>	\$stitch_distance,
		"min_total_exp_frac:f"			=>	\$min_total_exp_frac,
		"min_gene_strand_read_frac:f"	=>	\$min_gene_strand_read_frac,
		"min_spreadness:f"				=>	\$min_spreadness,
		"Rscript_bin=s"					=>	\$Rscript_bin,
		"outputPrefix=s"					=>	\$outputPrefix,
		"outDir=s"							=>	\$outDir,
		"overwrite:s"						=>	\$overwrite,
		'help'								=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $tssCluster_bed_path;
	
	#---check file
	my $file_check_hsh_ref = {
		'tssCluster_bed_path' => $tssCluster_bed_path,
		'tssCluster_info_path' => $tssCluster_info_path,
	};
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}
	
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
	
	return($exon_slop_rng, $addon_length, $merge_dist, $up_end5Rng, $dn_end5Rng, $tssCluster_bed_path, $tssCluster_info_path, $merge_strandness, $proximity_slop_rng, $CRE_extend_size, $CRE_extend_upstrm_ratio, $genome, $proximal_strandness, $stitch_distance, $min_total_exp_frac, $min_gene_strand_read_frac, $min_spreadness, $Rscript_bin, $outputPrefix, $outDir, $overwrite);
}
sub readTranscriptBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $chrom_size_hsh_ref, $outDir, $tmp_bed_dir, $transcript_bed_path
#	output: $transcript_in_scope_bed_path, $trnscptInfoHsh_ref
#	toCall: my ($trnscptInfoHsh_ref, $transcript_in_scope_bed_path) = &readTranscriptBed($transcript_bed_path, $chrom_size_hsh_ref, $tmp_bed_dir, $outDir);
#	calledInLine: 221
#....................................................................................................................................................#

	my ($transcript_bed_path, $chrom_size_hsh_ref, $tmp_bed_dir, $outDir) = @_;

	my $trnscptInfoHsh_ref = {};
	my $transcript_in_scope_bed_path = "$tmp_bed_dir/transcript_in_scope.bed";
	open TRNSCPTSCOPE, ">", $transcript_in_scope_bed_path;

	&reportAndLogStatus("Reading transcript bed", 10, "\n");#->2953
	
	open (TRANSCRIPTBED, "gzip -dc $transcript_bed_path |");
	while (<TRANSCRIPTBED>) {
		chomp;

		my ($chrom, $start, $end, $trnscptIDStr, $score, $strand, $thickStart, $thickEnd, $rgbItem, $blkCount, $blkSizes, $blkStarts) = split /\t/;
		
		if (not exists $chrom_size_hsh_ref->{$chrom}) {
			#&reportAndLogStatus("trnscpt $trnscptIDStr will be skipped as it is on chrom $chrom that is outside the defined chromSize file", 10, "\n");#->2953
			next;
		}
		print TRNSCPTSCOPE $_."\n";
		
		if ($strand ne '+' and $strand ne '-') {
			die "skip $trnscptIDStr: ambigous strand\n";
		}

		my $trnscptStart = $start+1;
		my $trnscptEnd = $end;
		my @trnscptIDStrAry = split /\|/, $trnscptIDStr;
		my $trnscptID = $trnscptIDStrAry[-1];
		
		$trnscptInfoHsh_ref->{$trnscptID}{'strand'} = $strand;
		$trnscptInfoHsh_ref->{$trnscptID}{'chrom'} = $chrom;
		
		if ($trnscptInfoHsh_ref->{$trnscptID}{'strand'} eq '+') {
			$trnscptInfoHsh_ref->{$trnscptID}{'end5Pos'} = $trnscptStart;
		} elsif ($trnscptInfoHsh_ref->{$trnscptID}{'strand'} eq '-') {
			$trnscptInfoHsh_ref->{$trnscptID}{'end5Pos'} = $trnscptEnd;
		} else {
			die "trnscptID $trnscptID has amibigous strand\n";
		}

		$trnscptInfoHsh_ref->{$trnscptID}{'exonNum'} = $blkCount;
		$trnscptInfoHsh_ref->{$trnscptID}{'exonLen'} = sum(split /,/, $blkSizes);
		@{$trnscptInfoHsh_ref->{$trnscptID}{'trnscptRng'}} = ($trnscptStart, $trnscptEnd);
		$trnscptInfoHsh_ref->{$trnscptID}{'bedLine'} = [$chrom, $start, $end, $trnscptID, $score, $strand, $thickStart, $thickEnd, $rgbItem, $blkCount, $blkSizes, $blkStarts];

		#---[5/26/14 18:26] get the exon ranges
		if ($blkCount > 1) {
			my @blkStartsSplt = split /,/, $blkStarts;
			my @blkSizesSplt = split /,/, $blkSizes;

			for my $i (0..$blkCount-1) {
				my $exonStart = $trnscptStart + $blkStartsSplt[$i];
				my $exonEnd = $exonStart + $blkSizesSplt[$i] - 1;
				push @{$trnscptInfoHsh_ref->{$trnscptID}{'exonRng'}}, ($exonStart, $exonEnd);
			}

		} else {
			@{$trnscptInfoHsh_ref->{$trnscptID}{'exonRng'}} = ($trnscptStart, $trnscptEnd);
		}
	}
	close TRANSCRIPTBED;
	close TRNSCPTSCOPE;
	
	return ($trnscptInfoHsh_ref, $transcript_in_scope_bed_path);

}
sub readTranscriptInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $transcript_info_path, $trnscptInfoHsh_ref
#	output: $geneInfoHsh_ref
#	toCall: my ($geneInfoHsh_ref) = &readTranscriptInfo($transcript_info_path, $trnscptInfoHsh_ref);
#	calledInLine: 222
#....................................................................................................................................................#

	my ($transcript_info_path, $trnscptInfoHsh_ref) = @_;

	&reportAndLogStatus("Reading transcript info", 10, "\n");#->2953
	my $geneInfoHsh_ref = {};

	if ($transcript_info_path =~ m/\.gz$/) {
		open (FILEIN, " gzip -dc $transcript_info_path|");
	} else {
		open (FILEIN, "<", $transcript_info_path);
	}

	chomp(my $header = <FILEIN>);
	my @headerSplt = split /\t/, $header;
	my %colIndexHsh = ();
	
	foreach my $headerItem (qw/geneID trnscptID/) {
		$colIndexHsh{$headerItem} = undef;
		foreach my $i (0..$#headerSplt) {
			$colIndexHsh{$headerItem} = $i if $headerItem eq $headerSplt[$i];
		}

		if (not defined $colIndexHsh{$headerItem} and $headerItem eq 'trnscptID') {
			foreach my $i (0..$#headerSplt) {
				$colIndexHsh{$headerItem} = $i if $headerSplt[$i] eq 'transcriptID';
			}
		}
		
		
		die if not defined $colIndexHsh{$headerItem};
	}

	while (<FILEIN>) {
		next if $_ =~ m/^#/;
		chomp;
		my @splt = split /\t/;
		my $geneID = $splt[$colIndexHsh{'geneID'}];
		my $trnscptID = $splt[$colIndexHsh{'trnscptID'}];
		if (exists $trnscptInfoHsh_ref->{$trnscptID}) {
			$trnscptInfoHsh_ref->{$trnscptID}{'geneID'} = $geneID;
			$geneInfoHsh_ref->{$geneID}{'trnscptID'}{$trnscptID}++;
		}
	}
	close FILEIN;

	my $num_transcript = keys %{$trnscptInfoHsh_ref};
	&reportAndLogStatus("$num_transcript transcripts reads", 10, "\n");#->2953
	
	return ($geneInfoHsh_ref);
}
sub removeTmpBedDir {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $tmp_bed_dir
#	output: none
#	toCall: &removeTmpBedDir($tmp_bed_dir);
#	calledInLine: 253
#....................................................................................................................................................#
	
	my ($tmp_bed_dir) = @_;
	
	&reportAndLogStatus("removing tmp_bed_dir", 10, "\n");#->2953
	system ("rm -rf $tmp_bed_dir");

}
sub removeUnsupportedGene {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref, $trnscptInfoHsh_ref
#	output: none
#	toCall: &removeUnsupportedGene($geneInfoHsh_ref, $trnscptInfoHsh_ref);
#	calledInLine: 240
#....................................................................................................................................................#
	
	my ($geneInfoHsh_ref, $trnscptInfoHsh_ref) = @_;
	
	my %itemHsh = (
		'gene' => $geneInfoHsh_ref,
		'transcript' => $trnscptInfoHsh_ref,
	);
	
	foreach my $item_type (keys %itemHsh) {
		&reportAndLogStatus("removing $item_type with no 5'end support", 10, "\n");#->2953
		my $hsh_ref = $itemHsh{$item_type};
		my $remove_num = 0;
		foreach my $itemID (keys %{$hsh_ref}) {
			if (not exists $hsh_ref->{$itemID}{'clusterID'}) {
				delete $hsh_ref->{$itemID};
				$remove_num++;
			};
		}
		
		&reportAndLogStatus("$remove_num $item_type removed", 10, "\n");#->2953
		
	};

	foreach my $geneID (keys %{$geneInfoHsh_ref}) {
		foreach my $trnscptID (keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}}) {
			delete $geneInfoHsh_ref->{$geneID}{'trnscptID'}{$trnscptID} if not exists $trnscptInfoHsh_ref->{$trnscptID};
		}
	}
	
}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|695
#	appearInSub: addonTranscript|348, assignClusterProximity|445, checkAllExecutable|553, checkRScriptVersion|633, defineCRE|713, defineHyperactiveDistalLoci|861, defineUnannoPromoter|1002, filterUnannotatedCluster|1119, generateExtendedCluster|1198, getSuperCluster|1291, intersectCluster|1346, printAllBed|1432, printEnd5Bed|1514, printGenePromoterInfo|1595, printTableCREInfo|1794, printTableClusterInfo|1930, printTableDistalCRELocusInfo|2045, printTableGeneInfo|2099, printTableIDMappingInfo|2161, printTableTranscriptInfo|2221, readClusterBed|2479, readClusterInfo|2543, readGeneInfo|2604, readTranscriptBed|2751, readTranscriptInfo|2830, removeTmpBedDir|2892, removeUnsupportedGene|2911, summerizeGeneInfo|3103
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|193, 3_readInfo|217
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 364, 459, 479, 529, 538, 574, 579, 588, 597, 606, 615, 624, 652, 658, 729, 759, 876, 902, 905, 907, 910, 956, 959, 997, 1015, 1090, 1132, 1145, 1212, 1308, 1339, 1362, 1370, 1462, 1528, 1613, 1812, 1919, 1924, 1948, 2034, 2039, 2063, 2113, 2175, 2181, 2239, 2537, 2557, 2618, 2671, 2769, 2778, 2844, 2887, 2906, 2931, 2941, 3117
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->695
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->695
	
	return ();
}
sub storeCREInfoFromBed {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: defineCRE|713
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 3_readInfo|217
#	input: $CREInfoHsh_ref, $clusterInfoHsh_ref, $proximity, $tmp_merged_CRE_bed
#	output: 
#	toCall: &storeCREInfoFromBed($tmp_merged_CRE_bed, $proximity, $CREInfoHsh_ref, $clusterInfoHsh_ref);
#	calledInLine: 755, 781
#....................................................................................................................................................#
	my ($tmp_merged_CRE_bed, $proximity, $CREInfoHsh_ref, $clusterInfoHsh_ref) = @_;

	open MERGECREBED, "<", "$tmp_merged_CRE_bed";
	while (<MERGECREBED>) {
		chomp;
		my ($chrom, $chromStart, $chromEnd, $clusterIDStr, $score, $strandStr) = split /\t/;
		my $strand = $strandStr;
		$strand = '.' if $strandStr =~ m/\;/;
		my $CREID = "$chrom\_$chromStart\_$chromEnd\_$strand";
		my $max_clusterID = undef;
		my $max_count = 0;
		
		foreach my $clusterID (split /;/, $clusterIDStr) {
			my $max = $clusterInfoHsh_ref->{$clusterID}{'max'};
			if ($max > $max_count) {
				$max_clusterID = $clusterID; 
				$max_count = $max;
			}

			$CREInfoHsh_ref->{$CREID}{'clusterID'}{$clusterID}++;
			$clusterInfoHsh_ref->{$clusterID}{'CREID'} = $CREID;
		}
		$CREInfoHsh_ref->{$CREID}{'strand'} = $strand;
		$CREInfoHsh_ref->{$CREID}{'chrom'} = $chrom;
		$CREInfoHsh_ref->{$CREID}{'start'} = $chromStart;
		$CREInfoHsh_ref->{$CREID}{'end'} = $chromEnd;
		$CREInfoHsh_ref->{$CREID}{'score'} = $score;
		$CREInfoHsh_ref->{$CREID}{'proximity'} = $proximity;

		$CREInfoHsh_ref->{$CREID}{'regionType'} = $clusterInfoHsh_ref->{$max_clusterID}{'regionType'};
		$CREInfoHsh_ref->{$CREID}{'regionGeneID'} = $clusterInfoHsh_ref->{$max_clusterID}{'regionGeneID'};
		$CREInfoHsh_ref->{$CREID}{'regionOritentation'} = $clusterInfoHsh_ref->{$max_clusterID}{'regionOritentation'};

	}
	close MERGECREBED;

	return ();
}
sub summerizeCREInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $CREInfoHsh_ref, $clusterInfoHsh_ref, $geneInfoHsh_ref
#	output: 
#	toCall: &summerizeCREInfo($clusterInfoHsh_ref, $CREInfoHsh_ref, $geneInfoHsh_ref);
#	calledInLine: 238
#....................................................................................................................................................#
	my ($clusterInfoHsh_ref, $CREInfoHsh_ref, $geneInfoHsh_ref) = @_;
	
	foreach my $CREID (keys %{$CREInfoHsh_ref}) {
		my @CRENameAry = ();
		my $mask = 'no';
		my $max = 0;
		my $peakPos;
		my $sumClusterRead = 0;
		my $stranded_count_hsh_ref = {
			'+' => 0,
			'-' => 0,
		};
		foreach my $clusterID (keys %{$CREInfoHsh_ref->{$CREID}{'clusterID'}}) {
			foreach my $geneID (keys %{$clusterInfoHsh_ref->{$clusterID}{'geneID'}}) {
				$CREInfoHsh_ref->{$CREID}{'geneID'}{$geneID}++;
				$geneInfoHsh_ref->{$geneID}{'CREID'}{$CREID}++;
			}

			my $count = $clusterInfoHsh_ref->{$clusterID}{'count'};
			my $strand = $clusterInfoHsh_ref->{$clusterID}{'strand'};
			$stranded_count_hsh_ref->{$strand}+=$count; 
			$sumClusterRead+=$count;
			
			foreach my $promoter_name (split /\,/, $clusterInfoHsh_ref->{$clusterID}{'clusterName'}) {
				push @CRENameAry, $promoter_name;
			}
			if ($clusterInfoHsh_ref->{$clusterID}{'max'} > $max) {
				$max = $clusterInfoHsh_ref->{$clusterID}{'max'};
				$peakPos = $clusterInfoHsh_ref->{$clusterID}{'peakPos'};
			}
			$mask = 'yes' if $clusterInfoHsh_ref->{$clusterID}{'mask'} eq 'yes';
		}
		my $chrom = $CREInfoHsh_ref->{$CREID}{'chrom'};
		my $start = $CREInfoHsh_ref->{$CREID}{'start'};
		my $end = $CREInfoHsh_ref->{$CREID}{'end'};
		my $score = $CREInfoHsh_ref->{$CREID}{'score'};
		my $strand = $CREInfoHsh_ref->{$CREID}{'strand'};

		my $chromStart = $start;
		my $chromEnd = $end;
		my $blockSizes = $chromEnd - $chromStart;
		my $blockCount = 1;
		my $blockStarts = 0;
		my $thickEnd = $peakPos;
		my $thickStart = $thickEnd - 1;

		$CREInfoHsh_ref->{$CREID}{'plusClusterRead'} = $stranded_count_hsh_ref->{'+'};
		$CREInfoHsh_ref->{$CREID}{'minusClusterRead'} = $stranded_count_hsh_ref->{'-'};
		$CREInfoHsh_ref->{$CREID}{'sumClusterRead'} = $sumClusterRead;
		$CREInfoHsh_ref->{$CREID}{'mask'} = $mask;
		$CREInfoHsh_ref->{$CREID}{'peakPos'} = $peakPos;
		if ($CREInfoHsh_ref->{$CREID}{'proximity'} eq 'proximal') {
			$CREInfoHsh_ref->{$CREID}{'rgbItem'} = '106,61,154';

		} elsif ($CREInfoHsh_ref->{$CREID}{'proximity'} eq 'distal') {
			$CREInfoHsh_ref->{$CREID}{'rgbItem'} = '255,127,0';
		
		} else {
			die;
		}

		$CREInfoHsh_ref->{$CREID}{'bedLine'} = [$chrom, $chromStart, $chromEnd, $CREID, $sumClusterRead, $strand, $thickStart, $thickEnd, ".", $blockCount, $blockSizes, $blockStarts];
	}

	return ();
}
sub summerizeGeneInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|2953
#	appearInSub: >none
#	primaryAppearInSection: 3_readInfo|217
#	secondaryAppearInSection: >none
#	input: $geneInfoHsh_ref, $trnscptInfoHsh_ref
#	output: none
#	toCall: &summerizeGeneInfo($geneInfoHsh_ref, $trnscptInfoHsh_ref);
#	calledInLine: 233
#....................................................................................................................................................#

	my ($geneInfoHsh_ref, $trnscptInfoHsh_ref) = @_;
	
	&reportAndLogStatus("summerizing gene information", 10, "\n");#->2953
	
	foreach my $geneID (keys %{$geneInfoHsh_ref}) {
		my @tmpRngAry = ();
		my %strandHsh = ();
		my %chromHsh = ();
		foreach my $trnscptID (keys %{$geneInfoHsh_ref->{$geneID}{'trnscptID'}}) {
			$strandHsh{$trnscptInfoHsh_ref->{$trnscptID}{'strand'}}++;
			$chromHsh{$trnscptInfoHsh_ref->{$trnscptID}{'chrom'}}++;
			push @tmpRngAry, @{$trnscptInfoHsh_ref->{$trnscptID}{'exonRng'}};
		}
		
		my @chromAry = keys %chromHsh;
		die "chrom error\n" if @chromAry != 1;
		my $chrom = shift(@chromAry);
		
		@tmpRngAry = sort {$a <=> $b} @tmpRngAry;
		my $geneStart = $tmpRngAry[0];
		my $geneEnd = $tmpRngAry[-1];
		my $strand = '.';
		
		if (exists $strandHsh{'+'} and not exists $strandHsh{'-'}) {
			$strand = '+';
		} elsif (not exists $strandHsh{'+'} and exists $strandHsh{'-'}) {
			$strand = '-';
		}
		
		$geneInfoHsh_ref->{$geneID}{'chrom'} = $chrom;
		$geneInfoHsh_ref->{$geneID}{'strand'} = $strand;
		$geneInfoHsh_ref->{$geneID}{'geneRng'} = [$geneStart, $geneEnd];

		my $chromStart = $geneStart;
		my $chromEnd = $geneEnd;
		my $thickStart = $chromStart;
		my $thickEnd = $chromEnd;
		my $blockSizes = $chromEnd - $chromStart;
		my $blockCount = 1;
		my $blockStarts = 0;
	
		$geneInfoHsh_ref->{$geneID}{'bedLine'} = [$chrom, $chromStart, $chromEnd, $geneID, '0', $strand, $thickStart, $thickEnd, ".", $blockCount, $blockSizes, $blockStarts];
		
	}
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 153
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































