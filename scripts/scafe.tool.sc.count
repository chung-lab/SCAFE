#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


#====================================================================================================================================================#
#<use>
$|++; #---turn on the auto flush for the progress bar
no warnings 'utf8';
use warnings;
use strict;
use File::Path;
use File::Copy;
use File::Basename;
use File::Spec::Functions qw(rel2abs abs2rel);
use Time::HiRes qw( time );
use Getopt::Long 'HelpMessage';
use List::Util qw (sum shuffle min max);
use Cwd 'abs_path';
#<\use>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<doc>
=head1 SYNOPSIS

           5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~AAA-3'
                        O~~~AA      O~~         O~       O~~~~~~~AO~~~~~~~~A
                      O~~    O~~ O~~   O~~     O~O~~     O~~      O~~       
                       O~~      O~~           O~  O~~    O~~      O~~       
                         O~~    O~~          O~~   O~~   O~~~~~AA O~~~~~~A  
                            O~~ O~~         O~~~~~A O~~  O~~      O~~       
                      O~~    O~~ O~~   O~~ O~~       O~~ O~~      O~~       
                        O~~~~A     O~~~   O~~         O~~O~~      O~~~~~~~AA
       ┌─ᐅ 5'-O~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-3'
 ...===┴========================================================================================...

                      Single Cell Analysis of Five-prime End (SCAFE) Tool Suite 
                                  ---> scafe.tool.sc.count <---
                     <--- tool, single-cell mode, count of UMI within tCRE --->

 Description:
   This tool counts the UMI within a set of user-defined regions, e.g. tCRE, and returns a UMI/cellbarcode matrix

 Usage:
   scafe.tool.sc.count [options] --countRegion_bed_path --cellBarcode_list_path --ctss_bed_path --outputPrefix --outDir
   
   --countRegion_bed_path   <required> [string] bed file contains the regions for counting CTSS, e.g. tCRE ranges, 
                                                *.CRE.coord.bed.gz from scafe.tool.cm.annotate.pl
   --cellBarcode_list_path  <required> [string] tsv file contains a list of cell barcodes,
                                                barcodes.tsv.gz from cellranger
   --ctss_bed_path          <required> [string] ctss file for counting,
                                                *CB.ctss.bed.gz from scafe.tool.sc.bam_to_ctss.pl, 
                                                4th column cellbarcode and 5th column is number UMI
   --genome                 <required> [string] name of genome reference, e.g. hg19.gencode_v32lift37
   --ctss_scope_bed_path    <optional> [string] bed file contains the regions for filtering CTSS, e.g. tssCluster ranges, 
                                                so only the ctss within these ranges (i.e. scope) will be count. This is to 
                                                prevent over permissive counting to ctss in the CRE range by stricting only 
                                                ctss within valid tssClusters to be counted. 
                                                *.tssCluster.default.filtered.bed.gz from scafe.tool.cm.filter.
                                                It will skip filtering if no file was provide (default=null).
   --ctss_scope_slop_bp    <optional> [integer] the length of the boundary extension (in bp) for filter region provided in
                                                option ctss_scope_bed_path. All regions in ctss_scope_bed_path will be 
                                                extended both side by ctss_scope_slop_bp, for controlling the permissiveness
                                                of the counting. A large value of ctss_scope_slop_bp (e.g. 400) will be 
                                                equivalent to no filtering (default=0).
   --outputPrefix           <required> [string] prefix for the output files
   --outDir                 <required> [string] directory for the output files
   --overwrite              (optional) [yes/no] erase outDir/outputPrefix before running (default=no)

 Dependencies:
   bedtools

 For demo, cd to SCAFE dir and run,
   scafe.tool.sc.count \
   --overwrite=yes \
   --genome=hg19.gencode_v32lift37 \
   --countRegion_bed_path=./demo/output/sc.solo/annotate/demo/bed/demo.CRE.annot.bed.gz \
   --cellBarcode_list_path=./demo/input/sc.solo/demo.barcodes.tsv.gz \
   --ctss_bed_path=./demo/output/sc.solo/bam_to_ctss/demo/bed/demo.CB.ctss.bed.gz \
   --outputPrefix=demo \
   --outDir=./demo/output/sc.solo/count/

=head1 VERSION

v0.9.0-beta [March 20, 2021]
	-Initial pre-release

v1.0.0 [June 6, 2022]
	-Implemented region filter, will only count the ctss within the region filter, used for counting tssCluster only instead of the whole CRE

v1.0.1 [June 26, 2022]
	-No update

=cut
#<\doc>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<lastCmdCalled>
#
#	notCalledBefore
#
#	notCalledBefore
#
#<\lastCmdCalled>
#====================================================================================================================================================#

#====================================================================================================================================================#
#<global>
my $scriptDirPath = dirname(rel2abs($0));
my $scriptAbsPath = abs_path($0);
my ($curntTimeStamp) = &timeStamp();#->831
my $ARGVStr = join "\n", (&currentTime(), $scriptAbsPath, @ARGV);#->325
my $globalReadmeHsh_ref = {};
our $tmplog_fh;
#<\global>
#====================================================================================================================================================#

#====================================================================================================================================================#
{	#Main sections lexical scope starts
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 0_startingTasks
#
#<section ID="startingTasks" num="0">
my ($countRegion_bed_path, $ctss_bed_path, $cellBarcode_list_path, $ctss_scope_bed_path, $ctss_scope_slop_bp, $genome, $outputPrefix, $outDir, $overwrite) = &readParameters();#->655
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 1_defineHardCodedParam
#
#<section ID="defineHardCodedParam" num="1">
my $paramTag = "$outputPrefix";
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 2_defineOutDirPath
#
#<section ID="defineOutDirPath" num="2">
my @mkDirAry;
my $result_dir = "$outDir/$paramTag/"; push @mkDirAry, $result_dir;
system "rm -rf $result_dir" if ($overwrite eq 'yes');
my $result_matrix_dir = "$result_dir/matrix/"; push @mkDirAry, $result_matrix_dir;
my $result_log_dir = "$result_dir/log/"; push @mkDirAry, $result_log_dir;
my $result_script_dir = "$result_dir/script/"; push @mkDirAry, $result_script_dir;
foreach my $dir (@mkDirAry) {system ("mkdir -pm 777 $dir");}
open $tmplog_fh, ">", "$result_dir/00_screen_log.$curntTimeStamp.log.txt";
&logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);#->343
&printStartOrFinishMessage("startMessage");#->539
my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();#->203
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 3_output
#
#<section ID="output" num="3">
my ($countRegion_info_hsh_ref) = &readCountRegionInfo($countRegion_bed_path);#->614
my ($cellBarcode_info_hsh_ref) = &readCellBarcodeList($cellBarcode_list_path);#->573
my ($chrom_size_path) = &checkChromSizePath($genome);#->303
my ($tmp_count_path) = &runBedToolsIntersect($countRegion_bed_path, $ctss_bed_path, $countRegion_info_hsh_ref, $cellBarcode_info_hsh_ref, $result_matrix_dir, $ctss_scope_bed_path, $ctss_scope_slop_bp, $chrom_size_path, $result_log_dir, $bedtools_bin);#->731
&printMatrix($countRegion_info_hsh_ref, $cellBarcode_info_hsh_ref, $tmp_count_path, $result_log_dir, $result_matrix_dir);#->368
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
#	section 4_finishingTasks
#
#<section ID="finishingTasks" num="4">
&printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);#->424
&printStartOrFinishMessage("finishMessage");#->539
#<\section>
#====================================================================================================================================================#

#====================================================================================================================================================#
}	#Main sections lexical scope ends
#====================================================================================================================================================#

#====================================================================================================================================================#
#List of subroutines by category
#
#	general [n=5]:
#		currentTime, logCalledCMDAndScript, printStartOrFinishMessage
#		readParameters, timeStamp
#
#	log [n=1]:
#		reportAndLogStatus
#
#	output [n=1]:
#		printOutputFileListAndReadme
#
#	range [n=1]:
#		runBedToolsIntersect
#
#	time [n=1]:
#		timeStamp
#
#	unassigned [n=5]:
#		checkAllExecutable, checkChromSizePath, printMatrix
#		readCellBarcodeList, readCountRegionInfo
#
#====================================================================================================================================================#

sub checkAllExecutable {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|709
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|134
#	secondaryAppearInSection: >none
#	input: none
#	output: $bedGraphToBigWig_bin, $bedtools_bin, $bgzip_bin, $bigWigAverageOverBed_bin, $cut_sh_path, $paraclu_bin, $samtools_bin, $tabix_bin
#	toCall: my ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin) = &checkAllExecutable();
#	calledInLine: 148
#....................................................................................................................................................#
	
	my $dirPath = dirname(rel2abs($0));

	my $tabix_bin = "$dirPath/../resources/bin/tabix/tabix";
	my $bgzip_bin = "$dirPath/../resources/bin/bgzip/bgzip";
	my $bedtools_bin = "$dirPath/../resources/bin/bedtools/bedtools";
	my $samtools_bin = "$dirPath/../resources/bin/samtools/samtools";
	my $paraclu_bin = "$dirPath/../resources/bin/paraclu/paraclu";
	my $cut_sh_path = "$dirPath/../resources/bin/paraclu/paraclu-cut.sh";
	my $bedGraphToBigWig_bin = "$dirPath/../resources/bin/bedGraphToBigWig/bedGraphToBigWig";
	my $bigWigAverageOverBed_bin = "$dirPath/../resources/bin/bigWigAverageOverBed/bigWigAverageOverBed";
	
	&reportAndLogStatus("Checking all SCAFE executables", 10, "\n");#->709
	
	{
		my $stdOut = `$tabix_bin  --version 2>&1`;
		if ($stdOut =~ m/tabix \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: tabix version: $1", 0, "\n");#->709
		} else {
			die "tabix is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bgzip_bin --version 2>&1`;
		if ($stdOut =~ m/bgzip \(htslib\) (\S+)/) {
			&reportAndLogStatus("Checking: bgzip version: $1", 0, "\n");#->709
		} else {
			die "bgzip is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedtools_bin --version 2>&1`;
		if ($stdOut =~ m/bedtools v(\S+)/) {
			&reportAndLogStatus("Checking: bedtools version: $1", 0, "\n");#->709
		} else {
			die "bedtools is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$samtools_bin 2>&1`;
		if ($stdOut =~ m/\s+(Version: \S+)\s+/) {
			&reportAndLogStatus("Checking: samtools version: $1", 0, "\n");#->709
		} else {
			die "samtools is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$paraclu_bin 2>&1`;
		if ($stdOut =~ m/paraclu: I need a minValue and a fileName/) {
			&reportAndLogStatus("Checking: paraclu found.", 0, "\n");#->709
		} else {
			die "paraclu is not installed properly. Quitting.\n";
		}
	}
	
	{
		my $stdOut = `$cut_sh_path 55C7128A 2>&1`;
		if ($stdOut =~ m/awk:/) {
			&reportAndLogStatus("Checking: paraclu-cut found.", 0, "\n");#->709
		} else {
			die "paraclu-cut is not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bedGraphToBigWig_bin 2>&1`;
		if ($stdOut =~ m/bedGraphToBigWig v (\S+)/) {
			&reportAndLogStatus("Checking: bedGraphToBigWig version: $1", 0, "\n");#->709
		} else {
			die "bedGraphToBigWig not installed properly. Quitting.\n";
		}
	}

	{
		my $stdOut = `$bigWigAverageOverBed_bin 2>&1`;
		if ($stdOut =~ m/bigWigAverageOverBed v(\S+)/) {
			&reportAndLogStatus("Checking: bigWigAverageOverBed version: $1", 0, "\n");#->709
		} else {
			die "bigWigAverageOverBed is not installed properly. Quitting.\n";
		}
	}

	return ($tabix_bin, $bgzip_bin, $bedtools_bin, $samtools_bin, $paraclu_bin, $cut_sh_path, $bedGraphToBigWig_bin, $bigWigAverageOverBed_bin);
}
sub checkChromSizePath {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 3_output|153
#	secondaryAppearInSection: >none
#	input: $genome
#	output: $chrom_size_path
#	toCall: my ($chrom_size_path) = &checkChromSizePath($genome);
#	calledInLine: 158
#....................................................................................................................................................#
	my ($genome) = @_;

	#$chrom_size_path, $gene_info_path, $transcript_bed_path, $transcript_info_path,

	my $dirPath = dirname(rel2abs($0));
	my $chrom_size_path = "$dirPath/../resources/genome/$genome/tsv/chrom.sizes.tsv";
	die "genome $genome does not have chrom_size_path. Please rerun prep_genome step\n" if not -s $chrom_size_path;

	return ($chrom_size_path);
}
sub currentTime {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: printStartOrFinishMessage|539, reportAndLogStatus|709
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|134, 4_finishingTasks|165
#	input: none
#	output: $runTime
#	toCall: my ($runTime) = &currentTime();
#	calledInLine: 107, 555, 559, 564, 568, 725, 726
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $runTime = sprintf "%04d-%02d-%02d %02d:%02d", $year+1900, $mon+1,$mday,$hour,$min;	
	
	return $runTime;
}
sub logCalledCMDAndScript {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|134
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $result_script_dir, $scriptAbsPath
#	output: 
#	toCall: &logCalledCMDAndScript($ARGVStr, $result_script_dir, $scriptAbsPath);
#	calledInLine: 146
#....................................................................................................................................................#
	my ($ARGVStr, $result_script_dir, $scriptAbsPath) = @_;


	my $cpScriptPath = "$result_script_dir/script.ran.pl";
	my $calledCMDPath = "$result_script_dir/called.cmd.txt";
	system "cp -f $scriptAbsPath $cpScriptPath";
	system "chmod 0444 $cpScriptPath"; #---[07/03/2014 18:02] make it read-only to make sure there'll be accodental change of parameters
	open CALLEDCMD, ">", $calledCMDPath;
	print CALLEDCMD join "", ($ARGVStr), "\n";
	close CALLEDCMD;
	
	return ();
}
sub printMatrix {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|709
#	appearInSub: >none
#	primaryAppearInSection: 3_output|153
#	secondaryAppearInSection: >none
#	input: $cellBarcode_info_hsh_ref, $countRegion_info_hsh_ref, $result_log_dir, $result_matrix_dir, $tmp_count_path
#	output: 
#	toCall: &printMatrix($countRegion_info_hsh_ref, $cellBarcode_info_hsh_ref, $tmp_count_path, $result_log_dir, $result_matrix_dir);
#	calledInLine: 160
#....................................................................................................................................................#
	my ($countRegion_info_hsh_ref, $cellBarcode_info_hsh_ref, $tmp_count_path, $result_log_dir, $result_matrix_dir) = @_;
	
	&reportAndLogStatus("printing matrix", 0, "\n");#->709
	
	open (CAGECLUSTERLOG, ">", "$result_log_dir/genes.log.tsv");
	print CAGECLUSTERLOG join "", ((join "\t", ('countRegion_ID', 'countRegion_name', 'umi_count')), "\n");
	open (CAGECLUSTERMTX, ">", "$result_matrix_dir/genes.tsv");
	foreach my $countRegion_ID (sort {$countRegion_info_hsh_ref->{$a}{'countRegion_index'} <=> $countRegion_info_hsh_ref->{$b}{'countRegion_index'}} keys %{$countRegion_info_hsh_ref})	{
		my $umi_count = $countRegion_info_hsh_ref->{$countRegion_ID}{'umi_count'};
		my $countRegion_name = $countRegion_info_hsh_ref->{$countRegion_ID}{'countRegion_name'};
		print CAGECLUSTERMTX join "", ((join "\t", ($countRegion_ID, $countRegion_name)), "\n");
		print CAGECLUSTERLOG join "", ((join "\t", ($countRegion_ID, $countRegion_name, $umi_count)), "\n");
	}
	close CAGECLUSTERMTX;
	close CAGECLUSTERLOG;

	open (CELLBARCODELOG, ">", "$result_log_dir/barcodes.log.tsv");
	print CELLBARCODELOG join "", ((join "\t", ('cellBarcode', 'umi_count')), "\n");
	open (CELLBARCODEMTX, ">", "$result_matrix_dir/barcodes.tsv");
	foreach my $cellBarcode (sort {$cellBarcode_info_hsh_ref->{$a}{'cellBarcode_index'} <=> $cellBarcode_info_hsh_ref->{$b}{'cellBarcode_index'}} keys %{$cellBarcode_info_hsh_ref})	{
		my $umi_count = $cellBarcode_info_hsh_ref->{$cellBarcode}{'umi_count'};
		print CELLBARCODEMTX join "", ((join "\t", ($cellBarcode)), "\n");
		print CELLBARCODELOG join "", ((join "\t", ($cellBarcode, $umi_count)), "\n");
	}
	close CELLBARCODEMTX;
	close CELLBARCODELOG;

	chomp (my $num_line = `wc -l < $tmp_count_path`);
	my $num_barcodes = keys %{$cellBarcode_info_hsh_ref};
	my $num_countRegion = keys %{$countRegion_info_hsh_ref};
	my $tmp_header_path = "$result_log_dir/tmp.header.txt";

	open (HEADER, ">", "$tmp_header_path");
	print HEADER '%%MatrixMarket matrix coordinate integer general'."\n";
	print HEADER '%'."\n";
	print HEADER "$num_countRegion $num_barcodes $num_line\n";
	close HEADER;
	
	system "cat $tmp_header_path $tmp_count_path >$result_matrix_dir/matrix.mtx";
	system "rm $tmp_header_path";
	system "rm $tmp_count_path";
	
	return ();
}
sub printOutputFileListAndReadme {
#....................................................................................................................................................#
#	subroutineCategory: output
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 4_finishingTasks|165
#	secondaryAppearInSection: >none
#	input: $ARGVStr, $outDir, $paramTag
#	output: 
#	toCall: &printOutputFileListAndReadme($ARGVStr, $paramTag, $outDir);
#	calledInLine: 168
#....................................................................................................................................................#
	my ($ARGVStr, $paramTag, $outDir) = @_;
	
	my $outputFileListPath = "$outDir/$paramTag/output.file.list.txt";
	open (OUTFILELIST, ">", $outputFileListPath);

	my %dirHsh = ();
	my %filelistLenCountHsh = ();
	push @{$filelistLenCountHsh{'dir'}}, length 'Directory';
	push @{$filelistLenCountHsh{'name'}}, length 'Name';
	push @{$filelistLenCountHsh{'description'}}, length 'Description';
	
	foreach my $outputFilePath (sort {$a cmp $b} keys %{$globalReadmeHsh_ref}) {
		my $fileDescription =  $globalReadmeHsh_ref->{$outputFilePath}{'description'};
		my $cleandOutputFilePath = $outputFilePath;
		$cleandOutputFilePath =~ s/\/+/\//g;
		
		my ($filePrefix, $fileDir, $fileSuffix) = fileparse($cleandOutputFilePath, qr/\.[^.]*/);
		$fileDir =~ s/^$outDir//;
		my $fileName = $filePrefix.$fileSuffix;
		$dirHsh{$fileDir}{$fileName} = $fileDescription;
		push @{$filelistLenCountHsh{'dir'}}, length $fileDir;
		push @{$filelistLenCountHsh{'name'}}, length $fileName;
		push @{$filelistLenCountHsh{'description'}}, length $fileDescription;
		
		open README, ">", "$outputFilePath.readme.txt";
		print README "=================\n";
		print README "File descriptions\n";
		print README "=================\n";
		print README "$fileDescription\n";
					
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}) {
			my @colLenCountHsh = (length 'column');
			push @colLenCountHsh, length $_ foreach (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}});
			my $headerColLen = max(@colLenCountHsh)+2;
			print README "\n";
			print README "\n";
			print README "===================\n";
			print README "Column descriptions\n";
			print README "===================\n";
			print README "\n";
			printf README "%-".$headerColLen."s", 'column';
			print README "description\n";
			printf README "%-".$headerColLen."s", '------';
			print README "-----------\n";
			foreach my $header (@{$globalReadmeHsh_ref->{$outputFilePath}{'headerAry'}}) {
				my $columnDescription = 'self-explanatory';
				$columnDescription = $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header} if exists $globalReadmeHsh_ref->{$outputFilePath}{'header'}{$header};
				printf README "%-".$headerColLen."s", $header;
				print README $columnDescription."\n";
			}
		}
		
		if (exists $globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}) {
			print README "\n";
			print README "\n";
			print README "=================\n";
			print README "Extra information\n";
			print README "=================\n";
			print README "\n";
			foreach my $title (sort keys %{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}}) {
				print README "$title\n";
				print README "-" foreach (1..length $title);
				print README "\n";
				print README "$_\n" foreach @{$globalReadmeHsh_ref->{$outputFilePath}{'extra_info'}{$title}};
			}
		}
		
		print README "\n";
		print README "\n";
		print README "~" foreach (1..length "$fileName was created from running,");
		print README "\n";
		print README "$fileName was created from running,\n";
		print README "\n";
		print README "$ARGVStr\n";
		print README "\n";
		close README;
	}

	my $fileDir_colLen = max(@{$filelistLenCountHsh{'dir'}})+2;
	my $fileName_colLen = max(@{$filelistLenCountHsh{'name'}})+2;
	my $fileDescription_colLen = max(@{$filelistLenCountHsh{'description'}})+2;
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", 'directory', 'name', 'description');
	printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", '=========', '====', '===========');
	foreach my $fileDir (sort {$a cmp $b} keys %dirHsh) {
		foreach my $fileName (sort {$a cmp $b} keys %{$dirHsh{$fileDir}}) {
			my $fileDescription = $dirHsh{$fileDir}{$fileName};	
			printf OUTFILELIST ("%-".$fileDir_colLen."s %-".$fileName_colLen."s %-".$fileDescription_colLen."s\n", $fileDir, $fileName, $fileDescription);
		}
	}
	
	print OUTFILELIST "\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "~" foreach (1..length "The above files were generated by running,");
	print OUTFILELIST "\n";
	print OUTFILELIST "The above files were generated by running,\n";
	print OUTFILELIST "\n";
	print OUTFILELIST "$ARGVStr\n";
	print OUTFILELIST "\n";

	close OUTFILELIST;

	return ();
}
sub printStartOrFinishMessage {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: currentTime|325
#	appearInSub: >none
#	primaryAppearInSection: 2_defineOutDirPath|134, 4_finishingTasks|165
#	secondaryAppearInSection: >none
#	input: $StartOrFinishMessage
#	output: none
#	toCall: &printStartOrFinishMessage($StartOrFinishMessage);
#	calledInLine: 147, 169
#....................................................................................................................................................#

	my ($StartOrFinishMessage) = @_;
	
	if ($StartOrFinishMessage eq "startMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] starts running ...... \n";#->325
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] starts running ...... \n";#->325
		print $tmplog_fh "=========================================================================\n\n";

	} elsif ($StartOrFinishMessage eq "finishMessage") {
		print "\n=========================================================================\n";
		print "[".&currentTime()."] finished running .......\n";#->325
		print "=========================================================================\n\n";

		print $tmplog_fh "\n=========================================================================\n";
		print $tmplog_fh "[".&currentTime()."] finished running .......\n";#->325
		print $tmplog_fh "=========================================================================\n\n";
	}
}
sub readCellBarcodeList {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|709
#	appearInSub: >none
#	primaryAppearInSection: 3_output|153
#	secondaryAppearInSection: >none
#	input: $cellBarcode_list_path
#	output: $cellBarcode_info_hsh_ref
#	toCall: my ($cellBarcode_info_hsh_ref) = &readCellBarcodeList($cellBarcode_list_path);
#	calledInLine: 157
#....................................................................................................................................................#
	my ($cellBarcode_list_path) = @_;

	my $cellBarcode_info_hsh_ref = {};

	&reportAndLogStatus("reading cell barcode info", 0, "\n");#->709
	
	if ($cellBarcode_list_path =~ m/\.gz$/) {
		open (CELLBARCODE, " gzip -dc $cellBarcode_list_path|");
	} else {
		open (CELLBARCODE, "<", $cellBarcode_list_path);
	}
	my $cellBarcode_index = 1;
	
	while (<CELLBARCODE>) {
		chomp;
		next if $_ =~ m/^#/;
		my ($cellBarcode) = split /\t/;
		die "$cellBarcode is duplicated\n" if exists $cellBarcode_info_hsh_ref->{$cellBarcode};
		$cellBarcode_info_hsh_ref->{$cellBarcode}{'cellBarcode_index'} = $cellBarcode_index;
		$cellBarcode_info_hsh_ref->{$cellBarcode}{'umi_count'} = 0;
		$cellBarcode_index++;
	}
	close CELLBARCODE;
	
	my $num_cellBarcode = keys %{$cellBarcode_info_hsh_ref};
	&reportAndLogStatus("info of $num_cellBarcode cell barcode stored", 0, "\n");#->709
		
	return ($cellBarcode_info_hsh_ref);
}
sub readCountRegionInfo {
#....................................................................................................................................................#
#	subroutineCategory: unassigned
#	dependOnSub: reportAndLogStatus|709
#	appearInSub: >none
#	primaryAppearInSection: 3_output|153
#	secondaryAppearInSection: >none
#	input: $countRegion_bed_path
#	output: $countRegion_info_hsh_ref
#	toCall: my ($countRegion_info_hsh_ref) = &readCountRegionInfo($countRegion_bed_path);
#	calledInLine: 156
#....................................................................................................................................................#
	my ($countRegion_bed_path) = @_;
	
	my $countRegion_info_hsh_ref = {};

	&reportAndLogStatus("reading count region info", 0, "\n");#->709
	if ($countRegion_bed_path =~ m/\.gz$/) {
		open (COUNTREGION, " gzip -dc $countRegion_bed_path |");
	} else {
		open (COUNTREGION, "<", $countRegion_bed_path);
	}
	my $countRegion_index = 1;
	while (<COUNTREGION>) {
		chomp;
		my ($chrom, $chromStart, $chromEnd, $countRegion_ID) = split /\t/;
		my $countRegion_name = $countRegion_ID;
		die "$countRegion_ID is duplicated\n" if exists $countRegion_info_hsh_ref->{$countRegion_ID};

		$countRegion_info_hsh_ref->{$countRegion_ID}{'countRegion_index'} = $countRegion_index;
		$countRegion_info_hsh_ref->{$countRegion_ID}{'countRegion_name'} = $countRegion_name;
		$countRegion_info_hsh_ref->{$countRegion_ID}{'umi_count'} = 0;
		$countRegion_index++;
	}
	close COUNTREGION;
	
	my $num_countRegion = keys %{$countRegion_info_hsh_ref};
	&reportAndLogStatus("info of $num_countRegion countRegion stored", 0, "\n");#->709
		
	return ($countRegion_info_hsh_ref);
}
sub readParameters {
#....................................................................................................................................................#
#	subroutineCategory: general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: 0_startingTasks|118
#	secondaryAppearInSection: >none
#	input: none
#	output: $cellBarcode_list_path, $countRegion_bed_path, $ctss_bed_path, $ctss_scope_bed_path, $ctss_scope_slop_bp, $genome, $outDir, $outputPrefix, $overwrite
#	toCall: my ($countRegion_bed_path, $ctss_bed_path, $cellBarcode_list_path, $ctss_scope_bed_path, $ctss_scope_slop_bp, $genome, $outputPrefix, $outDir, $overwrite) = &readParameters();
#	calledInLine: 121
#....................................................................................................................................................#
	
	my ($countRegion_bed_path, $ctss_bed_path, $cellBarcode_list_path, $ctss_scope_bed_path, $ctss_scope_slop_bp, $genome, $outputPrefix, $outDir, $overwrite);
	$overwrite = 'no';
	$ctss_scope_slop_bp = 0;
	$ctss_scope_bed_path = undef;
	
	GetOptions 	(
		"countRegion_bed_path=s"	=>	\$countRegion_bed_path,
		"cellBarcode_list_path=s"	=>	\$cellBarcode_list_path,
		"genome=s"						=>	\$genome,
		"ctss_bed_path=s"				=>	\$ctss_bed_path,
		"outputPrefix=s"				=>	\$outputPrefix,
		"outDir=s"						=>	\$outDir,
		"ctss_scope_bed_path:s"		=>	\$ctss_scope_bed_path,
		"ctss_scope_slop_bp:s"		=>	\$ctss_scope_slop_bp,
		"overwrite:s"					=>	\$overwrite,
		'help'							=>	sub { HelpMessage(0) },
	) or HelpMessage(1);

	HelpMessage(1) unless $countRegion_bed_path;
	
	#---check file
	my $file_check_hsh_ref = {
		'countRegion_bed_path' => $countRegion_bed_path,
		'cellBarcode_list_path' => $cellBarcode_list_path,
		'ctss_bed_path' => $ctss_bed_path,
	};
	
	$file_check_hsh_ref->{'ctss_scope_bed_path'} = $ctss_scope_bed_path if defined $ctss_scope_bed_path;
	
	foreach my $option_name (keys %{$file_check_hsh_ref}) {
		my $file_path = $file_check_hsh_ref->{$option_name};
		die "Quitting: File $option_name does not exists at $file_path" if not -s $file_path;
	}
	
	die "Quitting: ctss_scope_slop_bp must be integer\n" if ($ctss_scope_slop_bp !~ m/^\d+$/);
	
	chop $outDir if ($outDir =~ m/\/$/); #---remove the last slash
	system "mkdir -p -m 755 $outDir/";
	
	return($countRegion_bed_path, $ctss_bed_path, $cellBarcode_list_path, $ctss_scope_bed_path, $ctss_scope_slop_bp, $genome, $outputPrefix, $outDir, $overwrite);
}
sub reportAndLogStatus {
#....................................................................................................................................................#
#	subroutineCategory: log
#	dependOnSub: currentTime|325
#	appearInSub: checkAllExecutable|203, printMatrix|368, readCellBarcodeList|573, readCountRegionInfo|614, runBedToolsIntersect|731
#	primaryAppearInSection: >none
#	secondaryAppearInSection: 2_defineOutDirPath|134, 3_output|153
#	input: $lineEnd, $message, $numTrailingSpace
#	output: 
#	toCall: &reportAndLogStatus($message, $numTrailingSpace, $lineEnd);
#	calledInLine: 226, 231, 240, 249, 258, 267, 276, 285, 294, 381, 588, 609, 629, 650, 753, 756, 760, 804, 822, 823
#....................................................................................................................................................#
	my ($message, $numTrailingSpace, $lineEnd) = @_;

	my $trailingSpaces = '';
	$trailingSpaces .= " " for (1..$numTrailingSpace);
	
	print "[".&currentTime()."] ".$message.$trailingSpaces.$lineEnd;#->325
	print $tmplog_fh "[".&currentTime()."] ".$message.$lineEnd if $lineEnd ne "\r";#->325
	
	return ();
}
sub runBedToolsIntersect {
#....................................................................................................................................................#
#	subroutineCategory: range
#	dependOnSub: reportAndLogStatus|709
#	appearInSub: >none
#	primaryAppearInSection: 3_output|153
#	secondaryAppearInSection: >none
#	input: $bedtools_bin, $cellBarcode_info_hsh_ref, $chrom_size_path, $countRegion_bed_path, $countRegion_info_hsh_ref, $ctss_bed_path, $ctss_scope_bed_path, $ctss_scope_slop_bp, $result_log_dir, $result_matrix_dir
#	output: $tmp_count_path
#	toCall: my ($tmp_count_path) = &runBedToolsIntersect($countRegion_bed_path, $ctss_bed_path, $countRegion_info_hsh_ref, $cellBarcode_info_hsh_ref, $result_matrix_dir, $ctss_scope_bed_path, $ctss_scope_slop_bp, $chrom_size_path, $result_log_dir, $bedtools_bin);
#	calledInLine: 159
#....................................................................................................................................................#

	my ($countRegion_bed_path, $ctss_bed_path, $countRegion_info_hsh_ref, $cellBarcode_info_hsh_ref, $result_matrix_dir, $ctss_scope_bed_path, $ctss_scope_slop_bp, $chrom_size_path, $result_log_dir, $bedtools_bin) = @_;

	my $tmp_count_path = "$result_log_dir/tmp.sparse.count.txt";
	open (COUNT, "| sort -k2,2n -k1,1n >$tmp_count_path");

	my $tmp_count_hsh_ref = {};
	my $last_countRegion_ID;
	
	if (defined $ctss_scope_bed_path) {
		if ($ctss_scope_slop_bp > 0) {
			&reportAndLogStatus("Start running bedtools intersect with ctss scope and slop distance $ctss_scope_slop_bp. Be patient.", 10, "\n");#->709
			open BEDTOOLS, "$bedtools_bin slop -b $ctss_scope_slop_bp -g $chrom_size_path -i $ctss_scope_bed_path | cut -f 1-6 | $bedtools_bin intersect -sorted -s -u -a $ctss_bed_path -b stdin | $bedtools_bin intersect -sorted -wo -a $countRegion_bed_path -b stdin |";
		} else {
			&reportAndLogStatus("Start running bedtools intersect with ctss scope. Be patient.", 10, "\n");#->709
			open BEDTOOLS, "$bedtools_bin intersect -sorted -s -u -a $ctss_bed_path -b $ctss_scope_bed_path | $bedtools_bin intersect -sorted -wo -a $countRegion_bed_path -b stdin |";
		}
	} else {
		&reportAndLogStatus("Start running bedtools intersect without ctss scope. Be patient.", 10, "\n");#->709
		open BEDTOOLS, "$bedtools_bin intersect -sorted -wo -a $countRegion_bed_path -b $ctss_bed_path |";
	}

	my $num_proc = 0;
	my $total_count = 0;
	while (<BEDTOOLS>) {
		chomp;
		#chr1	19485502	19485554	p1@CAPZB	639956	-	chr1	19485525	19485526	TGCGCAGAGGCACATG-1	2	-	1

		#my ($chrom, $countRegion_start, $countRegion_end, $curnt_countRegion_ID, undef, $countRegion_strand, undef, undef, undef, $cellBarcode, $umi_num, $CTSS_strand) = split /\t/;
		my @splt = split /\t/;

		my $chrom = $splt[0];
		my $countRegion_start = $splt[1];
		my $countRegion_end = $splt[2];
		my $curnt_countRegion_ID = $splt[3];
		my $countRegion_strand = $splt[5];
		my $CTSS_strand = $splt[-2];
		my $umi_num = $splt[-3];
		my $cellBarcode = $splt[-4];
		
		if (($countRegion_strand eq '.' or $countRegion_strand eq $CTSS_strand) and 
			exists $cellBarcode_info_hsh_ref->{$cellBarcode} and 
			exists $countRegion_info_hsh_ref->{$curnt_countRegion_ID}) {
			
			$tmp_count_hsh_ref->{$curnt_countRegion_ID}{$cellBarcode} += $umi_num;
			$cellBarcode_info_hsh_ref->{$cellBarcode}{'umi_count'}+= $umi_num;
			$countRegion_info_hsh_ref->{$curnt_countRegion_ID}{'umi_count'}+= $umi_num;
			
			$last_countRegion_ID = $curnt_countRegion_ID if not defined $last_countRegion_ID;
			
			if ($curnt_countRegion_ID ne $last_countRegion_ID) {
				my $countRegion_index = $countRegion_info_hsh_ref->{$last_countRegion_ID}{'countRegion_index'};
				foreach my $cellBarcode (keys %{$tmp_count_hsh_ref->{$last_countRegion_ID}}) {
					my $umi_count = $tmp_count_hsh_ref->{$last_countRegion_ID}{$cellBarcode};
					my $cellBarcode_index = $cellBarcode_info_hsh_ref->{$cellBarcode}{'cellBarcode_index'};
					$total_count += $umi_count;
					print COUNT join "", (join " ", ($countRegion_index, $cellBarcode_index, $umi_count)), "\n";
				}
				delete $tmp_count_hsh_ref->{$last_countRegion_ID};
				$last_countRegion_ID = $curnt_countRegion_ID;
				$num_proc++;
				if ($num_proc%1000 == 0) {
					&reportAndLogStatus("$num_proc countRegion counted", 10, "\n");#->709
				}
			}
			
			if (eof(BEDTOOLS)) {
				foreach my $countRegion_ID (sort keys %{$tmp_count_hsh_ref}) {
					my $countRegion_index = $countRegion_info_hsh_ref->{$countRegion_ID}{'countRegion_index'};
					foreach my $cellBarcode (sort keys %{$tmp_count_hsh_ref->{$countRegion_ID}}) {
						my $cellBarcode_index = $cellBarcode_info_hsh_ref->{$cellBarcode}{'cellBarcode_index'};
						my $umi_count = $tmp_count_hsh_ref->{$countRegion_ID}{$cellBarcode};
						$total_count += $umi_count;
						print COUNT join "", (join " ", ($countRegion_index, $cellBarcode_index, $umi_count)), "\n";
					}
				}
			}
		}
	}

	&reportAndLogStatus("$num_proc countRegion counted", 10, "\n");#->709
	&reportAndLogStatus("total_count within countRegion = $total_count", 10, "\n");#->709

	close COUNT;
	close (BEDTOOLS);
	
	return ($tmp_count_path);
}
sub timeStamp {
#....................................................................................................................................................#
#	subroutineCategory: time, general
#	dependOnSub: >none
#	appearInSub: >none
#	primaryAppearInSection: >none
#	secondaryAppearInSection: >none
#	input: none
#	output: $curntTimeStamp
#	toCall: my ($curntTimeStamp) = &timeStamp();
#	calledInLine: 106
#....................................................................................................................................................#
	
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)=localtime(time);
	my $curntTimeStamp = sprintf "%04d.%02d.%02d.%02d.%02d.%02d", $year+1900,$mon+1,$mday,$hour,$min,$sec;	

	return ($curntTimeStamp);
}

exit;


















































